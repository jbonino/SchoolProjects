'From Squeak5.1 of 23 August 2016 [latest update: #16548] on 30 October 2016 at 11:24:16 pm'!WeakIdentityKeyDictionary subclass: #ASTCache	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!ASTCache commentStamp: '<historical>' prior: 0!I am a simple cache for AST nodes corresponding to CompiledMethods in the image. The cache is emptied when the image is saved.!Object subclass: #BrowserEnvironment	instanceVariableNames: 'label searchStrings'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!BrowserEnvironment subclass: #BrowserEnvironmentWrapper	instanceVariableNames: 'environment'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!BrowserEnvironmentWrapper subclass: #AndEnvironment	instanceVariableNames: 'andedEnvironment'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!Model subclass: #CategoryAndClassSelector	instanceVariableNames: 'done classes classCategories'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!BrowserEnvironmentWrapper subclass: #CategoryEnvironment	instanceVariableNames: 'categories'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!RectangleMorph subclass: #ChooserMorph	instanceVariableNames: 'response done cancelBlock list listSelections values isMultipleSelect listIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!ASTCache class	instanceVariableNames: 'default'!BrowserEnvironmentWrapper subclass: #ClassEnvironment	instanceVariableNames: 'classes metaClasses'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!Model subclass: #ClassToRename	instanceVariableNames: 'rewriteRule builder class'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!ClassToRename class	instanceVariableNames: 'notUsed'!TestCase subclass: #DuplicationNodeEliminationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!TestCase subclass: #ExampleParserTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!Object subclass: #FinderTool	instanceVariableNames: 'searchString conditionString searchEnvironment foundEnvironment searchClass searchMethods'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!!FinderTool commentStamp: 'nk 2/25/2005 10:53' prior: 0!To match unknown code, use "Jokers" (explained below) that start with a ` , like the `@Expression in the example.That Joker will match any expression: 3 halt and (3 + 4) halt both match.The condition (second) paneBeyond the pattern match in the top pane, the expression found is also checked against a test condition in the second pane. Within that condition, aNode is set to each node that matches the pattern. If that pane is empty, the default pattern is true which is equivalent to this test block:[:aNode | true]Edit the second pane to make the test block more selective.See below for a quick reference to the node accessors and some tests.Browse RBProgramNode and subclasses to see what other tests they support.Joker referenceAll of the wild-card patterns used in the FinderTool start with a ` character. They include:`#literal		matches any literal (#(), #foo, 1, etc.)`@	(list of...) When applied to a variable node, this will match a literal, variable, or a sequence of messages sent to a literal or variable.When applied to a keyword in a message, it will match a list of keyword messages (i.e., any message send).When applied with a statement character, it will match a list of statements.	| `@Temps |				matches list of temps	`@.Statements			matches list of statements	`@object					matches any message node, literal node or block node	foo `@message: `@args	matches any message sent to foo`.Statement				matches a single statement in a sequence node`@.Statements			matches list of statements in a sequence node`		(recurse into)Whenever a match is found, look inside this matched node for more matches.	``@object foo				matches foo sent to any object, plus for each match found look for more matches in the ``@object part`{ :node :context | code }		Abitrary code; matches if code returns true. Block is passed the node being examined, and a Dictionary that can be used to hold context. The context is reset every method.For more information on Joker, aka meta-variables, see this page on the rewrite rule editor, with whom this tool shares much logic. http://st-www.cs.uiuc.edu/users/brant/Refactory/Rewrite.htmlTest condition quick referenceBrowse RBProgramNode and subclasses to see what other tests the nodes support.accessors:allArgumentVariables allDefinedVariables allTemporaryVariables asReturn blockVariables children comments comments: formattedCode formatterClass parent parent: precedence sentMessages source sourceInterval start stop temporaryVariablestests:isList isPatternNode assigns: containedBy: containsReturn defines: directlyUses: evaluatedFirst: intersectsInterval: isAssignment isBlock isCascade isDirectlyUsed isEvaluatedFirst isImmediate isLast: isLiteral isMessage isMethod isReturn isSequence isUsed isValue isVariable lastIsReturn references: uses:!TestCase subclass: #LineNumberStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!Model subclass: #LintDialog	instanceVariableNames: 'environment tests testCategories results selector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!Object subclass: #LintRule	instanceVariableNames: 'name rationale'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!LintRule subclass: #BasicLintRule	instanceVariableNames: 'result openSymbol'	classVariableNames: 'FilterDictionary'	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!BasicLintRule subclass: #BlockLintRule	instanceVariableNames: 'classBlock methodBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!LintRule subclass: #CompositeLintRule	instanceVariableNames: 'rules'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!Object subclass: #LintRuleTest	instanceVariableNames: 'name foo1'	classVariableNames: 'Foo1'	poolDictionaries: 'TextConstants'	category: 'RefactoringEngine-Testdata'!LintRuleTest subclass: #BasicLintRuleTest	instanceVariableNames: 'classBlock methodBlock result'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!LintRuleTest subclass: #CompositeLintRuleTest	instanceVariableNames: 'rules'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!LintRuleTest subclass: #FooLintRuleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!Model subclass: #MethodNameEditor	instanceVariableNames: 'argumentListIndex methodName accepted modalView bodyPane'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!BrowserEnvironmentWrapper subclass: #MultiEnvironment	instanceVariableNames: 'environmentDictionaries'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!Model variableSubclass: #MultipleSelectionModel	instanceVariableNames: 'model list selection getList getMenu primary'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!BrowserEnvironmentWrapper subclass: #NotEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!Object subclass: #NumberParser	instanceVariableNames: 'sourceStream base neg integerPart fractionPart exponent scale nDigits lastNonZero requestor failBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!NumberParser commentStamp: 'nice 2/13/2010 00:31' prior: 0!NumberParser is an abstract class for parsing and building numbers from string/stream.It offers a framework with utility methods and exception handling.Number syntax is not defined and should be subclassResponsibility.Instance variables:sourceStream <Stream> the stream of characters from which the number is readbase <Integer> the radix in which to interpret digitsneg <Boolean> true in case of minus signintegerPart <Integer> the integer part of the numberfractionPart <Integer> the fraction part of the number if anyexponent <Integer> the exponent used in scientific notation if anyscale <Integer> the scale used in case of ScaledDecimal number if anynDigits <Integer> number of digits read to form an IntegerlasNonZero <Integer> position of last non zero digit, starting at 1 from left, 0 if all digits are zerorequestor <?> could eventually be used to insert an error message in a text editorfailBlock <BlockClosure> Block to execute whenever an error occurs!BrowserEnvironmentWrapper subclass: #PackageEnvironment	instanceVariableNames: 'package'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!BasicLintRule subclass: #ParseTreeLintRule	instanceVariableNames: 'matcher'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!TestCase subclass: #ParserGeneratorTest	instanceVariableNames: 'wrappers'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!Object subclass: #ParserRecompiler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!BrowserEnvironmentWrapper subclass: #ProtocolEnvironment	instanceVariableNames: 'class protocols'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!Object subclass: #RBAbstractClass	instanceVariableNames: 'name newMethods instanceVariableNames model superclass subclasses removedMethods realClass'	classVariableNames: 'LookupSuperclass'	poolDictionaries: ''	category: 'RefactoringEngine-Model'!Object subclass: #RBAbstractCondition	instanceVariableNames: 'errorMacro'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Conditions'!RBAbstractClass subclass: #RBClass	instanceVariableNames: 'classVariableNames poolDictionaryNames category'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Model'!Object subclass: #RBComment	instanceVariableNames: 'contents start'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBComment commentStamp: '<historical>' prior: 0!A RBComment represents a text comment associated to an AST node.!RBAbstractCondition subclass: #RBCondition	instanceVariableNames: 'block type errorBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Conditions'!RBAbstractCondition subclass: #RBConjunctiveCondition	instanceVariableNames: 'left right failed'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Conditions'!RBAbstractClass subclass: #RBMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Model'!Object subclass: #RBMethod	instanceVariableNames: 'class compiledMethod source selector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Model'!Object subclass: #RBMethodName	instanceVariableNames: 'selector arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Support'!Object subclass: #RBNamespace	instanceVariableNames: 'changes environment newClasses removedClasses changedClasses rootClasses implementorsCache sendersCache'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Model'!RBAbstractCondition subclass: #RBNegationCondition	instanceVariableNames: 'condition'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Conditions'!Object subclass: #RBParseTreeRule	instanceVariableNames: 'searchTree owner'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBParseTreeRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.Instance Variables:	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.	searchTree	<RBProgramNode>	The parse tree to be searched.!Object subclass: #RBParser	instanceVariableNames: 'scanner currentToken nextToken errorBlock source comments pragmas'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!RBParser commentStamp: '<historical>' prior: 0!RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either 'RBParser parseExpression: aString' if you want the AST for an expression, or 'RBParser parseMethod: aString' if you want to parse an entire method.Instance Variables:	currentToken	<RBToken>	The current token being processed.	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren't.	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.	source	<String>	The source code to parse	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)Shared Variables:	ParserType	<Symbol>	the type code we are parsing!RBParser subclass: #RBExplicitVariableParser	instanceVariableNames: 'currentVariableNodeClass currentScope'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!RBExplicitVariableParser commentStamp: '<historical>' prior: 0!I am a specialized version of the RBParser that takes the specialized sublcasses of RBVariableNode into account.!RBParser subclass: #RBPatternParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!RBPatternParser commentStamp: '<historical>' prior: 0!RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.!Object subclass: #RBProgramNode	instanceVariableNames: 'parent properties'	classVariableNames: 'FormatterClass'	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBProgramNode commentStamp: '<historical>' prior: 0!RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.Subclasses must implement the following messages:	accessing		start		stop	visitor		acceptVisitor:The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.Instance Variables:	comments	<Collection of: Interval>	the intervals in the source that have comments for this node	parent	<RBProgramNode>	the node we're contained inShared Variables:	FormatterClass	<Behavior>	the formatter class that is used when we are formatted!RBProgramNode subclass: #RBMethodNode	instanceVariableNames: 'scope selector keywordsPositions body source arguments pragmas replacements nodeReplacements compilationContext'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBMethodNode commentStamp: '<historical>' prior: 0!RBMethodNode is the AST that represents a Smalltalk method.Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method	body	<BRSequenceNode>	the body/statements of the method	nodeReplacements	<Dictionary>	a dictionary of oldNode -> newNode replacements	replacements	<Collection of: RBStringReplacement>	the collection of string replacements for each node replacement in the parse tree	selector	<Symbol>	the method name	keywordsPositions	<IntegerArray | nil>	the positions of the selector keywords	source	<String>	the source we compiled	tags	<Collection of: Interval>	the source location of any resource/primitive tags!RBProgramNode subclass: #RBParseErrorNode	instanceVariableNames: 'errorMessage value start'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBParseErrorNode commentStamp: '<historical>' prior: 0!I am a node representing a source code segement that could not be parsed. I am manly used for source-code coloring where we should parse as far as possible and mark the rest as a failure.!RBMethodNode subclass: #RBPatternMethodNode	instanceVariableNames: 'isList'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!!RBPatternMethodNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. Instance Variables:	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!RBProgramNode subclass: #RBPragmaNode	instanceVariableNames: 'selector keywordsPositions arguments left right'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBPragmaNode commentStamp: '<historical>' prior: 0!RBPragmaNode is an AST node that represents a method pragma.Instance Variables:	arguments <SequenceableCollection of: RBLiteralNode> our argument nodes	left <Integer | nil> position of <	right <Integer | nil> position of >	selector	<Symbol>	the selector we're sending	keywordsPositions	<IntegerArray | nil>	the positions of the selector keywords!RBPragmaNode subclass: #RBPatternPragmaNode	instanceVariableNames: 'isList'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!RBParseTreeRule subclass: #RBReplaceRule	instanceVariableNames: 'verificationBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Subclasses must implement the following messages:	matching		foundMatchFor:Instance Variables:	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.!RBReplaceRule subclass: #RBBlockReplaceRule	instanceVariableNames: 'replaceBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBBlockReplaceRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBReturnNode commentStamp: '<historical>' prior: 0!RBReturnNode is an AST node that represents a return expression.Instance Variables:	return	<Integer>	the position of the ^ character	value	<RBValueNode>	the value that is being returned!Object subclass: #RBScanner	instanceVariableNames: 'stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock'	classVariableNames: 'PatternVariableCharacter'	poolDictionaries: ''	category: 'AST-Core-Parser'!!RBScanner commentStamp: '<historical>' prior: 0!RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.Instance Variables:	buffer	<PositionableStream>	Accumulates the text for the current token.	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.	currentCharacter	<Character>	The character currently being processed.	errorBlock	<BlockClosure>	The block to execute on lexical errors.	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.	nameSpaceCharacter	<Character>	The character used to separate namespaces.	numberType	<ByteSymbol>	The method to perform: to scan a number. 	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.	stream	<PositionableStream>	Contains the text to be scanned.	tokenStart	<Integer>	The source position of the beginning of the current tokenClass Instance Variables:	classificationTable	<Array>		the default classification table for all charactersShared Variables:	PatternVariableCharacter	<Character>	the character that starts a pattern node!RBScanner subclass: #RBPatternScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Parser'!!RBPatternScanner commentStamp: '<historical>' prior: 0!RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.!RBScanner class	instanceVariableNames: 'classificationTable'!RBParseTreeRule subclass: #RBSearchRule	instanceVariableNames: 'answerBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBSearchRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).Instance Variables:	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.!RBProgramNode subclass: #RBSequenceNode	instanceVariableNames: 'leftBar rightBar statements periods temporaries'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBSequenceNode commentStamp: '<historical>' prior: 0!RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.Instance Variables:	leftBar	<Integer | nil>	the position of the left | in the temporaries definition	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements	rightBar	<Integer | nil>	the position of the right | in the temporaries definition	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined!RBReplaceRule subclass: #RBStringReplaceRule	instanceVariableNames: 'replaceTree'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBStringReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.Instance Variables:	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.!Object subclass: #RBStringReplacement	instanceVariableNames: 'startPosition stopPosition string'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBStringReplacement commentStamp: '<historical>' prior: 0!RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.Instance Variables:	startPosition	<Integer>	the start position in the original source	stopPosition	<Integer>	the end position in the original source	string	<String>	replaces everything from the startPosition to the endPosition with this string!Object subclass: #RBToken	instanceVariableNames: 'sourcePointer comments'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBToken commentStamp: '<historical>' prior: 0!RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser's) remember where they came from in the original source code.Subclasses must implement the following messages:	accessing		lengthInstance Variables:	sourcePointer	<Integer>	The position in the original source code where this token began.!RBToken subclass: #RBAssignmentToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBAssignmentToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBAssignmentToken is the first-class representation of the assignment token ':='!RBAssignmentToken subclass: #RBShortAssignmentToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!RBProgramNode subclass: #RBValueNode	instanceVariableNames: 'parentheses'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBValueNode commentStamp: '<historical>' prior: 0!RBValueNode is an abstract class that represents a node that returns some value.Subclasses must implement the following messages:	accessing		startWithoutParentheses		stopWithoutParentheses	testing		needsParenthesisInstance Variables:	parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.!RBValueNode subclass: #RBArrayNode	instanceVariableNames: 'left right statements periods'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBArrayNode commentStamp: '<historical>' prior: 0!A RBArrayNode is an AST node for runtime arrays.Instance Variables	left:	 <Integer | nil> position of {	periods: <SequenceableCollection of: Integer> the positions of all the periods that separate the statements	right: <Integer | nil> position of }	statements: <SequenceableCollection of: RBStatementNode> the statement nodes!RBValueNode subclass: #RBAssignmentNode	instanceVariableNames: 'variable assignment value'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBAssignmentNode commentStamp: '<historical>' prior: 0!RBAssignmentNode is an AST node for assignment statementsInstance Variables:	assignment	<Integer>	position of the :=	value	<RBValueNode>	the value that we're assigning	variable	<RBVariableNode>	the variable being assigned!RBValueNode subclass: #RBBlockNode	instanceVariableNames: 'left right colons arguments bar body scope'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBBlockNode commentStamp: '<historical>' prior: 0!RBBlockNode is an AST node that represents a block "[...]".Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block	bar	<Integer | nil>	position of the | after the arguments	body	<RBSequenceNode>	the code inside the block	colons	<SequenceableCollection of: Integer>	positions of each : before each argument	left	<Integer>	position of [	right	<Integer>	position of ]!RBValueNode subclass: #RBCascadeNode	instanceVariableNames: 'messages semicolons'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBCascadeNode commentStamp: '<historical>' prior: 0!RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").Instance Variables:	messages	<SequenceableCollection of: RBMessageNode>	the messages 	semicolons	<SequenceableCollection of: Integer>	positions of the ; between messages!RBValueNode subclass: #RBLiteralNode	instanceVariableNames: 'start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBLiteralNode commentStamp: '<historical>' prior: 0!RBLiteralNode is an AST node that represents literals.Instance Variables	start: <Integer | nil> source position for the literal's beginning	stop: <Integer | nil> source position for the literal's end!RBLiteralNode subclass: #RBLiteralArrayNode	instanceVariableNames: 'isByteArray contents'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBLiteralArrayNode commentStamp: '<historical>' prior: 0!A RBLiteralArrayNode is an AST node that represents literal arrays and literal byte arrays.Instance Variables	contents: <Array of: RBLiteralNode> literal nodes of the array	isByteArray: <Boolean> if the receiver is a literal byte array!RBLiteralNode subclass: #RBLiteralValueNode	instanceVariableNames: 'value sourceText'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBLiteralValueNode commentStamp: '<historical>' prior: 0!RBLiteralNode is an AST node that represents literal values (e.g., #foo, true, 1, etc.), but not literal arrays.Instance Variables	value	<Numeric | Symbol | String  | Character>	the literal value I represent!RBValueNode subclass: #RBMessageNode	instanceVariableNames: 'receiver selector keywordsPositions arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBMessageNode commentStamp: '<historical>' prior: 0!RBMessageNode is an AST node that represents a message send.Instance Variables:	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes	receiver	<RBValueNode>	the receiver's node	selector	<Symbol>	the selector we're sending	keywordsPositions	<IntegerArray | nil>	the positions of the selector keywords!RBBlockNode subclass: #RBPatternBlockNode	instanceVariableNames: 'valueBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!!RBPatternBlockNode commentStamp: 'md 8/9/2005 14:56' prior: 0!RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.Instance Variables:	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.!RBMessageNode subclass: #RBPatternMessageNode	instanceVariableNames: 'isList isCascadeList'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!!RBPatternMessageNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. Instance Variables:	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!RBPatternBlockNode subclass: #RBPatternWrapperBlockNode	instanceVariableNames: 'wrappedNode'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!!RBPatternWrapperBlockNode commentStamp: '<historical>' prior: 0!RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.Instance Variables:	wrappedNode	<RBProgramNode>	The original pattern node to match!RBToken subclass: #RBValueToken	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBValueToken commentStamp: '<historical>' prior: 0!RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).Instance Variables:	value	<String>	The value of this token!RBValueToken subclass: #RBBinarySelectorToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBBinarySelectorToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)!RBValueToken subclass: #RBErrorToken	instanceVariableNames: 'cause location'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBErrorToken commentStamp: '<historical>' prior: 0!I'm an scanned error.I can have multiple causes.!RBValueToken subclass: #RBIdentifierToken	instanceVariableNames: 'stopPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBIdentifierToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBIdentifierToken is the first class representation of an identifier token (e.g. Class)!RBValueToken subclass: #RBKeywordToken	instanceVariableNames: 'stopPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBKeywordToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBKeywordToken is the first-class representation of a keyword token (e.g. add:)!RBValueToken subclass: #RBLiteralArrayToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!RBValueToken subclass: #RBLiteralToken	instanceVariableNames: 'stopPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBLiteralToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).Instance Variables:	stopPosition	<Integer>	The position within the source code where the token terminates.!RBLiteralToken subclass: #RBMultiKeywordLiteralToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!RBLiteralToken subclass: #RBNumberLiteralToken	instanceVariableNames: 'source'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!RBValueToken subclass: #RBPatternBlockToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBPatternBlockToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBPatternBlockToken is the first-class representation of the pattern block token.!RBValueToken subclass: #RBSpecialCharacterToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Tokens'!!RBSpecialCharacterToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBSpecialCharacterToken is the first class representation of special characters.!RBValueNode subclass: #RBVariableNode	instanceVariableNames: 'name start'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBVariableNode commentStamp: '<historical>' prior: 0!RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).Instance Variables:	name	<RBValueToken>	the variable's name I represent	nameStart <Integer>	the position where I was found at the source code!RBVariableNode subclass: #RBArgumentNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBArgumentNode commentStamp: '<historical>' prior: 0!I am a specific variable node for method and block arguments.!RBVariableNode subclass: #RBClassReference	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBClassReference commentStamp: '<historical>' prior: 0!I am a specific variable node used for ClassReferences!RBVariableNode subclass: #RBPatternVariableNode	instanceVariableNames: 'recurseInto isList isLiteral isStatement isAnything'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Pattern'!!RBPatternVariableNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").Instance Variables:	isAnything	<Boolean>	can we match any type of node	isList	<Boolean>	can we match a list of items (@)	isLiteral	<Boolean>	only match a literal node (#)	isStatement	<Boolean>	only match statements (.)	recurseInto	<Boolean>	search for more matches in the node we match (`)!RBVariableNode subclass: #RBSelfNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBSelfNode commentStamp: '<historical>' prior: 0!I am a specialized version for the 'self'!RBVariableNode subclass: #RBSuperNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBSuperNode commentStamp: '<historical>' prior: 0!I am a specialized variable node for 'super'!RBVariableNode subclass: #RBTemporaryNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBTemporaryNode commentStamp: '<historical>' prior: 0!I am a specialized variable node for temporary variables!RBVariableNode subclass: #RBThisContextNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Nodes'!!RBThisContextNode commentStamp: '<historical>' prior: 0!I represent the specialized variable named 'thisContext'!Object subclass: #ReceiverAndSelector	instanceVariableNames: 'receiver selector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Object subclass: #Refactoring	instanceVariableNames: 'model options'	classVariableNames: 'RefactoringOptions'	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Refactoring subclass: #AbstractVariablesRefactoring	instanceVariableNames: 'tree fromClass instVarReaders instVarWriters classVarReaders classVarWriters toClasses ignore'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Refactoring subclass: #ClassRefactoring	instanceVariableNames: 'className'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!ClassRefactoring subclass: #AddClassRefactoring	instanceVariableNames: 'category superclass subclasses'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!ClassRefactoring subclass: #ChildrenToSiblingsRefactoring	instanceVariableNames: 'parent subclasses'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Refactoring subclass: #ExpandReferencedPoolsRefactoring	instanceVariableNames: 'pools fromClass parseTree toClasses'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Refactoring subclass: #MethodRefactoring	instanceVariableNames: 'class'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #AddMethodRefactoring	instanceVariableNames: 'protocols source'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #ChangeMethodNameRefactoring	instanceVariableNames: 'newSelector oldSelector permutation implementors'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!ChangeMethodNameRefactoring subclass: #AddParameterRefactoring	instanceVariableNames: 'initializer senders'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #ExtractMethodRefactoring	instanceVariableNames: 'selector extractionInterval extractedParseTree modifiedParseTree parameters needsReturn'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #ExtractMethodToComponentRefactoring	instanceVariableNames: 'selector extractionInterval extractedMethodSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #ExtractToTemporaryRefactoring	instanceVariableNames: 'sourceInterval selector newVariableName parseTree'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #InlineAllSendersRefactoring	instanceVariableNames: 'selector numberReplaced numberNotReplaced'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #InlineMethodRefactoring	instanceVariableNames: 'sourceInterval inlineParseTree sourceParseTree sourceSelector sourceMessage inlineClass'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!InlineMethodRefactoring subclass: #InlineMethodFromComponentRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #InlineTemporaryRefactoring	instanceVariableNames: 'sourceInterval selector sourceTree assignmentNode definingNode'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #MoveMethodRefactoring	instanceVariableNames: 'selector variable moveToClasses parseTree hasOnlySelfReturns selfVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #MoveVariableDefinitionRefactoring	instanceVariableNames: 'selector interval name parseTree blockNodes definingNode'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #PushDownMethodRefactoring	instanceVariableNames: 'selectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!MethodRefactoring subclass: #PushUpMethodRefactoring	instanceVariableNames: 'removeDuplicates selectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!TestCase subclass: #RefactoringBrowserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringBrowserTest subclass: #BrowserEnvironmentTest	instanceVariableNames: 'browser universalEnvironment'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringBrowserTest subclass: #ExtraParsingAndFormattingTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringBrowserTest subclass: #ParserTest	instanceVariableNames: 'currentSelector classSearches rewrites'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringBrowserTest subclass: #RBClassTest	instanceVariableNames: 'objectClass newClass messageNodeClass'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringBrowserTest subclass: #RBNamespaceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!Error subclass: #RefactoringError	instanceVariableNames: 'parameter'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Support'!Object subclass: #RefactoringManager	instanceVariableNames: 'refactorings'	classVariableNames: 'Instance'	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!ServiceProvider subclass: #RefactoringServiceProvider	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Services'!RefactoringBrowserTest subclass: #RefactoringTest	instanceVariableNames: 'manager changeSet model'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AbstractClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AbstractInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AddClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AddClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AddInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AddMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #AddParameterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #ChildrenToSiblingsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #CreateAccessorsForVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #ExtractMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #ExtractMethodToComponentTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #ExtractToTemporaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #InlineAllMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #InlineMethodFromComponentTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #InlineMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #InlineParameterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #InlineTemporaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #MoveMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #MoveVariableDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #ProtectInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PullUpClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PushDownClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PushDownInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PushDownMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PushUpInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #PushUpMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!Exception subclass: #RefactoringWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Support'!Object subclass: #RefactoryChange	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryChange subclass: #CompositeRefactoryChange	instanceVariableNames: 'changes'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!Object subclass: #RefactoryChangeManager	instanceVariableNames: 'undo redo isPerformingRefactoring'	classVariableNames: 'Instance UndoSize'	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryChange subclass: #RefactoryClassChange	instanceVariableNames: 'className isMeta'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryClassChange subclass: #AddClassChange	instanceVariableNames: 'definition superclassName instanceVariableNames classVariableNames poolDictionaryNames category'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryClassChange subclass: #AddMethodChange	instanceVariableNames: 'source selector protocols'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!AddClassChange subclass: #InteractiveAddClassChange	instanceVariableNames: 'controller definedClass'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!AddMethodChange subclass: #InteractiveAddMethodChange	instanceVariableNames: 'controller definedSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!Object subclass: #RefactoryTestDataApp	instanceVariableNames: 'temporaryVariable'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!Object subclass: #RefactoryTyper	instanceVariableNames: 'model class variableTypes bestGuesses variableMessages bindings backpointers methodName selectorLookup'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Support'!RefactoryClassChange subclass: #RefactoryVariableChange	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryVariableChange subclass: #AddClassVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryVariableChange subclass: #AddInstanceVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoryVariableChange subclass: #AddPoolVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoringBrowserTest subclass: #ReferenceFinderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoryClassChange subclass: #RemoveClassChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!Refactoring subclass: #RemoveClassRefactoring	instanceVariableNames: 'classNames'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RemoveClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoryVariableChange subclass: #RemoveClassVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoringTest subclass: #RemoveClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoryVariableChange subclass: #RemoveInstanceVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RefactoringTest subclass: #RemoveInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoryClassChange subclass: #RemoveMethodChange	instanceVariableNames: 'selector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!MethodRefactoring subclass: #RemoveMethodRefactoring	instanceVariableNames: 'selectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RemoveMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!ChangeMethodNameRefactoring subclass: #RemoveParameterRefactoring	instanceVariableNames: 'parameterIndex argument'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RemoveParameterRefactoring subclass: #InlineParameterRefactoring	instanceVariableNames: 'expressions'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RemoveParameterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoryVariableChange subclass: #RemovePoolVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!CompositeRefactoryChange subclass: #RenameClassChange	instanceVariableNames: 'oldName newName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!ClassRefactoring subclass: #RenameClassRefactoring	instanceVariableNames: 'newName class'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RenameClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #RenameClassVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!RefactoringTest subclass: #RenameInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!ChangeMethodNameRefactoring subclass: #RenameMethodRefactoring	instanceVariableNames: 'hasPermutedArguments'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RenameMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!MethodRefactoring subclass: #RenameTemporaryRefactoring	instanceVariableNames: 'selector interval oldName newName parseTree'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #RenameTemporaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!CompositeRefactoryChange subclass: #RenameVariableChange	instanceVariableNames: 'className isMeta oldName newName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RenameVariableChange subclass: #RenameClassVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!RenameVariableChange subclass: #RenameInstanceVariableChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-ChangeObjects'!FinderTool subclass: #RewriteTool	instanceVariableNames: 'replacementString'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!!RewriteTool commentStamp: 'nk 2/25/2005 10:59' prior: 0!This tool searches for code matching the pattern in the top pane that satisfies the condition in the second pane, and lets you replace the found code patterns with the replacement pattern in the bottom pane.You will be shown the potential changes to the code, and you can choose which of them to actually use.You may use Jokers (explained below) defined in the top pane in the replacement text in the bottom pane. These will refer to whatever the corresponding Joker matched.So if you search for:	`@something foo: `@argsand replace it with:	`@something bar: `@argsthen every call to #foo: will be replaced by a call to #bar:.!BrowserEnvironmentWrapper subclass: #SelectorEnvironment	instanceVariableNames: 'classSelectors metaClassSelectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!SelectorEnvironment subclass: #ParseTreeEnvironment	instanceVariableNames: 'matcher'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!Error subclass: #SemanticError	instanceVariableNames: 'node compilationContext'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Exceptions'!TestCase subclass: #SentNotImplementedTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!Object subclass: #SmaCCAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCAction commentStamp: 'jmb' prior: 0!SmaCCAction is an abstract class that represents an action in the LR parsing table.Subclasses must implement the following messages:	accessing		id!SmaCCAction subclass: #SmaCCAcceptAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCAcceptAction commentStamp: 'jmb' prior: 0!SmaCCAcceptAction represents an accept action in the parser (i.e., we have parsed a valid string).!Notification subclass: #SmaCCCompilationNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCCompilationNotification commentStamp: 'jmb' prior: 0!SmaCCCompilationNotification is a notification that is raised when we discover a problem with the parser. For example, a shift/reduce conflict will raise this notification.!Object subclass: #SmaCCEdge	instanceVariableNames: 'toNode transitionObjects'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCEdge commentStamp: '<historical>' prior: 0!SmaCCEdge represents a transition in a Finite Automata (directed graph). It is labeled with the characters or states (possibly none, indicating an epsilon transition) that cause the transition.Instance Variables:	toNode	<SmaCCNode>	The node that this is transitioning to.	transitionObjects	<SortedCollection of: (Character | Symbol)>	The characters or symbols that cause the transition. Note that there are no duplicates and all characters/symbols are sorted.!SmaCCEdge subclass: #SmaCCCharacterEdge	instanceVariableNames: ''	classVariableNames: 'IsExpressions'	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCCharacterEdge commentStamp: '<historical>' prior: 0!SmaCCCharacterEdge is a SmaCCEdge for Character transitions!Object subclass: #SmaCCGrammar	instanceVariableNames: 'type shiftReduceTable symbols scannerDefinition otherStartingSymbols'	classVariableNames: 'IgnoreCase MaximumCharacterValue'	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCGrammar commentStamp: '<historical>' prior: 0!SmaCCGrammar represents a LR(1) or a LALR(1) grammar.Instance Variables:	otherStartingSymbols	<Collection of: SmaCCSymbol>	other starting productions. The first production in the grammar is the defaulting starting position, but this can list other starting positions.	shiftReduceTable	<Dictionary key: SmaCCSymbol value: SmaCCAction class>	when we have a shift/reduce conflict how should we handle it. This table contains the left/right associative rules. Left is a reduce action and right is a shift action.	symbols	<OrderedCollection of: SmaCCSymbol>	all symbols in our grammar -- includes both terminal and non-terminal	tokens	<Dictionary key: String value: SmaCCRegularExpressionNode>	the tokens for our scanner	type	<Symbol>	the type of grammar (LALR1 or LR1)!Object subclass: #SmaCCGrammarCompiler	instanceVariableNames: 'shiftTable itemSets startingStateMap actions parserClass parserDefinitionString scannerCompiler grammar model'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCGrammarCompiler commentStamp: 'jmb' prior: 0!SmaCCGrammarCompiler compiles a SmaCCGrammar.Instance Variables:	actions	<Array>	the action table for the parser. It contains the action (shift/reduce/accept/reject) for each possible state/symbol pair	grammar	<SmaCCGrammar>	our grammar	itemSets	<SequenceableCollection of: SmaCCItemSet>	the item sets for our grammar	model	<RBNameSpace>	where we are compiling our changes into	parserClass	<RBAbstractClass>	the parser class for our changes	parserDefinitionString	<String>	the definition of our parser	scannerCompiler	<SmaCCScannerCompiler>	a compiler for the scanner	shiftTable	<Dictionary key: (Array with: Integer with: SmaCCSymbol) value: Integer>	a table mapping a state/symbol pair to the new state that is aquired by shifting the symbol	startingStateMap	<Dictionary key: SmaCCSymbol value: Integer>	the state for SmaCCSymbol's starting item set!Object subclass: #SmaCCGraphAlgorithm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCGraphAlgorithm commentStamp: '<historical>' prior: 0!SmaCCGraphAlgorithm is an abstract class that has support for the graph transformation algorithms.!SmaCCGraphAlgorithm subclass: #SmaCCDuplicateNodeEliminator	instanceVariableNames: 'comparisonState root'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCDuplicateNodeEliminator commentStamp: '<historical>' prior: 0!SmaCCDuplicateNodeEliminator removes duplicate nodes in a SmaCCNode graph.Instance Variables:	comparisonState	<Dictionary>	dictionary mapping equivalent nodes	root	<SmaCCNode>	the root of the graph!SmaCCGraphAlgorithm subclass: #SmaCCEpsilonRemoval	instanceVariableNames: 'nodeMap'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCEpsilonRemoval commentStamp: '<historical>' prior: 0!SmaCCEpsilonRemoval removes epsilon nodes from a NFA.Instance Variables:	nodeMap	<Dictionary>	Dictionary mapping sets of states to a new state in the new graph!Set variableSubclass: #SmaCCItemSet	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCItemSet commentStamp: 'jmb' prior: 0!SmaCCItemSet represents a LALR(1) or a LR(1) item set.Instance Variables:	type	<Symbol>	#LALR1 or #LR1!Object subclass: #SmaCCLR1Item	instanceVariableNames: 'rhs symbol location followers'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCLR1Item commentStamp: 'jmb' prior: 0!SmaCCLR1Item represents an item in a SmaCCItemSet.Instance Variables:	followers	<SmaCCSymbolSet>	all possible symbols that can follow this production in this state	location	<Integer>	the position in the rhs of the production we are at	rhs	<SmaCCRHS>	the rhs of the production	symbol	<SmaCCSymbol>	the symbol for the production!Stream subclass: #SmaCCLineNumberStream	instanceVariableNames: 'sourceStream previousWasCR eolPositions lastPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCC-Runtime'!!SmaCCLineNumberStream commentStamp: '<historical>' prior: 0!SmaCCLineNumberStream is a wrapper for streams that calculates line numbers.Instance Variables:	eolPositions	<OrderedCollection of: Integer>	the positions of each end of line	lastPosition	<Integer>	the position of the last character that we have calculated the end of line information for (we know the line number for all characters before this position and don't know anything about the characters after this position)	previousWasCR	<Boolean>	was the previous character a CR. This is used for CR LF streams. A CR LF combination should only increment the line counter by 1	sourceStream	<Stream>	the stream that we are wrapping!SmaCCGraphAlgorithm subclass: #SmaCCNFAtoDFA	instanceVariableNames: 'mergedStates'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCNFAtoDFA commentStamp: '<historical>' prior: 0!SmaCCNFAtoDFAAlgorithm converts an NFA without epsilon transitions into a DFA. If a node contains edges that lead to multiple nodes for the same character, then a new state is created that merges all states for the given character. Instance Variables:	mergedStates	<Dictionary>	dictionary that maps a collection of states to the resulting merged state!Object subclass: #SmaCCNode	instanceVariableNames: 'transitions action id'	classVariableNames: 'MaxSubNodesInMethod NextId'	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCNode commentStamp: '<historical>' prior: 0!SmaCCNode is a node in a directed graph.Instance Variables:	action	<SequenceableCollection>	a collection of integers or a symbol. This contains the action to be performed when we match and can't find a longer match.	id	<Integer>	a unique number that allows us to sort the nodes	transitions	<Collection of: SmaCCEdge>	our transitions!Object subclass: #SmaCCParser	instanceVariableNames: 'scanner currentToken errorToken stateStack nodeStack'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCC-Runtime'!!SmaCCParser commentStamp: '<historical>' prior: 0!SmaCCParser is an abstract class that defines most of the parsing actions. Subclasses will define methods that specify their transitions and reduction actions. These are normally defined automatically when compiling the parser.Subclasses must implement the following messages:	accessing		emptySymbolTokenId		reduceTable		transitionTableInstance Variables:	currentToken	<SmaCCToken>	the token last returned by the scanner that has not been shifted (reduce actions leave the current token alone)	nodeStack	<OrderedCollection>	collection of items on stack. These items are specific to the parser and can be any object. 	scanner	<SmaCCScanner>	our scanner	stateStack	<OrderedCollection of: Integer>	the stack of states for our parser (standard LR state stack)!SmaCCParser subclass: #CParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!SmaCCParser subclass: #JavaParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!SmaCCParser subclass: #SmaCCGrammarParser	instanceVariableNames: 'grammar'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCGrammarParser commentStamp: 'jmb' prior: 0!SmaCCGrammarParser is a parser for grammars.Instance Variables:	grammar	<SmaCCGrammar>	the grammar we are producing!Error subclass: #SmaCCParserError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCC-Runtime'!!SmaCCParserError commentStamp: '<historical>' prior: 0!SmaCCParserException is the exception raised when a parsing error occurs. The description of the exception will be the error message and the parameter of the exception is the parser. With this information, you can insert a custom error message in your text view that you are parsing. For example, in VisualWorks, the following code will insert an error message into your text view:	textController insertAndSelect: ex description , ' ->' at: ex parameter position!Object subclass: #SmaCCParserGenerator	instanceVariableNames: 'tabList parserClassMorph scannerClassMorph findScannerClassButton findParserClassButton conflicts generateDefinitionComments generateSymbolComments generateItemSetComments ignoreCase mainWindow parserCodeHolder scannerCodeHolder testCodeHolder tutorialTextHolder conflictTextMorph'	classVariableNames: 'ShowPrecedenceConflicts'	poolDictionaries: ''	category: 'SmaCCDev-UI'!!SmaCCParserGenerator commentStamp: 'jmb 1/23/2003 15:59' prior: 0!SmaCC: The Smalltalk Compiler-Compiler from John Brant and Don Roberts(http://www.refactory.com/Software/SmaCC)TutorialThis is a walk-through tutorial to demonstrate many of the features of SmaCC, the Smalltalk Compiler Compiler. In this example, we will incrementally develop a simple calculator. Our first calculator is going to be relatively simple. It is going to take two  numbers  and add them together. To start things off, we have to tell the scanner how to recognize a  number. It starts with one or more digits, possibly followed by an decimal point with zero or more digits after it. The scanner definition for this token is: <number>        :       [0-9]+ (\. [0-9]*) ? ; Enter that line into the scanner tab on the interface. Let's go over each part: <number> Names the token. The name inside the <> must be a legal Smalltalk variable name. :Separates the name of the token from the token's definition. [0-9] Matches any single character in the range '0' to '9' (a digit). +Matches the previous expression  one or more times. In this case, we are matching one or more digits. ( ... ) Groups subexpressions. \. Matches the '.' character (. has a special meaning in regular expressions, \ quotes it). *Matches the previous expression zero or more times. ?Matches the previous expression  zero or one time (i.e., it is optional). ;Terminates a token specification. We don't want to have to worry about whitespace in our language, so we need to define what a whitespace is and to ignore it. To do this, enter the following token specification on the next line on the scanner page: <whitespace>    :       \s+; \s matches any whitespace character (space, tab, linefeed, etc.). So how do  we tell the scanner to ignore it? If you look in the SmaCCScanner class, you will find a method named 'whitespace'. If a scanner understands a method that has the same name as a token name, that method will get called whenever the scanner matches that kind of token. As you can see, the whitespace method eats whitespace. There is also a 'comment' method that behaves similarly. The only other token that will appear in our system would be the '+' token for addition. However, since this is token is always the same, we don't have to tell the scanner what it looks like. It will figure it out from our grammar. Speaking of our grammar, let's go ahead and define it. Enter the following specification in the Parser tab: Expression :           Expression "+" Number        | Number ;Number : <number>; This basically says that an expressions is either a number  or an expression added to a number. We should be able to compile a parser now. Switch to the Compile tab. You need to enter the class name for both  the scanner and parser. Use CalculatorScanner and CalculatorParser respectively.  Once the class names are entered, we are ready to compile the parser. Press the  'Compile LALR(1)' button (you should always push this one unless you know what  you are doing. Basically, it will generate smaller parsers than the other  option). This will create new Smalltalk classes for the CalculatorScanner and  CalculatorParser and compile several methods in those classes. All methods that  SmaCC compiles will go into a "generated-*" method protocol. You should not  change those methods since they are replace each time you compile. Whenever SmaCC creates new classes, they are compiled in the default application/package. If you are using VisualAge,  you will need to make sure that the default application is an open edition and  that it prereqs the SmaCCRuntime application. If you have already created the scanner and parser classes, you can load their  definitions by using the "..." buttons next to the class name entry fields. If  you answer "Yes" to the dialog, the text in the scanner/parser tabs will be  replaced with the definition that was last compiled (assuming that the "Generate  definition comments" was checked during the last compile). Now we are ready to test our parser. Go to the test pane, enter 3 + 4, and press the parse button; you will see that the parser correctly parses it. If you press Parse and Inspect you will see and inspector on an OrderedCollection that contains the parsed tokens. This is because we haven't specified what the parser is supposed to do when it parses. You can also enter incorrect  items. For example, try to parse "3 + + 4" or "3 + a". An  error message should appear in the text. Now we need to define the actions that need to happen when we parse our  expressions. Currently, our parser is just validating that the expression is a  bunch of numbers added together. Generally, you will create some structure that  represents what you've parsed (e.g., a parse tree). However, in this case, we  are not concerned about the structure, but we are concerned about the result  (the value of the expression). For our example, you need to modify the grammar  definition to be: Expression :           Expression "+" Number {'1' + '3'} | Number {'1'} ;Number : <number> {'1' value asNumber} ;The text between the braces is Smalltalk code that gets evaluated when the rule is applied. Strings with a number get replaced with the corresponding parse node. In the first Expression rule, the '1' will get replaced by the ParseNode that matches Expression and the '3' gets replaced by the ParseNode that matches Number. The second item in the rule is the "+" token. Since we already know what  it is, it is not interesting. Compile the new parser. Now when you do a 'Parse  and Inspect' from the test pane, you should see the result: 7. One problem with the previous code is that if you need to change a rule then you  may also need to change the code for that rule. For example, suppose you  inserted a new token at the beginning of a rule, then you would need to change  all of your references in the Smalltalk code. We can alleviate this problem by  using named expressions. After each part of a rule, we can specify its name.  Names are specified with single quotes and must be legal Smalltalk variable  names. Doing this for our grammar we get: Expression :           Expression 'expression' "+" Number 'number' {expression + number} | Number 'number' {number} ;Number : <number> 'numberToken' {numberToken value asNumber} ;While this will result in the same language being parsed, it makes it easier  to maintain your parsers. Let's extend our language to add subtraction. Here's the new grammar: Expression :           Expression 'expression' "+" Number 'number' {expression + number} | Expression 'expression' "-" Number 'number' {expression - number} | Number 'number' {number};Number : <number> 'numberToken' {numberToken value asNumber}; After you've compiled this, '3 + 4 - 2 ' should return '5'. Next, let's add multiplication and division: Expression :           Expression 'expression' "+" Number 'number' {expression + number}        | Expression 'expression' "-" Number 'number' {expression - number} | Expression 'expression' "*" Number 'number' {expression * number}        | Expression 'expression' "/" Number 'number' {expression / number} | Number 'number' {number};Number : <number> 'numberToken' {numberToken value asNumber}; Here we run into a problem. If you evaluate '2 + 3 * 4' you end up with 20. The problem is that in standard mathematics, multiplication has a higher precedence than addition. Our grammar evaluates strictly left-to-right. The standard solution for this problem is to define additional nonterminals to force the sequence of evaluation. Our grammar with that solution would look like: Expression :           Term 'term' {term}        | Expression 'expression' "+" Term 'term' {expression + term}        | Expression 'expression' "-" Term 'term' {expression - term};Term :           Number 'number' {number}        | Term 'term' "*" Number 'number' {term * number}        | Term 'term' "/" Number 'number' {term / number};Number : <number> 'numberToken' {numberToken value asNumber}; If you compile this grammar, you will see that '2 + 3 * 4' evaluates to 14 like we would expect. Now, as you can imagine, this gets pretty complicated as the number of precedence rules increases (e.g., C). We can use ambiguous grammars and precedence rules to simplify this situation. Here is the same grammar using precedence to enforce our evaluation order: %left "+" "-";%left "*" "/"; Expression :           Expression 'exp1' "+" Expression 'exp2' {exp1 + exp2} | Expression 'exp1' "-" Expression 'exp2' {exp1 - exp2} | Expression 'exp1' "*" Expression 'exp2' {exp1 * exp2} | Expression 'exp1' "/" Expression 'exp2' {exp1 / exp2} | Number 'number' {number};Number : <number> 'numberToken' {numberToken value asNumber}; Notice that we changed the grammar so that there are Expressions on both sides  of the operator.  The two lines that we added to the top of the grammar mean that + and - are evaluated left-to-right and have the same precedence, which is lower than * and /. Likewise, the second line means that * and / have equal precedence.  Grammars in this form are usually much more intuitive, especially in cases with many precedence levels. Just as an example, let's add exponentiation and parentheses: %left "+" "-";%left "*" "/"; %right "^"; Expression :           Expression 'exp1' "+" Expression 'exp2' {exp1 + exp2}        | Expression 'exp1' "-" Expression 'exp2' {exp1 - exp2}        | Expression 'exp1' "*" Expression 'exp2' {exp1 * exp2}        | Expression 'exp1' "/" Expression 'exp2' {exp1 / exp2} | Expression 'exp1' "^" Expression 'exp2' {exp1 raisedTo: exp2} | "(" Expression 'expression' ")" {expression} | Number 'number' {number};Number : <number> 'numberToken' {numberToken value asNumber}; Once you have compiled the grammar, you will be able to evaluate '3 + 4 * 5 ^ 2  ^ 2' to get 2503. Since the exponent operator is right associative, this  expression is evaluated like 3 + (4 * (5 ^ (2 ^ 2))). We can also evaluate  expressions with parentheses. For example, evaluating '(3 + 4) * (5 - 2) ^ 3'  results in 189. The ScannerScanning takes an input stream of characters and converts that into a stream of tokens. The tokens are then passed on to the parsing phase. The scanner is specified by a collection of token specifications. Each token is specified by:     TokenName    :    RegularExpression ;TokenName is a valid Smalltalk variable name that is surrounded by <>. For example, "<token>" is a valid TokenName, but "<token name>" is not since "token name" isn't a valid Smalltalk variable name. The RegularExpression is a regular expression that matches a token. It should match one or more characters in the input stream. The colon character, ":", is used to separate the TokenName and the RegularExpression, and the semicolon character, ";", is used to terminate the token specification. Regular Expression SyntaxWhile the rules are specified as regular expressions, there are many different syntaxes for regular expressions. We choose a relatively simple syntax that is specified below. If you wish to have a more rich syntax, you can modify the scanner's parser: SmaCCScannerScanner & SmaCCScannerParser. These classes were created using SmaCC. \character Matches a special character. The character immediately following the backslash is matched exactly, unless it is a letter. Backslash-letter combinations have other meanings and are specified below. \cLetter Matches a control character. Control characters are the first 26 characters (e.g., \cA equals "Character value: 0"). The letter that follows the "\c" must be an uppercase letter. \d Matches a digit, 0-9. \D Matches anything that is not a digit. \f Matches a form-feed character, "Character value: 12". \n Matches a newline character, "Character value: 10". \r Matches a carriage return character, "Character value: 13". \s Matches any whitespace character, [ \f\n\r\t\v]. \S Matches any non-whitespace character. \t Matches a tab, "Character value: 9". \v Matches a vertical tab, "Character value: 11" \w Matches any letter, number or underscore, [A-Za-z0-9_]. \W Matches anything that is not a letter, number or underscore. \xHexNumber Matches a character specified by the hex number following the "\x". The hex number must be at least one character long and no more than four characters for Unicode characters and two characters for non-Unicode characters. For example, "\x20" matches the space character (Character value: 16r20), and "\x1FFF" matches "Character value: 16r1FFF". <token> Copies the definition of <token> into the current regular expression. For example, if we have "<hexdigit> : \d | [A-F] ;", we can use <hexdigit> in a later rule: "<hexnumber> : <hexdigit> + ;". [characters] Matches one of the characters inside the []. This is a shortcut for the "|" operator. In addition to single characters, you can also specify character ranges with the "-" character. For example, "[a-z]" matches any lower case letter. [^characters] Matches any character not listed in the characters block. "[^a]" matches anything except for "a". # comment Creates a comment that is ignored by SmaCC. Everything from the # to the end of the line is ignored. exp1| exp2 Matches either exp1 or exp2. exp1 exp2 Matches exp1 followed by exp2. "\d \d" matches two digits. exp* Matches exp zero or more times. "0*" matches "" and "000". exp? Matches exp zero or one time. "0?" matches only "" or "0". exp+ Matches exp one or more times. "0+" matches "0" and "000", but not "". exp{min,max} Matches exp at least min times but no more than max times. "0{1,2}" matches only "0" or "00". It does not match "" or "000". (exp) Groups exp for precedence. For example, "(a b)*" matches "ababab". Without the parentheses, "a b *" would match "abbbb" but not "ababab". Since there are multiple ways to combine expressions, we need precedence rules for their combination. The or operator, "|", has the lowest precedence and the "*", "?", "+", and "{,}" operators have the highest precedence. For example, "a | b c *" matches "a" or "bcccc", but not "accc" or "bcbcbc". If you wish to match "a" or "b" followed by any number of c's, you need to use "(a | b) c *". Overlapping TokensUnlike T-Gen, SmaCC can handle overlapping tokens with any problems. For example, the following is a legal SmaCC scanner definition: 	<variable>	: [a-zA-Z] \w* ;	<any_character>	: . ;This definition will match a variable or a single character. A variable can also be a single character [a-zA-Z], so the two tokens overlap. SmaCC handles overlapping characters by preferring the first token specified by the grammar. For example, an "a" could be a <variable> or an <any_character> token, but since <variable> is specified first, SmaCC will use it. Matching MethodsIf your scanner has a method name that matches the name of the token, (e.g. whitespace), that method will get called upon a match of that type. The SmaCCScanner superclass already has a default implementation of #whitespace and #comment. These methods ignore those tokens by default. Matching methods can also be used to handle overlapping token classes. For example, in the C grammar, a type definition is the same as an identifier. The only way that they can be disambiguated is by looking up the name in the type table. In our example C parser, we have an IDENTIFIER method that is used to determine whether the token is really an IDENTIFIER or whether it is a TYPE_NAME. Unreferenced TokensIf a token is not referenced from a grammar specification, it will not be included in the generated scanner, unless the token's name is also a name of a method (see previous section). This, coupled with the ability to do substitutions, allows you to have the equivalent of macros within your scanner specification. However, be aware that if you are simply trying to generate a scanner, you will have to make sure that you create a dummy parser specification that references all of the tokens that you want in the final scanner. Case Insensitive ScanningYou can specify that the scanner should ignore case differences by checking the "Ignore Case" option on the compile tab. If you have a language that is case insensitive and has several keywords, this can be a handy feature to have. For example, if you have "THEN" as a keyword in a case insensitive language, you would need to specify a token for then as "<then> : [tT] [hH] [eE] [nN] ;". This is a pain to enter correctly. When the ignore case option is checked, SmaCC will automatically convert "THEN" into "[tT][hH][eE][nN]". Unicode CharactersSmaCC compiles the scanner into a bunch of conditional tests on characters. Normally, it assumes that characters have values between 0 and 255, and it can make some optimizations based on this fact. With the "Allow Unicode Characters" option checked, it will assume that characters have values between 0 and 65535. The ParserParsing converts the stream of tokens provided by the scanner into some object. Normally, this object will be a parse tree, but it does not have to be a parse tree. For example, the SmaCC tutorial shows a calculator. This calculator does not produce a parse tree; it produces the result, a number. In SmaCC the parser is defined by the grammar specification entered in the 'Parser' tab. The grammar specification has two parts, an optional directives section and the production rules. The directives section is used to tell SmaCC how to handle ambiguous grammars as well as how it should generate the code for the parser. The production rules section contains the grammar for the parser and the code that executes when a production rule is matched. DirectivesThe optional directives section consists of a set of directives. The system currently has 5 directives. Each directive begins with a "%" character and the directive keyword, then lists a set of symbols, and finally ends with the semicolon character, ";". Ambiguous Grammars and PrecedenceSmaCC can handle ambiguous grammars. Given an ambiguous grammar, SmaCC will produce some parser. However, it may not parse correctly. For an LR parser, there are two basic types of ambiguities, reduce/reduce conflicts and shift/reduce conflicts. Reduce/reduce conflicts are bad. SmaCC has no directives to handle them and just picks one of the choices. These conflicts normally require a rewrite of your grammar. On the other hand, shift/reduce conflicts can be handled by SmaCC without rewriting your grammar. When SmaCC encounters a shift/reduce conflict it will perform the shift action by default. However, you can control this action with the "%left", "%right", and "%nonassoc" directives. If a token has been declared in a "%left" directive, it means that the token is left-associative. Therefore, the parser will perform a reduce operation. However, if it has been declared as right-associative, it will perform a shift operation. A token defined as %nonassoc will produce an error if that is encountered during parsing. For example, you may want to specify that the equal operator, "=", is non-associative, so "a = b = c" is not parsed as a valid expression. All three directives are followed by a list of tokens. Additionally, the %left, %right, and %nonassoc directives allow precedence to be specified. The order of the directives specifies the precedence of the tokens. The higher precedence tokens appear on the higher line numbers. For example, the following directive section gives the precedence for the simple calculator in our tutorial: %left "+" "-";%left "*" "/";%right "^";The "+" and "-" symbols appear on the first line and have the lowest precedence. They are also left-associative so "1 + 2 +3" will be evaluated as "(1 + 2) + 3". On the next line are the "*" and "/" symbols. Since they appear on a higher line number, they have higher precedence than the "+" and "-". Finally, on line three we have the "^" symbol. It has the highest precedence. Combining all the rules allows us to parse "1 + 2 * 3 / 4 ^ 2 ^ 3" as "1 + ((2 * 3) / (4 ^ (2 ^ 3)))". Start SymbolsBy default, the left-hand side of the first grammar rule is the start symbol. If you want to multiple start symbols, then you can specify them by using the "%start" directive followed by the nonterminals that are additional start symbols. This is useful for creating two parsers with two grammars that are similar but slightly different. For example, consider a Smalltalk parser. You can parse methods, and you can parse expressions. These are two different operations, but have very similar grammars. Instead of creating two different parsers for parsing methods and expressions, we can specify one grammar that parses methods and also specify another starting position for parsing expressions. The StParser in the SmaCC Example Parsers package has an example of this. The StParser class>>parseMethod: uses the #startingStateForMethod position to parse methods and the StParser class>>parseExpression: uses the #startingStateForSequenceNode position to parse expressions. Id MethodsInternally, the various token types are represented as integers. However, there are times that you need to reference the various token types. For example, in the CScanner and CParser classes, the TYPE_NAME token is identical to the IDENTIFIER token. The IDENTIFIER matching method does a lookup in the type table and if it finds a type definition with the same name as the current IDENTIFIER, it want to return the TYPE_NAME token type. To determine what integer this is, the parser was created with an %id directive for <IDENTIFIER> and <TYPE_NAME>. This generates the IDENTIFIERId and TYPE_NAMEId methods on the scanner. These methods simply return the number representing that token type. See the C sample scanner and parser for a good example of how this is used. Production RulesThe production rules contains the grammar for the parser. The first production rule is considered to be the starting rule for the parser. Each production rule consists of a non-terminal symbol name followed by a ":" separator which is followed by a list of possible productions separated by vertical bar, "|", and finally terminated by a semicolon, ";". Each production consists of a sequence of non-terminal symbols, tokens, or keywords followed by some optional Smalltalk code enclosed in curly brackets, {}. Non-terminal symbols are valid Smalltalk variable names and must be defined somewhere in the parser definition. Forward references are valid. Tokens are enclosed in angle brackets as they are defined in the scanner (e.g., <token>) and keywords are enclosed in double-quotes (e.g., "then"). Keywords that contain double-quotes need to have two double-quotes per each double-quote in the keyword. For example, if you need a keyword for one double-quote character, you would need to enter """" (four double-quote characters). The Smalltalk code is evaluated whenever that production is matched. If the code is a zero or a one argument symbol, then that method is performed. For a one argument symbol, the argument is an OrderedCollection that contains one element for each item in the production. If the code isn't a zero or one argument symbol, then the code is executed and whatever is returned by the code is the result of the production. If no Smalltalk code is specified, then the default action is to execute the #reduceFor: method. This method converts all items into an OrderedCollection. If one of the items is another OrderedCollection, then all of its elements are added to the new collection. Inside the Smalltalk code you can refer to the values of each production item by using literal strings. The literal string, '1', refers the to value of the first production item. The values for tokens and keywords will be SmaCCToken objects. The value for all non-terminal symbols will be whatever the Smalltalk code evaluates to for that non-terminal symbol. Named SymbolsWhen entering the Smalltalk code, you can get the value for a symbol by using the literal strings (e.g., '2'). However, this creates difficulties when modifying a grammar. If you insert some symbol at the beginning of a production, then you will need to modify your Smalltalk code changing all literal string numbers. Instead you can name each symbol in the production and then refer to the name in the Smalltalk code. To name a symbol (non-terminal, token, or keyword), you need to add a quoted variable name after the symbol in the grammar. For example, "MySymbol : Expression 'expr' "+" <number> 'num' {expr + num} ;" creates two named variables. One for the non-terminal Expression and one for the <number> token. These variables are then used in the Smalltalk code. Extended SyntaxSmaCC also has some extended syntax that makes it easier to enter different grammars. Most of the additions are for the productions, but one change that is not for productions is the addition of "::=" as the separator between the non-terminal and the production. The production syntax enhancements are listed in the following table: Symbol ? Makes symbol optional. It is equivalent to defining a new production rule: "Optional_Symbol : Symbol {'1'} | {nil};". Symbol * or Symbol + Makes a repeating symbol. The "*" repeats zero or more times, and the "+" repeats one or more times. It is equivalent to defining a new production rule: "Repeat_Symbol : | Symbol;" for "*" and "Repeat_Symbol : Symbol | Repeat_Symbol Symbol ;" for "+". ( Productions ) Groups the items in Productions. By itself it is not that useful, but it can be combined with the "?", "*", or "+". It is equivalent to defining "Group_Productions : Productions ;". [ Productions ] Equivalent to "( Productions ) ?". <% Productions %> Equivalent to "( Productions ) *" Parser CommentsThe compile page has three options to generate comments. You should always select the "Generate definition comments". That saves the scanner and parser definition strings into the scanner and parser classes. It allows your grammar to be under the same version control system as your Smalltalk code. The other two comment options should not be needed unless you need to debug a parser generated. The "generate symbol comments" option will generate a comment that explains what each symbol is mapped to. When SmaCC compiles a grammar it converts all symbols into integers. This comment gives you the integer for each symbol. You may need this information if you have an incorrect scanner definition. For example, you may have overlapping token definitions and SmaCC is picking the wrong one (by default it picks the first one in your scanner definition). When you debug, you can inspect the SmaCCToken object and validate its "id" with those in the symbol comment. If they are different, then you have a bug in your scanner. Finally, the "generate item set comments" option should rarely be needed. It generates a listing of all LR(1) item sets in the parser. If you are familiar with LR parsing, then it might be interesting to look at. However, for a moderate sized grammar (e.g., Java), this comment can be a few MB in size. I would not recommend generating such comments when using ENVY -- you don't want to store a 10MB method in your library. For the calculator example in the tutorial, this comment is 9,000 characters long. Error RecoveryNormally, when the parser encounters an error, it raises the SmaCCParserError exception and parsing is immediately stopped. However, there are times when you may wish to try to parse more of the input. For example, if you are highlighting code, you do not want to stop highlighting at the first syntax error. Instead you may wish to attempt to recover after the statement separator -- the period ".". SmaCC uses the error symbol to specify where error recovery should be attempted. For example, we may have the following rule to specify a list of Smalltalk statements: 	Statements : Expression | Statements "." Expression ;If we wish to attempt recovery from a syntax error when we encounter a period, we can change our rule to be: 	Statements : Expression | Statements "." Expression | error "." Expression ;While the error recovery allows you to proceed parsing after a syntax error, it will not allow you to return a parse tree from the input. Once the input has been parsed with errors, it will raise a non-resumable SmaCCParserError. !Object subclass: #SmaCCRHS	instanceVariableNames: 'collection reduceAction variableNames'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCRHS commentStamp: 'jmb' prior: 0!SmaCCRHS represents the right hand side of the production.Instance variables:	collection	<OrderedCollection of: SmaCCSymbol> the collection of symbols that represent the rhs	grammar <SmaCCGrammar> the grammar that the production is in	variableNames	<Dictionary key: String value: Integer>	the name of each symbol in the rhs. These names can be used in the {} code blocks.!SmaCCAction subclass: #SmaCCReduceAction	instanceVariableNames: 'symbol rhs'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCReduceAction commentStamp: 'jmb' prior: 0!SmaCCReduceAction represents a reduce action in our parser's table.Instance Variables:	rhs	<SmaCCRHS>	the rhs that is being reduced	symbol	<SmaCCNonTerminalSymbol>	the symbol that has the rhs!Object subclass: #SmaCCRegularExpressionNode	instanceVariableNames: 'action position states'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCRegularExpressionNode commentStamp: '<historical>' prior: 0!SmaCCRegularExpressionNode represents a regular expression. The scanner is represented by a regular expression. These are the initial objects created in producing the scanner. From these nodes, we create a directed graph and then we compile the graph.Subclasses must implement the following messages:	accessing		possibleMatchesSize	private		asNFAStartingWith:		possibleMatchesDo:on:Instance Variables:	action	<SequenceableCollection>	the actions to be performed when we find a match	position	<Integer>	the position of the RE in the scanner. If we have multiple matches, we prefer the ones listed first.!SmaCCRegularExpressionNode subclass: #SmaCCCharacterRENode	instanceVariableNames: 'characters'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCCharacterRENode commentStamp: 'jmb' prior: 0!SmaCCCharacterRENode represents a regular expression that matches one of a set of characters.Instance Variables:	characters	<SortedCollection of: Character>	The characters that this node can accept. Note that there are no duplicates and all characters are sorted.!SmaCCRegularExpressionNode subclass: #SmaCCOrRENode	instanceVariableNames: 'nodes'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCOrRENode commentStamp: 'jmb' prior: 0!SmaCCOrRENode is a SmaCCRegularExpressionNode that represents an alternative.Instance Variables:	nodes	<Collection of: SmaCCRegularExpressionNode>	our possible choices!SmaCCAction subclass: #SmaCCRejectAction	instanceVariableNames: ''	classVariableNames: 'Reject'	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCRejectAction commentStamp: 'jmb' prior: 0!SmaCCRejectAction represents a reject action in the parsing tables.!SmaCCRegularExpressionNode subclass: #SmaCCRepeatingRENode	instanceVariableNames: 'node minimumMatches maximumMatches'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCRepeatingRENode commentStamp: 'jmb' prior: 0!SmaCCRepeatingRENode represents a repeating node in a regular expression.Instance Variables:	maximumMatches	<Integer>	the minimum number of matches required	minimumMatches	<Integer>	the maximum number of matches allowed. An infinite amount of matches is represented by (SmaCCRepeatingRENode finiteInfinity).	node	<SmaCCRegularExpressionNode>	what we need to match!Object subclass: #SmaCCScanner	instanceVariableNames: 'stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock state'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCC-Runtime'!!SmaCCScanner commentStamp: '<historical>' prior: 0!SmaCCScanner is an abstract class that represents a scanner for the parser. The scanner converts its string input into SmaCCToken objects that the parser then uses for its parsing.Subclasses must implement the following messages:	accessing		scanForTokenInstance Variables:	currentCharacter	<Character>	the current character we are scanning	lastMatchWasEmpty	<Boolean>	was our last scanning match an empty string -- don't allow two empty matches in a row	lastOutputStreamMatchPosition	<Integer>	the position in the outputStream of the last match	matchActions	<Array | Symbol>	the actions for the last match (a symbol means that the action should be performed on the scanner)	matchEnd	<Integer>	the position of the last match in the stream (our input stream)	outputStream	<PositionableStream>	the matched characters go in this stream. After a match is made, we take this stream's contents and create a token object.	returnMatchBlock	<BlockClosure>	when we match a token evaluate this block with the token (hack to return from multiple levels)	start	<Integer>	the starting position of a match in the stream	stream	<Stream>	our input!SmaCCScanner subclass: #CScanner	instanceVariableNames: 'typeNames'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!SmaCCScanner subclass: #JavaScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!SmaCCScanner subclass: #SmaCCGrammarScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCGrammarScanner commentStamp: 'jmb' prior: 0!SmaCCGrammarScanner is the scanner for the grammar parser!SmaCCScanner class	instanceVariableNames: 'keywordMap'!Object subclass: #SmaCCScannerCompiler	instanceVariableNames: 'grammar scannerClass scannerDefinitionString'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCScannerCompiler commentStamp: 'jmb' prior: 0!SmaCCScannerCompiler represents the compiler for the scanner part of the parser.Instance Variables:	grammar	<SmaCCGrammar>	the grammar that defines the scanner	scannerClass	<RBAbstractClass>	the class to compile the scanner into	scannerDefinitionString	<String>	the string that defines the scanner!Object subclass: #SmaCCScannerDefinition	instanceVariableNames: 'tokens states excludeStates'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCScannerDefinition commentStamp: '<historical>' prior: 0!SmaCCScannerDefinition is the parsed representation of the scanner. It contains the tokens and states for the scanner.Instance Variables:	excludeStates	<Collection>	exclusive states (when we are in one of these, then we shouldn't try to parse the default tokens)	states	<Collection>	states in the scanner -- if no states are specified, then this will only contain #default	tokens	<Dictionary>	dictionary mapping token names to their regular expressions!SmaCCParser subclass: #SmaCCScannerParser	instanceVariableNames: 'scannerDefinition'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCScannerParser commentStamp: '<historical>' prior: 0!SmaCCScannerParser is the parser for the scanner definition.Instance Variables:	tokens	<Dictionary key: String value: SmaCCRegularExpressionNode>	the tokens that are parsed!SmaCCScanner subclass: #SmaCCScannerScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCScannerScanner commentStamp: 'jmb' prior: 0!SmaCCScannerScanner is the scanner for the scanner definition!SmaCCRegularExpressionNode subclass: #SmaCCSequenceRENode	instanceVariableNames: 'nodes'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCSequenceRENode commentStamp: 'jmb' prior: 0!SmaCCSequenceRENode represents a regular expression that is made up of several other regular expressions concatenated together.Instance Variables:	nodes	<Collection of: SmaCCRegularExpressionNode>	our children nodes in left-to-right order!SmaCCAction subclass: #SmaCCShiftAction	instanceVariableNames: ''	classVariableNames: 'Shift'	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCShiftAction commentStamp: 'jmb' prior: 0!SmaCCShiftAction represents a shift action in the parser's tables.!SmaCCEdge subclass: #SmaCCStateEdge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ScannerGenerator'!!SmaCCStateEdge commentStamp: '<historical>' prior: 0!SmaCCStateEdge is a SmaCCEdge for Symbol (state) transitions!Object subclass: #SmaCCSymbol	instanceVariableNames: 'name precedence firstItems'	classVariableNames: 'EmptySymbol ErrorSymbol SentinelSymbol'	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCSymbol commentStamp: '<historical>' prior: 0!SmaCCSymbol is an abstract class that represents a symbol in the grammar.Subclasses must implement the following messages:	accessing		calculateFirstTerminals	testing		isTerminalInstance Variables:	firstItems	<Collection of: SmaCCTerminalSymbol>	the first terminals that can be produced from us	name	<String>	our name	precedence	<Integer>	our precedence (in case of shift/reduce conflicts)!SmaCCSymbol subclass: #SmaCCNonTerminalSymbol	instanceVariableNames: 'productions'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCNonTerminalSymbol commentStamp: 'jmb' prior: 0!SmaCCNonTerminalSymbol represents a non-terminal symbol in our grammar.Instance Variables:	productions	<SequenceableCollection of: SmaCCRHS>	our rhs' for the symbol!SmaCCNonTerminalSymbol subclass: #SmaCCStartingSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCStartingSymbol commentStamp: 'jmb' prior: 0!SmaCCStartingSymbol is the starting symbol in the grammar. A grammar can only have one starting symbol, but it can have may different starting item sets.!Model subclass: #SmaCCSymbolSet	instanceVariableNames: 'symbols components'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCSymbolSet commentStamp: 'jmb' prior: 0!SmaCCSymbolSet represents a set of follow symbols in the LALR(1) item sets.Instance Variables:	components	<Collection of: SmaCCSymbolSet>	other SmaCCSymbolSets that we depend on, we include all items in these sets also	symbols	<Collection of: SmaCCTerminalSymbol>	our follow symbols!SmaCCSymbol subclass: #SmaCCTerminalSymbol	instanceVariableNames: 'regularExpression createIdMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-ParserGenerator'!!SmaCCTerminalSymbol commentStamp: 'jmb' prior: 0!SmaCCTerminalSymbol represents a terminal symbol in our grammar.Instance Variables:	createIdMethod	<Boolean>	should we create a symbolNameId method for this symbol.	regularExpression	<SmaCCRegularExpression>	our regular expression that we must match for this terminal symbol!Object subclass: #SmaCCToken	instanceVariableNames: 'start id value'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCC-Runtime'!!SmaCCToken commentStamp: '<historical>' prior: 0!SmaCCTokens are used as the interface objects between scanner and parser. They hold the string that was scanned and its position information. Also, included in the token is its id. The id specifies what type of token it is.Instance Variables:	id	<Array of: Integer>	the list of possible token types this represents. There can be overlapping tokens, so we list all of the id here. The default parser only looks at the first id, but we can redefine this behavior in a subclass to look at all possibilities until we find a valid token.	start	<Integer>	the starting position of the token in the original input	value	<Object>	the value of our token (normally a string, but could be anything)!Object subclass: #SmalllintChecker	instanceVariableNames: 'rule environment context methodBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!Object subclass: #SmalllintContext	instanceVariableNames: 'class selector parseTree literals literalSemaphore literalProcess selectors compiledMethod selfMessages superMessages messages'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!Object subclass: #SmalllintResultEditor	instanceVariableNames: 'label results resultsList'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!RefactoringBrowserTest subclass: #SmalllintTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!Refactoring subclass: #SplitClassRefactoring	instanceVariableNames: 'class instanceVariables newClassName referenceVariableName newClass'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!SmaCCParser subclass: #StParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!SmaCCScanner subclass: #StScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Examples'!Browser subclass: #RefactoringBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!RefactoringBrowser subclass: #SelectorEnvironmentBrowser	instanceVariableNames: 'browserEnvironment'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!SelectorEnvironmentBrowser subclass: #ClassEnvironmentBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!StringHolder subclass: #SmaCCCodeHolder	instanceVariableNames: 'contentsMorph owner ownerAcceptSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-UI'!ClassToRename subclass: #SubclassOfClassToRename	instanceVariableNames: 'rewriteRule1'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!MethodRefactoring subclass: #SwapMethodRefactoring	instanceVariableNames: 'target selector'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!Trait named: #TRBProgramNodeVisitor	uses: #()	category: 'AST-Core-Visitors'!!TRBProgramNodeVisitor commentStamp: '<historical>' prior: 0!A TRBProgramNodeVisitor is a simple  that define visitor methods. !Object subclass: #RBProgramNodeVisitor	uses: TRBProgramNodeVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Visitors'!!RBProgramNodeVisitor commentStamp: '<historical>' prior: 0!RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.!RBProgramNodeVisitor subclass: #ParseTreeSearcher	instanceVariableNames: 'searches answer argumentSearches context messages'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!ParseTreeSearcher commentStamp: '<historical>' prior: 0!ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables:	answer	<Object>	the "answer" that is propagated between matches	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).	messages	<Collection>	the sent messages in our searches	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)!ParseTreeSearcher subclass: #ParseTreeRewriter	instanceVariableNames: 'tree'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!ParseTreeRewriter commentStamp: '<historical>' prior: 0!ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	<RBProgramNode>	the parse tree we're transforming!RBProgramNodeVisitor subclass: #RBConfigurableFormatter	instanceVariableNames: 'codeStream indent lookaheadCode originalSource lineStart'	classVariableNames: 'CascadedMessageInsideParentheses FormatCommentWithStatements FormatOnAccept FormatOnDisplay IndentString IndentsForKeywords KeepBlockInMessage LineUpBlockBrackets MaxLineLength MethodSignatureOnMultipleLines MinimumNewLinesBetweenStatements MultiLineMessages NewLineAfterCascade NewLineBeforeFirstCascade NewLineBeforeFirstKeyword NewLinesAfterMethodComment NewLinesAfterMethodPattern NewLinesAfterTemporaries NumberOfArgumentsForMultiLine OneLineMessages PeriodsAtEndOfBlock PeriodsAtEndOfMethod RetainBlankLinesBeforeComments RetainBlankLinesBetweenStatements StringFollowingReturn StringInsideBlocks StringInsideParentheses TraditionalBinaryPrecedence UseTraditionalBinaryPrecedenceForParentheses'	poolDictionaries: ''	category: 'AST-Core-Visitors'!!RBConfigurableFormatter commentStamp: '<historical>' prior: 0!RBConfigurableFormatter formats the Refactoring Browser's parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.Instance Variables:	codeStream	<PositionableStream>	the stream we are writing our output to	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.!RBProgramNodeVisitor subclass: #RBFindBlockArgumentAssignment	instanceVariableNames: 'arguments argumentAssignments'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Visitors'!!RBFindBlockArgumentAssignment commentStamp: 'NicolaiHess 8/23/2014 21:19' prior: 0!Find assignment nodes with block arguments on its left side.!RBProgramNodeVisitor subclass: #RBParseTreeSearcher	instanceVariableNames: 'searches answer argumentSearches context messages'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBParseTreeSearcher commentStamp: '<historical>' prior: 0!ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables:	answer	<Object>	the "answer" that is propagated between matches	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).	messages	<Collection>	the sent messages in our searches	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)!RBParseTreeSearcher subclass: #RBParseTreeRewriter	instanceVariableNames: 'tree'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Matching'!!RBParseTreeRewriter commentStamp: '<historical>' prior: 0!ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	<RBProgramNode>	the parse tree we're transforming!RBProgramNodeVisitor subclass: #RBReadBeforeWrittenTester	instanceVariableNames: 'read checkNewTemps scopeStack'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Core-Visitors'!!RBReadBeforeWrittenTester commentStamp: '<historical>' prior: 0!RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.Instance Variables:	checkNewTemps	<Boolean>	description of checkNewTemps	read	<Collection>	description of read	scopeStack	<OrderedCollection>	description of scopeStack!MethodRefactoring subclass: #TemporaryToInstanceVariableRefactoring	instanceVariableNames: 'selector temporaryVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringTest subclass: #TemporaryToInstanceVariableTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!SmaCCParser subclass: #TestParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!SmaCCScanner subclass: #TestScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SmaCCDev-Tests'!LintRule subclass: #TransformationRule	instanceVariableNames: 'rewriteRule builder class'	classVariableNames: 'RecursiveSelfRule'	poolDictionaries: ''	category: 'RefactoringEngine-Lint'!FooLintRuleTest subclass: #TransformationRuleTest	instanceVariableNames: 'rewriteRule builder class'	classVariableNames: 'RecursiveSelfRule'	poolDictionaries: ''	category: 'RefactoringEngine-Testdata'!BrowserEnvironmentWrapper subclass: #VariableEnvironment	instanceVariableNames: 'instanceVariables instanceVariableReaders instanceVariableWriters classVariables selectorCache'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Environments'!SelectorEnvironmentBrowser subclass: #VariableEnvironmentBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-UserInterface'!BrowserEnvironmentTest subclass: #VariableEnvironmentTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!Refactoring subclass: #VariableRefactoring	instanceVariableNames: 'class variableName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #AbstractClassVariableRefactoring	instanceVariableNames: 'accessorsRefactoring'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #AbstractInstanceVariableRefactoring	instanceVariableNames: 'accessorsRefactoring'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #AddClassVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #AddInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #CreateAccessorsForVariableRefactoring	instanceVariableNames: 'getterMethod setterMethod classVariable needsReturn'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!CreateAccessorsForVariableRefactoring subclass: #CreateAccessorsForClassVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Services'!CreateAccessorsForVariableRefactoring subclass: #CreateAccessorsForInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Services'!VariableRefactoring subclass: #ProtectInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #PullUpClassVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #PullUpInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #PushDownClassVariableRefactoring	instanceVariableNames: 'destinationClass'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #PushDownInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #RemoveClassVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #RemoveInstanceVariableRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #RenameClassVariableRefactoring	instanceVariableNames: 'newName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!VariableRefactoring subclass: #RenameInstanceVariableRefactoring	instanceVariableNames: 'newName'	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Refactorings'!RefactoringBrowserTest subclass: #VariableTypeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RefactoringEngine-Testing'!!ASTCache methodsFor: 'accessing' stamp: 'GuillermoPolito 5/14/2013 10:52'!at: aCompiledMethod	^ self 		at: aCompiledMethod		ifAbsentPut: [ 			aCompiledMethod parseTree doSemanticAnalysisIn: aCompiledMethod methodClass ]! !!ASTCache methodsFor: 'accessing' stamp: 'CamilloBruni 2/17/2012 14:29'!reset	self removeAll! !!BrowserEnvironment methodsFor: 'environments'!& anEnvironment 	"If we or anEnvironment includes everything, then just include the other environment (optimization)"	self isSystem ifTrue: [^anEnvironment].	anEnvironment isSystem ifTrue: [^self].	^AndEnvironment onEnvironment: self and: anEnvironment! !!BrowserEnvironment methodsFor: 'environments'!forCategories: categoryList 	^CategoryEnvironment onEnvironment: self categories: categoryList! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass protocols: protocolCollection 	^ProtocolEnvironment onEnvironment: self		class: aClass		protocols: protocolCollection! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass selectors: selectorCollection 	^(SelectorEnvironment 		onMethods: selectorCollection		forClass: aClass		in: self)		label: aClass name , '>>' 					, (selectorCollection detect: [:each | true] ifNone: ['']);		yourself! !!BrowserEnvironment methodsFor: 'environments'!forClasses: classCollection 	| classes |	classes := OrderedCollection new: classCollection size * 2.	classCollection do: 			[:each | 			classes add: each;				add: each class].	^ClassEnvironment onEnvironment: self classes: classes! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackage: aPackageInfo	^ PackageEnvironment onEnvironment: self package: aPackageInfo.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageContainingClassCategory: aClassCategory	| package |	package := PackageInfo allPackages 		detect: [ :each | each includesSystemCategory: aClassCategory ]		ifNone: [ self inform: 'no package for this category'. ^nil ].	^ self forPackage: package.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageNamed: aString	^ PackageEnvironment onEnvironment: self packageNamed: aString.! !!BrowserEnvironment methodsFor: 'environments'!implementorsMatching: aString 	^SelectorEnvironment implementorsMatching: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!implementorsOf: aSelector 	^SelectorEnvironment implementorsOf: aSelector in: self! !!BrowserEnvironment methodsFor: 'environments'!instVarReadersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		readersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarRefsTo: instVarName in: aClass 	^VariableEnvironment 		on: self		referencesToInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarWritersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		writersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!matches: aString 	^SelectorEnvironment matches: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!not	self isSystem ifTrue: [^SelectorEnvironment new].	^NotEnvironment onEnvironment: self! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral 	^SelectorEnvironment referencesTo: aLiteral in: self! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral in: aClass 	| classes |	classes := aClass withAllSuperclasses asSet.	classes		addAll: aClass allSubclasses;		addAll: aClass class withAllSuperclasses;		addAll: aClass class allSubclasses.	^(self forClasses: classes) referencesTo: aLiteral! !!BrowserEnvironment methodsFor: 'environments'!selectMethods: aBlock 	| env |	env := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: 			[:each :sel | 			(aBlock value: (each compiledMethodAt: sel)) 				ifTrue: [env addClass: each selector: sel]].	^env! !!BrowserEnvironment methodsFor: 'environments'!| anEnvironment 	"If we or anEnvironment includes everything, then return it instead of creating 	an or that will include everything."	self isSystem ifTrue: [^self].	anEnvironment isSystem ifTrue: [^anEnvironment].	^(self not & anEnvironment not) not! !!BrowserEnvironment methodsFor: 'accessing'!addSearchString: aString 	searchStrings isNil ifTrue: 			[searchStrings := SortedCollection sortBlock: 							[:a :b | 							(a indexOf: $: ifAbsent: [a size]) > (b indexOf: $: ifAbsent: [b size])]].	searchStrings add: aString! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:41'!asSelectorEnvironment	^(ClassEnvironment onEnvironment: self classes: self classes) asSelectorEnvironment! !!BrowserEnvironment methodsFor: 'accessing'!categories	^Smalltalk organization categories select: [:each | self includesCategory: each]! !!BrowserEnvironment methodsFor: 'accessing'!classNamesFor: aCategoryName	^(Smalltalk organization listAtCategoryNamed: aCategoryName)		select:			[:each |			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil and: [(self includesClass: class)					or: [self includesClass: class class]]]! !!BrowserEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^aClass classVarNames! !!BrowserEnvironment methodsFor: 'accessing'!classesAndSelectorsDo: aBlock 	self classesDo: 			[:class | 			self selectorsForClass: class do: [:sel | aBlock value: class value: sel]]! !!BrowserEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	^aClass instVarNames! !!BrowserEnvironment methodsFor: 'accessing'!numberClasses	^self classNames size! !!BrowserEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		allClassesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!BrowserEnvironment methodsFor: 'accessing'!problemCount	^self numberSelectors! !!BrowserEnvironment methodsFor: 'accessing'!protocolsFor: aClass	^aClass organization categories select: [:each | self includesProtocol: each in: aClass]! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings	^searchStrings isNil		ifTrue: [#()]		ifFalse: [searchStrings]! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings: aCollection 	searchStrings := aCollection! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:02'!selectionIntervalFor: aString 	| interval |	self searchStrings isEmpty ifTrue: [^nil].	interval := self selectionParseTreeIntervalFor: aString.	interval notNil ifTrue: [^interval].	self searchStrings do: 			[:each | 			| search index |			search := each isSymbol ifTrue: [each keywords first] ifFalse: [each].			index := aString indexOfSubCollection: search startingAt: 1.			index > 0 ifTrue: [^index to: index + search size - 1]].	^nil! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!selectionParseTreeIntervalFor: aString	| parseTree answerBlock |	parseTree := RBParser parseMethod: aString onError: [ :str :pos | ^ nil ].	answerBlock := [ :aNode :answer | ^ aNode sourceInterval ].	self searchStrings		do: [ :each | 			| matcher tree |			matcher := ParseTreeSearcher new.			each isSymbol				ifTrue: [ 					matcher matchesTree: (RBLiteralNode value: each) do: answerBlock.					tree := ParseTreeSearcher buildSelectorTree: each.					tree notNil						ifTrue: [ matcher matchesTree: tree do: answerBlock ] ]				ifFalse: [ 					tree := RBVariableNode named: each.					matcher						matchesTree: tree do: answerBlock;						matchesArgumentTree: tree do: answerBlock ].			matcher executeTree: parseTree ].	^ nil! !!BrowserEnvironment methodsFor: 'accessing'!selectorsFor: aProtocol in: aClass	^(aClass organization listAtCategoryNamed: aProtocol)		select: [:each | self includesSelector: each in: aClass]! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass 	| selectors |	selectors := Set new: 50.	self selectorsForClass: aClass do: [:each | selectors add: each].	^selectors! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	aClass selectorsAndMethodsDo: 			[:each :meth | 			(self includesSelector: each in: aClass) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'accessing'!whichCategoryIncludes: aClassName	^Smalltalk organization categoryOfElement: aClassName! !!BrowserEnvironment methodsFor: 'accessing'!whichProtocolIncludes: aSelector in: aClass	^aClass organization categoryOfElement: aSelector! !!BrowserEnvironment methodsFor: 'private' stamp: 'nk 8/8/2003 09:07'!allClassesDo: aBlock 	self systemNavigation allBehaviorsDo: aBlock! !!BrowserEnvironment methodsFor: 'private'!defaultLabel	^'Smalltalk'! !!BrowserEnvironment methodsFor: 'private'!label	^label isNil		ifTrue: [self defaultLabel]		ifFalse: [label]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'dvf 10/9/2001 16:14'!associationAt: aKey	| association class |	association := Smalltalk associationAt: aKey ifAbsent: [^nil].	class := association value isBehavior				ifTrue: [association value]				ifFalse: [association value class].	^((self includesClass: class) or: [self includesClass: class class])		ifTrue: [association]		ifFalse: [nil]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 8/2/2005 23:26'!at: aKey	^self at: aKey ifAbsent: [self error:'key ',aKey printString,' was not found'.]! !!BrowserEnvironment methodsFor: 'accessing-classes'!at: aKey ifAbsent: aBlock	| assoc |	assoc := self associationAt: aKey.	^assoc isNil		ifTrue: [aBlock value]		ifFalse: [assoc value]! !!BrowserEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new.	self classesDo: 			[:each | 			names add: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name].	^names! !!BrowserEnvironment methodsFor: 'accessing-classes'!classes	| classes |	classes := Set new.	self classesDo: [:each | classes add: each].	^classes! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 2/26/2006 15:11'!classesDo: aBlock 	self allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'accessing-classes'!keys	| keys |	keys := Set new.	Smalltalk keysAndValuesDo: 			[:key :value | 			| class |			value isBehavior 				ifTrue: [(self includesClass: value) ifTrue: [keys add: key]].			class := value class.			(self includesClass: class) ifTrue: [keys add: key]].	^keys! !!BrowserEnvironment methodsFor: 'copying' stamp: 'bh 3/16/2000 23:24'!copy	^self shallowCopy postCopy! !!BrowserEnvironment methodsFor: 'copying'!copyEmpty	^self class new! !!BrowserEnvironment methodsFor: 'copying' stamp: 'dvf 9/12/2003 13:21'!postCopy	^self! !!BrowserEnvironment methodsFor: 'testing'!definesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesCategory: aCategory	^true! !!BrowserEnvironment methodsFor: 'testing'!includesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!isClassEnvironment	^false! !!BrowserEnvironment methodsFor: 'testing'!isEmpty	^false! !!BrowserEnvironment methodsFor: 'testing'!isSelector	^false! !!BrowserEnvironment methodsFor: 'testing'!isSystem	^true! !!BrowserEnvironment methodsFor: 'initialize-release'!initialize! !!BrowserEnvironment methodsFor: 'initialize-release'!label: aString	label := aString! !!BrowserEnvironment methodsFor: 'SqueakRB-UserInterface' stamp: 'nk 3/4/2005 12:41'!openEditor	^self asSelectorEnvironment openEditor! !!BrowserEnvironment methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self label! !!BrowserEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: self class name;		nextPutAll: ' new'! !!BrowserEnvironmentWrapper methodsFor: 'private'!environment	^environment! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesCategory: aCategory	^environment includesCategory: aCategory! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesClass: aClass	^environment includesClass: aClass! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^(self includesClass: aClass)		and: [environment includesProtocol: aProtocol in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(self includesClass: aClass)		and: [environment includesSelector: aSelector in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isEmpty	self classesDo: [:each | ^false].	^true! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isSystem	^false! !!BrowserEnvironmentWrapper methodsFor: 'initialize-release'!onEnvironment: anEnvironment	environment := anEnvironment! !!BrowserEnvironmentWrapper methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:03'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	^interval notNil 		ifTrue: [interval]		ifFalse: [environment selectionIntervalFor: aString]! !!BrowserEnvironmentWrapper methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: '(';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPut: $)! !!AndEnvironment methodsFor: 'private'!andedEnvironment	^andedEnvironment! !!AndEnvironment methodsFor: 'initialize-release'!andedEnvironment: aBrowserEnvironment 	andedEnvironment := aBrowserEnvironment! !!AndEnvironment methodsFor: 'accessing'!classesDo: aBlock 	environment 		classesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	environment classesAndSelectorsDo: 			[:each :sel | 			(andedEnvironment includesSelector: sel in: each) 				ifTrue: [total := total + 1]].	^total! !!AndEnvironment methodsFor: 'accessing'!problemCount	^environment isClassEnvironment 		ifTrue: [self numberClasses]		ifFalse: [super problemCount]! !!AndEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:01'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	interval notNil ifTrue: [^interval].	^andedEnvironment selectionIntervalFor: aString! !!AndEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	environment selectorsForClass: aClass		do: 			[:each | 			(andedEnvironment includesSelector: each in: aClass) 				ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesClass: aClass 	| doesntHaveSelectors |	(environment includesClass: aClass) ifFalse: [^false].	(andedEnvironment includesClass: aClass) ifFalse: [^false].	doesntHaveSelectors := true.	environment selectorsForClass: aClass		do: 			[:each | 			doesntHaveSelectors := false.			(andedEnvironment includesSelector: each in: aClass) ifTrue: [^true]].	^doesntHaveSelectors! !!AndEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) 		and: [andedEnvironment includesSelector: aSelector in: aClass]! !!AndEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' & '.	andedEnvironment storeOn: aStream.	aStream nextPut: $)! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:19'!appendTextAnswer: aString	answer nextPutAll: aString! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/3/2005 09:52'!getAnyVariable	"answers the selected temporary or instance variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^ self getVariableIn: (tree allDefinedVariables union: self getClass instVarNames)		string: 'please choose a variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:14'!getArgOrTempNode	"answers the selected temporary variable, or prompts the user for one"	| tree node vars |	tree := self getParseTree.	node := self getNode.	vars := tree allDefinedVariables.	(node isVariable and: [vars includes: node name]) ifTrue: [^ node].	^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:15'!getArgumentVariable	"answers the selected temporary variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^self getVariableIn: tree allArgumentVariables		string: 'please choose an argument'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:15'!getAssignmentNode	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |	node := self getNode.	[node isNil or: [node isAssignment]] whileFalse: [node := node parent].	^ node! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getCategoryName	self caption:'Enter class category'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:19'!getClassVariable	"answers the selected instance variable, or prompts the user for one"	| class |	class := self getClass.	^ self getVariableIn: class theNonMetaClass classVarNames			string: 'please choose a class var'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:58'!getClassVariableName	^ self getClassVariable! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 7/6/2005 16:18'!getInstanceVariable	"answers the selected temporary variable, or prompts the user for one"	^ self getVariableIn: self getClass instVarNames		string: 'please choose an instance variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/3/2005 09:38'!getInstanceVariableName	^ self getInstanceVariable! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:33'!getInstanceVariablesToMoveInTheNewClassCollection	self getClass instVarNames		do: [:iv | self appendTextAnswer: iv]		separatedBy: [self appendTextAnswer: ' '].	self caption: 'Enter the list of instance variables to be moved to the new superclass'.	^ self getStringCollection		! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 1/4/2006 16:02'!getMessage	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |		(self  isSymbol: (node := self getNode) ) ifTrue: [^ node value].	[node isNil  or:[node isMessage]]  whileFalse:[node _ node parent].	^ node  ifNil:[self getSelector]  ifNotNil:[node selector]! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:21'!getMessageNode	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |	node := self getNode.	[node isNil or: [node isMessage]] whileFalse: [node := node parent].	^ node! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 3/8/2006 11:40'!getMethodCategoryName	^ self getReference category! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getNewClassName	self caption:'Enter new class name'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getNewSuperClassName	self caption:'Enter new (super)class name'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:43'!getNewVariableWhereRequestsWillBeForwarded	self caption: 'Enter the name of the (new) variable 	where all requests will be forwarded to'.	^ self getString! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getNode	| n |	n := self getBrowser findNodeUnderCaret.	n ifNil: [^RBProgramNode new].	^n! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getParseTree	^ self getBrowser parseTree! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 2/20/2007 18:45'!getRBEnv	"overriden in browserbooster to have real environments"		^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getReference	^ self getBrowser methodReference! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectedInterval	^ self getBrowser selectedInterval! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectedText	^ self getBrowser selectedText! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectionNode	^ self getBrowser findSelectionNode! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:48'!getSubclasses	self caption:'Enter (existing) subclasses of the new class'.	^ self getClassCollection! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:22'!getSubclassesToMoveCollection	self getClass subclasses do: [:sc | self appendTextAnswer: sc name asString]			separatedBy: [self appendTextAnswer: ' '].	self caption: 'Enter the list of subclasses to be moved to the new superclass'.	^ self getSymbolCollection		! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:22'!getTempNode	"answers the selected temporary variable, or prompts the user for one"	| tree node vars |	tree := self getParseTree.	node := self getNode.	vars := tree allDefinedVariables difference: tree allArgumentVariables.	(node isVariable and: [vars includes: node name]) ifTrue: [^ node].	^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:22'!getTemporaryVariable	"answers the selected temporary variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^ self getVariableIn: (tree allDefinedVariables difference: tree allArgumentVariables)		string: 'please choose a temporary variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:23'!getVariableIn: varList string: str 	| node |	node := self getNode.	(node isVariable and: [varList includes: node name]) ifTrue: [^node name].	^varList chooseOne: str! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 1/4/2006 16:01'!isSymbol: node 	^ node isLiteral  and:[node value isSymbol]! !!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/25/2005 09:11'!accept	done := true! !!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/27/2005 13:38'!cancel	self deselectAll.	done := true! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!categoryAndClassChooserMorph	^(Morph new)		color: Color transparent;		borderWidth: 0;		layoutPolicy: ProportionalLayout new;		addMorph: self classCategoryMorph			fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 1));		addMorph: self classMorph			fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0.5 @ 1));		yourself! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classCategoryMorph	^self listMorphFor: classCategories! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classMorph	^self listMorphFor: classes! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:02'!getClassEnvironmentFromUser	"Wait for the user to choose classes, then accept or cancel.	Answers a (possibly empty) ClassEnvironment."	| m |	m := self morphicDialog.	self runModal: ((SystemWindow labelled: 'Select classes')				model: self;				addMorph: m frame: (0 @ 0 corner: 1 @ 1);				yourself).	^self selectedClassEnvironment! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/25/2005 09:24'!getSelectorEnvironmentFromUser	^self getClassEnvironmentFromUser asSelectorEnvironment! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:41'!listMorphFor: aPluggableListOfManyArray 	^aPluggableListOfManyArray listMorph! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:49'!morphicDialog	| m |	m := AlignmentMorph newColumn.	m		extent: 400 @ 400;		borderWidth: 2;		color: Color white.	m addMorphBack: ((self categoryAndClassChooserMorph)				vResizing: #spaceFill;				hResizing: #spaceFill;				yourself).	m 		addMorphBack: (((AlignmentMorph inARow: { 						(SimpleButtonMorph newWithLabel: 'OK')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #accept;							yourself.						m transparentSpacerOfSize: 40 @ 1.						(SimpleButtonMorph newWithLabel: 'Cancel')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #cancel;							yourself})				hResizing: #spaceFill;				borderWidth: 0;				yourself)				listCentering: #center;				yourself).	^m! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 14:50'!runModal: m 	done := false.	World addMorph: m centeredNear: ActiveHand position.	m openInWorld.	[done] whileFalse: [World doOneCycle].	m delete.	World doOneCycle! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!classCategoryMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package category |	category := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: category.	package := self packageForSystemCategory: category.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!classMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package class |	class := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: (self class environment organization categoryOfElement: class).	package := self packageForClassNamed: class.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!packageForClassNamed: aClass	^PackageInfo allPackages detect: [ :p | p includesClassNamed: aClass ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!packageForSystemCategory: aClassCategory	^PackageInfo allPackages detect: [ :p | p includesSystemCategory: aClassCategory ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectCategory: cat 	| classList |	classCategories listSelectionAt: (classCategories list indexOf: cat asString) put: true.	classList := classes list.	(SystemOrganization listAtCategoryNamed: cat) do: [ :clsName |		classes listSelectionAt: (classList indexOf: clsName asString) put: true	].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectPackage: aPackage 	classCategories list withIndexDo: 			[:catName :i | 			(aPackage includesSystemCategory: catName) 				ifTrue: 					[ self selectCategory: catName]]! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:36'!classesFromCategories	^classCategories trueIndexes inject: SortedCollection new into:		[:partialList :each | partialList addAll: (SystemOrganization listAtCategoryNumber: each).		partialList].! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:41'!defaultClassCategoriesModel	^(MultipleSelectionModel withModel: self		withList: SystemOrganization categories)		menuGetter: #classCategoryMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:42'!defaultClassesModel	^(MultipleSelectionModel 		withModel: self		withList: #()		withMessage: #classesFromCategories)		menuGetter: #classMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!deselectAll	classes selectNone.! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!selectedClassEnvironment	| cls |	^ClassEnvironment new		classes: (Array streamContents: [ :s |			classes selectedItems do: [:clsName |				cls := Smalltalk at: clsName.				s nextPut: cls; nextPut: cls class ]]);		yourself! !!CategoryAndClassSelector methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 13:37'!initialize	done := false.	classCategories := self defaultClassCategoriesModel.	classCategories addDependent: self.	classes := self defaultClassesModel.	self addDependent: classes! !!CategoryAndClassSelector methodsFor: 'updating' stamp: 'nk 2/27/2005 14:18'!update: aSelector	self changed: #classesFromCategories! !!CategoryEnvironment methodsFor: 'accessing'!categories	^categories select: [:each | self includesCategory: each]! !!CategoryEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		classesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!CategoryEnvironment methodsFor: 'initialize-release'!categories: aCollection	categories := aCollection! !!CategoryEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	categories := Set new! !!CategoryEnvironment methodsFor: 'accessing-classes'!classNames	^self categories inject: OrderedCollection new into: [:col :each | col addAll: (self classNamesFor: each); yourself]! !!CategoryEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	categories do: [:each | stream nextPutAll: each; nextPut: $ ].	^stream contents! !!CategoryEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(categories includes: aCategory)		and: [super includesCategory: aCategory]! !!CategoryEnvironment methodsFor: 'testing'!includesClass: aClass 	^(super includesClass: aClass) and: 			[| nonMetaClass |			nonMetaClass := aClass isMeta 						ifTrue: [aClass soleInstance]						ifFalse: [aClass].			categories 				includes: (environment whichCategoryIncludes: nonMetaClass name)]! !!CategoryEnvironment methodsFor: 'testing'!isEmpty	^categories isEmpty! !!CategoryEnvironment methodsFor: 'as yet unclassified' stamp: 'nk 3/4/2005 12:43'!openEditor	^(ClassEnvironment onEnvironment: self classes: self classes) openEditor! !!CategoryEnvironment methodsFor: 'copying'!postCopy	categories := categories copy.	^super postCopy! !!CategoryEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' categories: '.	categories asArray storeOn: aStream.	aStream nextPut: $)! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 02:08'!accept	response := OrderedCollection new.	listSelections 		doWithIndex: [:selection :index | selection ifTrue: [response add: (values at: index)]].	response := response asArray.	isMultipleSelect 		ifFalse: [response := response ifEmpty: [nil] ifNotEmpty: [:col | col first]].	done := true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:13'!addButtonRow	| b spacer buttonRow |	b := SimpleButtonMorph new target: self; color: Color veryLightGray.	spacer := AlignmentMorph newSpacer: self color.	buttonRow := AlignmentMorph newRow		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds left@self lastSubmorph bottom.	buttonRow		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'OK'; actionSelector: #accept);		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'Cancel'; actionSelector: #cancel);		addMorphBack: spacer fullCopy.	self addMorphBack: buttonRow.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:12'!addLabel: queryString	| lines queryMorph |	lines := queryString asString findTokens: String cr.	queryMorph := AlignmentMorph newColumn		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds topLeft.	lines do: [:s | queryMorph addMorphBack: (StringMorph contents: s)].	self addMorph: queryMorph.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:29'!addLine	| line |	line := RectangleMorph new color: Color black;		extent: self width@borderWidth;		position: self left@self lastSubmorph bottom.	self addMorphBack: line.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:30'!cancel	response := cancelBlock value.	done := true.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:57'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	isMultipleSelect := multiSelectBoolean.	listSelections := listCollection collect: [:each | false].	values := listValues.	list := listCollection collect: [:each | each asString].	cancelBlock := aBlock.	done := false.	self openShowing: messageString.	self setInitialSelections: initialSelectionCollection.	^self getUserResponse! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:58'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	| w |	w := self world.	w ifNil: [^response].	done := false.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^response! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!list	^ list! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:07'!listIndex	^ listIndex! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!listSelectionAt: anInteger	^listSelections at: anInteger.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:03'!listSelectionAt: anInteger put: aBoolean	listSelections at: anInteger put: aBoolean.	self changed: #listSelectionAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:35'!openShowing: messageString 	| listPane |	self removeAllMorphs.	listIndex := 0.	self addLabel: messageString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	listPane := isMultipleSelect 				ifTrue: 					[PluggableListMorphOfMany 						on: self						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: nil						keystroke: nil]				ifFalse: 					[PluggableListMorph 						on: self						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: nil						keystroke: nil].	listPane		color: self color;		hResizing: #spaceFill; vResizing: #spaceFill;		position: self innerBounds left @ self lastSubmorph bottom.	self addMorphBack: listPane.	self addButtonRow.	self height: ((((self list size * listPane font height) + submorphs first height + submorphs last height) min: Display height * 2 / 3) max: 100).	World addMorph: self centeredNear: ActiveHand position! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response	^ response! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response: aText	"Sent when text pane accepts."	response := aText asString.	done := true.	^ true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:09'!setInitialSelections: aCollection 	list 		doWithIndex: [:item :index | self listSelectionAt: index put: (aCollection includes: item)].	listIndex := 0.	self changed: #listIndex.	self changed: #listIndexAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:08'!toggleListIndex: newListIndex	newListIndex isZero ifFalse: [		listSelections at: newListIndex put: (listSelections at: newListIndex) not.		self changed: #listSelectionAt: ].	listIndex := newListIndex.	self changed: #listIndex.! !!ChooserMorph methodsFor: 'accessing' stamp: 'bh 11/8/2000 16:30'!color	^Color white.! !!ChooserMorph methodsFor: 'submorphs-add/remove' stamp: 'bh 11/8/2000 16:30'!delete	self breakDependents.	^ super delete! !!ChooserMorph methodsFor: 'initialization' stamp: 'nk 2/25/2005 08:33'!initialize	super initialize.	self borderWidth: 0.	self layoutPolicy: TableLayout new.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self color: Color black.	self		layoutInset: 1;		cellInset: 0.	self extent: 200 @ 200.	listIndex := 0.! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:37'!chooseClassVarAlphabeticallyThenDo: aBlock	| allVars index |	allVars := self allClassVarNames asSortedArray.	allVars isEmpty ifTrue: [^ self inform: 'There are noclass variables'].	index := (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:36'!chooseClassVarThenDo: aBlock 	| lines labelStream vars allVars index count offerAlpha |	(count := self allClassVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noclass variables.'].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	(offerAlpha := count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index := (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseClassVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:38'!chooseSubclassesClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each classVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no class variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:25'!chooseSubclassesInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each instVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:39'!chooseThisClassClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self classVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no class variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:45'!chooseThisClassInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self instVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ASTCache class methodsFor: 'accessing' stamp: 'CamilloBruni 2/17/2012 14:22'!at: aCompiledMethod	^ default at: aCompiledMethod! !!ASTCache class methodsFor: 'accessing' stamp: 'CamilloBruni 2/17/2012 14:30'!default	^ default! !!ASTCache class methodsFor: 'accessing' stamp: 'CamilloBruni 2/17/2012 14:30'!default: anASTCache	default := anASTCache.! !!ASTCache class methodsFor: 'accessing' stamp: 'CamilloBruni 2/17/2012 14:27'!reset	default reset.! !!ASTCache class methodsFor: 'class initialization' stamp: 'CamilloBruni 2/20/2012 18:54'!initialize	default := self new.	Smalltalk addToShutDownList: self.! !!ASTCache class methodsFor: 'system startup' stamp: 'CamilloBruni 2/17/2012 15:10'!shutDown		self reset.! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!new	^self onEnvironment: BrowserEnvironment new! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!onEnvironment: anEnvironment 	^(self basicNew)		initialize;		onEnvironment: anEnvironment;		yourself! !!AndEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment and: anotherEnvironment 	^(self onEnvironment: anEnvironment)		andedEnvironment: anotherEnvironment;		yourself! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:11'!getClassEnvironmentFromUser	"	CategoryAndClassSelector getClassEnvironmentFromUser	"	^self new getClassEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:09'!getSelectorEnvironmentFromUser	"	CategoryAndClassSelector getSelectorEnvironmentFromUser	"	^self new getSelectorEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 15:03'!windowColorSpecification	^  WindowColorSpec classSymbol: self name  wording: 'Class chooser' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A dialog to select classes'! !!CategoryEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment categories: aCollection	^(self onEnvironment: anEnvironment)		categories: aCollection; yourself! !!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:24'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	^self new 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: initialSelectionCollection! !!ClassEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta		ifTrue: [metaClasses add: aClass soleInstance name]		ifFalse: [classes add: aClass name]! !!ClassEnvironment methodsFor: 'accessing' stamp: 'bh 6/10/2000 17:05'!asSelectorEnvironment	^SelectorEnvironment new		searchStrings:#();		label:self label;		onEnvironment: self environment;		classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;		yourself.! !!ClassEnvironment methodsFor: 'accessing'!problemCount	^self numberClasses! !!ClassEnvironment methodsFor: 'accessing-classes'!classNames	^(Set withAll: classes) addAll: metaClasses;		yourself! !!ClassEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classes		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class])				ifTrue: [aBlock value: class]].	metaClasses		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class class])				ifTrue: [aBlock value: class class]]! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!classSelectorDictionary	^classes inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) selectors;			yourself].	! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 17:53'!logOrInspect	Transcript cr; cr; show:self name.	(classes asArray, metaClasses asArray) asSet do: 		[:class | 		Transcript cr; show: '     ',class asString].! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!metaClassSelectorDictionary	^metaClasses inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) class selectors;			yourself].	! !!ClassEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' classes: (('.	classes asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.	metaClasses asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'! !!ClassEnvironment methodsFor: 'initialize-release'!classes: aCollection 	aCollection do: [:each | self addClass: each]! !!ClassEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classes := Set new.	metaClasses := Set new! !!ClassEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	classes do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ClassEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| class |						class := Smalltalk at: each ifAbsent: [nil].						class notNil and: [(self includesClass: class)								or: [self includesClass: class class]]]]]! !!ClassEnvironment methodsFor: 'testing'!includesClass: aClass 	^(aClass isMeta		ifTrue: [metaClasses includes: aClass soleInstance name]		ifFalse: [classes includes: aClass name])			and: [super includesClass: aClass]! !!ClassEnvironment methodsFor: 'testing'!isClassEnvironment	^true! !!ClassEnvironment methodsFor: 'testing'!isEmpty	^classes isEmpty and: [metaClasses isEmpty]! !!ClassEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(ClassEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!ClassEnvironment methodsFor: 'copying'!postCopy	classes := classes copy.	metaClasses := metaClasses copy.	^super postCopy! !!ClassEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta		ifTrue: [metaClasses remove: aClass soleInstance name ifAbsent: []]		ifFalse: [classes remove: aClass name ifAbsent: []]! !!ClassEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment classes: aCollection	^(self onEnvironment: anEnvironment)		classes: aCollection; yourself! !!ClassToRename methodsFor: 'performing'!method1	^self method2! !!ClassToRename methodsFor: 'performing'!method2	^self method1! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:45'!includesBehavior: aClass	^false! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:37'!soleInstance	^baseTrait! !!DuplicationNodeEliminationTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testDuplicateLoop	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 1.	node3 := SmaCCNode new.	node3 action: 1.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 1.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects = 'a'.	self assert: node1 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testNoDuplicates	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 3.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 3.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects = 'a'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects = 'a'.	node3 := node2 transitions first to.	self deny: node1 = node3.	self deny: node2 = node3.	self assert: node3 transitions size = 1.	self assert: (node3 action includes: 3).	self assert: node3 transitions first transitionObjects = 'a'.	self assert: node3 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testSimpleDuplicateWithEdges	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node2 addEdgeTo: node1 onCharacters: 'c'.	node3 addEdgeTo: node1 onCharacters: 'c'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self assert: node1 transitions first transitionObjects = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects = 'c'.	self assert: node2 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testSimpleTerminalDuplicate	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self assert: node1 transitions first transitionObjects = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions isEmpty.	self assert: (node2 action includes: 2)! !!ExampleParserTests methodsFor: 'testing-java' stamp: 'lr 1/8/2007 22:30'!testApplet	JavaParser parse: '// Hello.javaimport java.applet.Applet;import java.awt.Graphics;public class Hello extends Applet {   public void paint(Graphics gc) {      gc.drawString("Hello, world!!", 65, 95);   }    }'! !!ExampleParserTests methodsFor: 'testing-java' stamp: 'lr 1/8/2007 22:30'!testServlet	JavaParser parse: '// Hello.javaimport java.io.*;import javax.servlet.*;public class Hello extends GenericServlet {    public void service(ServletRequest request, ServletResponse response)        throws ServletException, IOException {       response.setContentType("text/html");       PrintWriter pw = response.getWriter();       pw.println("Hello, world!!");       pw.close();    }}'! !!ExampleParserTests methodsFor: 'testing-java' stamp: 'lr 1/8/2007 22:30'!testStandAlone	JavaParser parse: '// Hello.javapublic class Hello {    public static void main(String[] args) {        System.out.println("Hello, World!!");     } }'! !!ExampleParserTests methodsFor: 'testing-java' stamp: 'lr 1/8/2007 22:30'!testSwing	JavaParser parse: '// Hello.java (Java SE 5)import java.awt.BorderLayout;import javax.swing.*;public class Hello extends JFrame {   public Hello() {      super("hello");      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      setLayout(new BorderLayout());      getContentPane().add(new JLabel("Hello, world!!"));      pack();   }   public static void main(String[] args) {      new Hello().setVisible(true);   }}'! !!ExampleParserTests methodsFor: 'testing-c' stamp: 'lr 1/8/2007 22:30'!testEcho	CParser parse: 'int main(int argc, char *argv[]) {	int i;	for (i = 0; i < argc; i++) {		printf("%s", argv[i]);	}}'! !!ExampleParserTests methodsFor: 'testing-c' stamp: 'lr 1/8/2007 22:30'!testHello	CParser parse: 'main( ) {	printf("Hello World\n");}'! !!ExampleParserTests methodsFor: 'testing-st' stamp: 'lr 1/8/2007 22:34'!testSelfParsing	StParser parseMethod: (self class 		sourceCodeAt: thisContext selector)! !!ExampleParserTests methodsFor: 'testing-st' stamp: 'lr 1/8/2007 22:32'!testTranscript	StParser parseExpression: 'Transcript show: ''Hello World''; cr'! !!ExampleParserTests class methodsFor: 'testing' stamp: 'lr 1/8/2007 22:12'!testJava1	JavaParser parse: '// Hello.javapublic class Hello {    public static void main(String[] args) {        System.out.println("Hello, World!!");     } }'! !!ExampleParserTests class methodsFor: 'testing' stamp: 'lr 1/8/2007 22:12'!testJava2	JavaParser parse: 'package Hello;import java.applet.Applet;import java.awt.Graphics;public class Hello extends Applet {   public void paint(Graphics gc) {      gc.drawString("Hello, world!!", 65, 95);   }    }'! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/25/2005 10:26'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu		addLine;		add: 'select classes to operate on' target: self action: #chooseClasses;		yourself.! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:42'!canSearch	^searchEnvironment isEmpty not ! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.9! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:28'!createMorphicWindow	| conditionsPane searchStringPane window |	window := (SystemWindow labelled: self labelString) model: self.	searchStringPane := PluggableTextMorph 				on: self				text: #searchPatternString				accept: #searchString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: searchStringPane frame: self searchStringPaneFrame.	conditionsPane := PluggableTextMorph 				on: self				text: #conditionString				accept: #conditionString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: conditionsPane frame: self conditionsPaneFrame.	window addMorph: (PluggableTextMorph 				on: self class				text: #jokerHelp				accept: nil				readSelection: nil				menu: nil)		frame: self commentPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: #canSearch				action: #searchAndOpenEditor)				label: 'Search';				onColor: self defaultBackgroundColor lighter					offColor: self defaultBackgroundColor darker)		frame: self searchButtonFrame.	window addMorph: self methodCheckBoxPane frame: self methodCheckBoxFrame.	^window! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:29'!methodCheckBoxFrame	^0.5 @ 0.9 corner: 1 @ 1! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:53'!methodCheckBoxPane	^(AlignmentMorph newRow)		cellInset: 4;		listCentering: #center;		wrapCentering: #center;		addMorph: ((UpdatingThreePhaseButtonMorph checkBox)					target: self;					getSelector: #searchMethods;					actionSelector: #toggleSearchMethods);		addMorph: (TextMorph new contentsAsIs: 'Search Entire Methods' translated);		yourself! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:43'!openAsMorph	"self new openAsMorph"	| window |	window := self createMorphicWindow.	self changed: #canSearch.	window		center: Display center;		extent: 100 @ 100.	window openInWorld.	^window! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:16'!searchButtonFrame	^0 @ 0.9 corner: 0.5 @ 1! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 12:59'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!FinderTool methodsFor: 'class membership' stamp: 'nk 2/27/2005 13:48'!chooseClasses	| newEnvironment |	newEnvironment := CategoryAndClassSelector new getClassEnvironmentFromUser.	newEnvironment isEmpty ifFalse: [self searchEnvironment: newEnvironment]! !!FinderTool methodsFor: 'menus' stamp: 'nk 3/1/2005 07:35'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu := shifted		ifTrue:			[ParagraphEditor shiftedYellowButtonMenu]		ifFalse:			[ParagraphEditor yellowButtonMenu].	^ aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!conditionString	^conditionString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/24/2005 14:39'!conditionString: anObject	conditionString := anObject.	foundEnvironment := nil.	self changed: #conditionString.	^true! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment	^foundEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment: anObject	foundEnvironment := anObject! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:36'!labelString	^self class name, ' on ', self searchEnvironment printString! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/27/2001 18:40'!searchEnvironment	^searchEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:35'!searchEnvironment: anObject	searchEnvironment := anObject.	foundEnvironment := nil.	self changed: #relabel.! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods	^searchMethods! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods: anObject	searchMethods := anObject! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:32'!searchPatternString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!searchString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:33'!searchString: aString	searchString := aString.	foundEnvironment := nil.	self changed: #searchPatternString.	^true! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:56'!toggleSearchMethods	| wasDefault |	wasDefault := self searchString = self defaultSearchString.	searchMethods := searchMethods not.	wasDefault ifTrue: [self searchString: self defaultSearchString]! !!FinderTool methodsFor: 'initialization' stamp: 'nk 8/13/2003 16:39'!createConditionBlock	^self conditionString isEmpty 		ifFalse: [Compiler evaluate: '[ :aNode | ' , conditionString , ' ]' for: self logged: false ]		ifTrue: [[:aNode | true]]! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:54'!defaultExpressionSearchString	^'`@Expression halt'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultMethodSearchString	^'`methodName: `@args	| `@temps |	^`@Expression'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultSearchString	^self searchMethods ifTrue: [ self defaultMethodSearchString ] ifFalse: [ self defaultExpressionSearchString ].! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:55'!initialize	conditionString := 'true'.	self searchEnvironment: BrowserEnvironment new.	searchMethods := false.	searchString := self defaultSearchString.! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:42'!search	| env |	self dependents 		do: [:dep | (dep respondsTo: #accept) ifTrue: [dep hasUnacceptedEdits ifTrue: [ dep accept]]].	([ self searchEnabled ] on: Error do: [ :ex | ex return: false ])		ifFalse: [ ^self inform: 'bad search string' ].	Cursor wait showWhile: 			[ env := (self searchFor: searchString asString				when: (self createConditionBlock ifNil: [^self flash])).				self foundEnvironment: env ]! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:41'!searchAndOpenEditor	self search.	self foundEnvironment ifNotNilDo: [ :env | env openEditor ]! !!FinderTool methodsFor: 'actions' stamp: 'jws 10/23/2016 05:38'!searchFor: pattern when: conditionalBlock	| newEnv searches selector |	newEnv := SelectorEnvironment onEnvironment: BrowserEnvironment new.	searches := Set new.	selector := self searchMethods		ifTrue: [ #replaceMethod:withValueFrom:when: ]		ifFalse: [ #replace:withValueFrom:when: ].	searchEnvironment		classesAndSelectorsDo: [ :currentClass :currentSelector | 			| methodTree |			searchClass := currentClass.			methodTree := currentClass parseTreeFor: currentSelector.			methodTree				ifNotNil: [ 					(ParseTreeRewriter new						perform: selector						with: pattern						with: [ :tree | 							searches add: ((currentClass sourceCodeAt: currentSelector) copyFrom: tree start to: tree stop).							newEnv addClass: currentClass selector: currentSelector.							tree ]						with: conditionalBlock) executeTree: methodTree ] ].	searchClass := nil.	newEnv searchStrings: searches.	^ newEnv! !!FinderTool methodsFor: 'testing' stamp: 'nk 3/5/2005 16:43'!searchEnabled	^self searchMethods 		ifTrue: [(RBParser parseRewriteMethod: searchString) notNil]		ifFalse: [(RBParser parseRewriteExpression: searchString) notNil]! !!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:16'!initialize	"self initialize"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	TheWorldMenu registerOpenCommand: {'Code Finder'. {self. #open}}.	self registerInFlapsRegistry.! !!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:17'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#FinderTool #prototypicalToolWindow 'Finder Tool' 'For finding advanced patterns in code' ) 						forFlapNamed: 'Tools']! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:54'!jokerHelp	^'This tool searches for code matching the pattern in the top pane.', self comment! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 09:32'!onBrowserEnvironment: anEvironment	^self new searchEnvironment: anEvironment! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/28/2001 23:31'!onClass: aClass	^self new searchEnvironment: (BrowserEnvironment new forClasses: {aClass}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/29/2001 00:03'!onClassCategory: aClassCategory	^self new searchEnvironment: (BrowserEnvironment new forCategories: {aClassCategory}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 07:43'!onClassHierarchyIncluding: aClass	| classes |	classes := Set new.	aClass withAllSubAndSuperclassesDo: [ :cls | classes add: cls ].	^self new searchEnvironment: (BrowserEnvironment new forClasses: classes).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:36'!onPackageWithClassCategory: aClassCategory	^self new searchEnvironment: ((BrowserEnvironment new forPackageContainingClassCategory: aClassCategory) ifNil: [ ^nil ])! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 8/27/2003 14:50'!open	self new openAsMorph! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:14'!prototypicalToolWindow	^(self new createMorphicWindow) extent: 400@400; yourself.! !!FinderTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!FinderTool class methodsFor: 'as yet unclassified' stamp: 'nk 2/27/2005 14:56'!windowColorSpecification	^RefactoringBrowser windowColorSpecification! !!LineNumberStreamTest methodsFor: 'private' stamp: ' 6/1/07 21:20'!addCRLFsTo: aString 	^aString copyReplaceAll: '\'		with: (String with: Character cr with: Character lf)! !!LineNumberStreamTest methodsFor: 'private' stamp: ' 6/1/07 21:20'!addCRsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character cr)! !!LineNumberStreamTest methodsFor: 'private' stamp: ' 6/1/07 21:20'!addLFsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character lf)! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character cr]! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testEmptyLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '\\\')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			stream upTo: Character cr]! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testForwardPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addLFsTo: '1234\1234\1234\1234')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testNoLines	| stream index |	stream := SmaCCLineNumberStream on: (ReadStream on: 'this is a test').	self assert: stream lineNumber = 1.	index := 1.	stream do: 			[:each | 			self assert: stream lineNumber = 1.			index := index + 1.			self assert: stream columnNumber = index]! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LineNumberStreamTest methodsFor: 'tests' stamp: ' 6/1/07 21:20'!testPositionCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream skip: -1.	self assert: stream lineNumber = 4.	self assert: stream columnNumber = 1.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 2.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!canRun	^tests anySelected 		and: [self environment notNil and: [self environment isEmpty not]]! !!LintDialog methodsFor: 'actions' stamp: 'nk 2/27/2005 13:14'!resultsForEnvironment: anEnvironment 	| allResults progress addAmount |	progress := ProgressMorph label: 'SLint progress'.	progress openInWorld.	addAmount := 1.0 / tests selectedItems size.	allResults := tests selectedItems				collect: [:each | 					progress subLabel: each name.					progress incrDone: addAmount.					SmalllintChecker runRule: each onEnvironment: anEnvironment].	progress delete.	^ allResults		select: [:each | each result problemCount > 0]! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!run	self canRun ifFalse: [^self].	Cursor wait 		showWhile: [results := self resultsForEnvironment: self environment].	self resultsDialog! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:07'!runOnEnvironment: anEnvironment	self environment: anEnvironment.	results := #().	tests anySelected		ifFalse: [^ self].	anEnvironment isEmpty		ifTrue: [^ self].	Cursor wait		showWhile: [results := self resultsForEnvironment: anEnvironment].	self resultsDialog! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!selectClasses	selector ifNil: [selector := CategoryAndClassSelector new].	self environment: selector getClassEnvironmentFromUser.	self changed: #canRun! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:44'!canSelectClasses	^true! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:10'!labelString	| theLabel |	theLabel := self environment printStringLimitedTo: 60.	^theLabel isEmpty ifFalse: [ 'SmallLint on ', theLabel ] ifTrue: ['SmallLint'].! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:09'!lintWindow	^(SystemWindow labelled: self labelString)		model: self;		addMorph: testCategories listMorph frame: (0.0 @ 0.0 extent: 1 @ 0.3);		addMorph: tests listMorph			fullFrame: (LayoutFrame fractions: (0.0 @ 0.3 extent: 1 @ 0.7)					offsets: (0 @ 0 corner: 0 @ -40));		addMorph: self selectClassesButton			fullFrame: (LayoutFrame fractions: (0 @ 1 corner: 0.5 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		addMorph: self runButton			fullFrame: (LayoutFrame fractions: (0.5 @ 1 corner: 1 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		yourself! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 11:09'!makeResultDialogOn: aNumber	| env |	aNumber = 0 ifTrue: [^self].	env := (results at: aNumber) result.	env openEditor.! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!open	| w |	w := self lintWindow openInWorld; yourself.	self changed: #canRun.	self changed: #canSelectClasses.	^w! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 14:38'!resultsDialog	| theLabel |	theLabel := self labelString copyReplaceAll: 'SmallLint on' with: 'SmallLint Results for'.	^(SystemWindow labelled: theLabel)		model: self;		addMorph: (self resultsListMorph) frame:(0@0 extent: 1@1);		openInWorld;		yourself! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 14:24'!resultsListMorph	| list |	list := PluggableListMorph 				on: self				list: #resultsAsText				selected: #returnZero				changeSelected: #makeResultDialogOn:.	^list! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!runButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canRun				action: #run.	button		label: 'Run';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	self addDependent: button.	^button! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!selectClassesButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canSelectClasses				action: #selectClasses.	button		label: 'Select Classes';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	^button! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!defaultTestsCategoriesModel	^ MultipleSelectionModel withModel: self withList: self determineTestCategories! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:23'!defaultTestsModel	^(MultipleSelectionModel 		withModel: self 		withList: #()		withMessage: #testsFromCategories)		menuGetter: #listMenuFor:in:;		yourself! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 13:38'!determineTestCategories	| taskCategories |	taskCategories := (self determineTestCategoriesForClass: BlockLintRule),		(self determineTestCategoriesForClass: ParseTreeLintRule).	taskCategories removeAllFoundIn: #(#'instance creation' #private #accessing).		^taskCategories asArray! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 08:46'!determineTestCategoriesForClass: aClass 	^ aClass withAllSubclasses		inject: Set new		into: [:sum :each | sum addAll: each class organization categories;				 yourself]! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!initialize	super initialize.	tests := self defaultTestsModel.	tests addDependent: self.	testCategories := self defaultTestsCategoriesModel.	testCategories addDependent: self.	testCategories addDependent: tests.! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:05'!environment	^environment! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:10'!environment: anObject	environment := anObject.	results := #().	self changed: #canRun.! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:46'!resultsAsText	^results collect:[:each| each asString , ' [' , each result problemCount asString , ']']! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!returnZero	^0! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:45'!testsFromCategories	^testCategories selectedItems inject: Array new into:		[:partialList :each | (self testsFromCategory: each) , partialList].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aCategory 	^ (self testsFromCategory: aCategory inClassAndSubclasses: BlockLintRule)		, (self testsFromCategory: aCategory inClassAndSubclasses: ParseTreeLintRule)! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClass: aClass	| classTests |	classTests := aClass class organization listAtCategoryNamed: aSymbol.	^classTests collect:[: each | aClass perform: each].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClassAndSubclasses: aClass 	| classAndSubclassesTests |	classAndSubclassesTests := (self testsFromCategory: aSymbol inClass: aClass) asOrderedCollection.	aClass allSubclasses		do: [:each | classAndSubclassesTests				addAll: (self testsFromCategory: aSymbol inClass: each)].	^ classAndSubclassesTests! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!listMenuFor: aMenu in: aMultipleSelectionModel 	aMenu add: 'View rationale for selected rules'		target: self		selector: #viewRationaleForSelectionsIn:		argument: aMultipleSelectionModel.! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!viewRationaleForSelectionsIn: aMultipleSelectionModel	| rationale |	rationale := String streamContents: [ :strm |		aMultipleSelectionModel selectedItems do: [ :rule | | str |			str := rule rationale.			str isEmpty ifFalse: [ strm nextPutAll: rule name; cr; nextPutAll: str; cr; cr ]]].	(StringHolder new contents: rationale)		openLabel: 'Rationale for selected rules'! !!LintDialog methodsFor: 'updating' stamp: 'nk 2/27/2005 15:29'!update: aSymbol	aSymbol == #allSelections ifTrue: [		self changed: #canRun.	]! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Lint'. {self. #open}}.	self registerInFlapsRegistry.! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#LintDialog #prototypicalToolWindow 'SmallLint' 'A tool to check for bugs in code' ) 						forFlapNamed: 'Tools']! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!unload	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self].	TheWorldMenu unregisterOpenCommandWithReceiver: self.! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 11:10'!onEnvironment: anEnvironment	self new environment: anEnvironment; open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!open	^self new open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^self new lintWindow! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/27/2005 13:19'!runOnEnvironment: anEnvironment	self new open; runOnEnvironment: anEnvironment! !!LintDialog class methodsFor: 'window color' stamp: 'nk 2/27/2005 15:00'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name  wording: 'Lint' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A tool for finding bugs in your code'! !!LintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^#()! !!LintRule methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRule methodsFor: 'accessing'!name	^name! !!LintRule methodsFor: 'accessing'!name: aString 	name := aString! !!LintRule methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale	"Answer the rationale for this rule."	^rationale ifNil: [ ^'' ]! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale: anObject	rationale := anObject! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!run	^SmalllintChecker runRule: self! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!runOnEnvironment: anEnvironment 	^SmalllintChecker runRule: self onEnvironment: anEnvironment! !!LintRule methodsFor: 'printing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ['.	self problemCount printOn: nameStream.	nameStream nextPut: $].	^nameStream contents! !!LintRule methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!LintRule methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	self subclassResponsibility! !!LintRule methodsFor: 'testing'!hasConflicts	^false! !!LintRule methodsFor: 'testing'!isComposite	^false! !!LintRule methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRule methodsFor: 'initialize-release'!initialize! !!LintRule methodsFor: 'initialize-release'!resetResult! !!BasicLintRule methodsFor: 'private'!defaultResultClass	^SelectorEnvironment! !!BasicLintRule methodsFor: 'private' stamp: 'md 3/26/2007 12:18'!openWithFilters	| |	self needsWork.	"browser := self filteredResult openEditor.	navigator := browser navigator.	filter := navigator environment andedEnvironment environment.	(filter isClassEnvironment or: [filter isSelector]) 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for class'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass.					filter addClass: navigator selectedClass.					navigator updateCategoryList].			navigator classMenu value addItemGroup: (Array with: menuItem).			navigator updateClassMenu].	filter isSelector 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for selector'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass						selector: navigator selector.					filter addClass: navigator selectedClass selector: navigator selector.					navigator updateCategoryList].			navigator selectorMenu value addItemGroup: (Array with: menuItem).			navigator updateSelectorMenu].	^browser"! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!openWithoutFilters	^self result openEditor! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!viewResults	^self perform: openSymbol! !!BasicLintRule methodsFor: 'accessing'!filteredResult	^(result 		& (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copy not)		label: result label;		yourself! !!BasicLintRule methodsFor: 'accessing'!problemCount	^self result problemCount! !!BasicLintRule methodsFor: 'accessing'!result	^(self class filterDictionary includesKey: self name) 		ifTrue: [self filteredResult]		ifFalse: [result]! !!BasicLintRule methodsFor: 'initialize-release'!initialize	super initialize.	openSymbol := #openWithFilters.	self resultClass: self defaultResultClass! !!BasicLintRule methodsFor: 'initialize-release'!openUsing: aSymbol 	openSymbol := aSymbol! !!BasicLintRule methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRule methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRule methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRule methodsFor: 'testing'!isEmpty	^self result isEmpty! !!BasicLintRule class methodsFor: 'accessing'!addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copy! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary	^FilterDictionary isNil 		ifTrue: [FilterDictionary := Dictionary new]		ifFalse: [FilterDictionary]! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary: aDictionary 	FilterDictionary := aDictionary! !!BasicLintRule class methodsFor: 'accessing'!filterFor: aName 	^self filterDictionary at: aName ifAbsentPut: [SelectorEnvironment new]! !!BasicLintRule class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!BasicLintRule class methodsFor: 'storing'!storeFiltersOn: aStream 	aStream		nextPut: $(;		nextPutAll: self name;		nextPutAll: ' filterDictionary: (Dictionary new'.	self filterDictionary keysAndValuesDo: 			[:key :value | 			aStream nextPutAll: ' at: '.			key storeOn: aStream.			aStream nextPutAll: ' put: '.			value storeOn: aStream.			aStream				nextPutAll: ';';				cr].	aStream		tab;		nextPutAll: 'yourself))'! !!BlockLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock! !!BlockLintRule methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ]! !!BlockLintRule methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!BlockLintRule class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!classInstVarNotInitialized	| detector |	detector := self new.	detector name: 'Has class instance variables but no initialize method'.	detector resultClass: ClassEnvironment.	detector classBlock: 		[:context :result | 		| definesVar class |		context selectedClass isMeta			ifTrue: 				[class := context selectedClass.				definesVar := false.				[definesVar or: [class isNil or: [class isMeta not]]]					whileFalse: 						[definesVar := class instVarNames isEmpty not.						class := class superclass].				(definesVar and: [(context selectedClass includesSelector: #initialize) not])					ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 2/25/2005 11:37'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector rationale: 'If objects of a class redefine equality, then to work properly in hashed collections like Sets or Dictionaries they must also have a hash method that returns equal hashes for each pair of objects for which = returns true.'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'md 8/2/2005 23:20'!literalArrayContainsComma	| detector |	detector := self new.	detector name: 'Literal array contains a #,'.	detector methodBlock: 			[:context :result | 			(context compiledMethod allLiterals inject: false				into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!literalArrayContainsSuspiciousTrueFalseOrNil	| detector searcher |	detector := self new.	detector name: 'Literal array contains a #true, #false, or #nil but the source doesn''t.'.	detector		rationale:			'With ANSI changes, #(true false nil) now is equal to {true. false. nil} not {#true. #false. #nil} as it used to be.This may be a bug.'.	searcher := ParseTreeSearcher new.	searcher		matches: '`{ :n | n isLiteral and: [ n token realValue isKindOf: Array ] }'		do: [ :aNode :answer | 			answer				addAll: (self literalTrueFalseOrNilSymbolsIn: aNode token realValue);				yourself ].	detector		methodBlock: [ :context :result | 			| compiledLits parsedLits |			compiledLits := self literalTrueFalseOrNilSymbolsIn: context compiledMethod allLiterals.			compiledLits size > 0				ifTrue: [ 					parsedLits := OrderedCollection new.					searcher executeTree: context parseTree initialAnswer: parsedLits.					compiledLits size ~= parsedLits size						ifTrue: [ result addClass: context selectedClass selector: context selector ] ] ].	^ detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:18'!overridesSuper	| detector definer superMethod |	detector := self new.	detector name: 'Overrides super method without calling it'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [true "self superMessages includes: context selector"]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher		matches: '^``@xObject'		do: [ :aNode :answer | 			answer				add: aNode value;				yourself ].	detector		methodBlock: [ :context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new)				do: [ :each | 					hasBool := hasBool						or: [ 							(each isLiteral								and: [ 									{true.									false} includes: each value ]) or: [ each isMessage and: [ #(#and: #or:) includes: each selector ] ] ].					hasSelf := hasSelf						or: [ 							(each isVariable and: [ each name = 'self' ])								or: [ 									each isLiteral										and: [ 											({true.											false} includes: each value) not ] ] ] ].			hasSelf & hasBool				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BlockLintRule class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:20'!superSends	| detector definer superMethod |	detector := self new.	detector name: 'Missing super sends in selected methods.'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [ self superMessages includes: context selector ]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := ParseTreeSearcher new		matchesArgument: '`xxxvar'			do: [ :aNode :answer | 					answer						or: [ 							varName := aNode name.							vars includes: varName ] ];		yourself.	detector		methodBlock: [ :context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ 					result addClass: context selectedClass selector: context selector.					result addSearchString: varName ] ].	^ detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'bh 3/16/2000 12:07'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector methodBlock: 			[:context :result | 			(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 				do: 					[:each | 					result addClass: context selectedClass selector: context selector.					result addSearchString: each]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta and: 					[(context selector						indexOfSubCollection: context selectedClass soleInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector		name: 'Instance variables defined in all subclasses';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							| count |							count := sels occurrencesOf: val.							count == subs size 								ifTrue: [result addClass: context selectedClass instanceVariable: val]]]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher		matches: '`.Stmt'		do: [ :aNode :answer | (aNode children inject: answer into: [ :sum :each | matcher executeTree: each initialAnswer: sum ]) + 1 ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: 0) >= self longMethodSize				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BlockLintRule class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMeta						ifTrue: [context selectedClass soleInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels do: [:each | result addClass: context selectedClass selector: each].			sels isEmpty ifFalse: [result addSearchString: className]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'bh 4/29/2000 23:31'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	self needsWork."	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta | (context selector numArgs == 0) or: 					[(context protocols detect: 							[:each | 							(self utilityProtocols detect: [:protocol | protocol match: each]								ifNone: [nil]) notNil]						ifNone: [nil]) notNil]) 				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector) 						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) 								ifTrue: 									[(context selectedClass allInstVarNames 										, context selectedClass allClassVarNames asArray , #('self') 										detect: [:each | context parseTree references: each]										ifNone: [nil]) isNil 										ifTrue: [result addClass: context selectedClass selector: context selector]]]]]."	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!variableAssignedLiteral	| detector |	detector := self new.	detector		name: 'Variable is only assigned a single literal value';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector		classBlock: [ :context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames				do: [ :each | 					| defClass selector |					(allSubclasses						inject: 0						into: [ :sum :class | 							| sels |							sels := class whichSelectorsAssign: each.							sels size == 1								ifTrue: [ 									selector := sels asArray first.									defClass := class ].							sum + sels size ]) == 1						ifTrue: [ 							| tree searcher |							searcher := ParseTreeSearcher new.							searcher matches: each , ' := ``@object' do: [ :aNode :answer | answer isNil and: [ aNode value isLiteral ] ].							tree := defClass parseTreeFor: selector.							tree notNil								ifTrue: [ 									(searcher executeTree: tree initialAnswer: nil) == true										ifTrue: [ result addClass: context selectedClass instanceVariable: each ] ] ] ] ].	^ detector! !!BlockLintRule class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BlockLintRule class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BlockLintRule class methodsFor: 'private'!doesLiteralArrayContainComma: aLiteral 	aLiteral class == Array ifFalse: [^false].	(aLiteral includes: #,) ifTrue: [^true].	^aLiteral inject: false		into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]! !!BlockLintRule class methodsFor: 'private' stamp: 'nk 3/4/2005 16:32'!literalTrueFalseOrNilSymbolsIn: aLiteral 	| retval |	aLiteral class == Array ifFalse: [^#()].	retval := OrderedCollection withAll: (aLiteral select: [:ea | ea isSymbol and: [#(#true #false #nil ) includes: ea]]).	aLiteral do: [ :each | retval addAll: (self literalTrueFalseOrNilSymbolsIn: each) ].	^retval.! !!BlockLintRule class methodsFor: 'private'!longMethodSize	^10! !!BlockLintRule class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BlockLintRule class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	^(aClass subclasses detect: 			[:each | 			(each includesSelector: aSelector)				or: [self subclassOf: each overrides: aSelector]]		ifNone: [nil]) notNil! !!BlockLintRule class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BlockLintRule class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BlockLintRule class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMeta				or: [context selectedClass subclasses isEmpty not])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:39'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector		methodBlock: [ :context :result | 			(context parseTree isPrimitive not and: [ matcher executeMethod: context parseTree initialAnswer: false ])				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BlockLintRule class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector		name: 'Instance variables not read AND written';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| isRead isWritten |					isRead := false.					isWritten := false.					allSubclasses detect: 							[:class | 							isRead ifFalse: [isRead := (class whichSelectorsRead: each) isEmpty not].							isWritten 								ifFalse: [isWritten := (class whichSelectorsAssign: each) isEmpty not].							isRead & isWritten]						ifNone: [result addClass: context selectedClass instanceVariable: each]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector		name: 'Variables not referenced';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses 						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addClass: context selectedClass instanceVariable: each]].			context selectedClass isMeta 				ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each) 								ifFalse: [result addClass: context selectedClass classVariable: each key]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester isVariable: each writtenBeforeReadIn: tree) 											ifTrue: 												[result addClass: defClass selector: selector.												result addSearchString: each]]]]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:05'!methodHasNoTimeStamp	| detector |	detector := self new.	detector name: 'Method has no timeStamp'.	detector rationale: 'For proper versioning, every method should have a timestamp.'.	detector methodBlock: 			[:context :result | 			context compiledMethod timeStamp isEmpty					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:19'!methodSourceContainsLinefeeds	| detector |	detector := self new.	detector name: 'Method source contains linefeeds'.	detector rationale: 'Squeak code should not contain linefeed characters.'.	detector methodBlock: 			[:context :result | 			(context sourceCode includes: Character lf)					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'jws 10/23/2016 05:39'!superSendsNew	| detector matcher |	detector := self new.	detector name: 'Sends super new initialize'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			#('super new initialize' '(super new: `@expr) initialize' 'self new initialize' '(self new: `@expr) initialize')		do: [ :aNode :answer | answer + 1 ].	detector		methodBlock: [ :context :result | 			context selectedClass isMeta				ifTrue: [ 					(matcher executeTree: context parseTree initialAnswer: 0) > 0						ifTrue: [ result addClass: context selectedClass selector: context selector ] ] ].	^ detector! !!BlockLintRule class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector		name: 'Method defined in all subclasses, but not in superclass';		resultClass: MultiEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMeta not 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size 								and: [(context selectedClass canUnderstand: each) not]) 									ifTrue: 										[| envName |										envName := context selectedClass name , '>>' , each.										subs do: 												[:subClass | 												result 													addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMeta				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'Subclass responsibility not defined'.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!undeclaredReference	| detector |	detector := self new.	detector name: 'References an undeclared variable'.	detector methodBlock: 			[:context :result | 			| undeclared |			undeclared := Undeclared associations detect: 							[:each | 							(context uses: each)								and: [context compiledMethod refersToLiteral: each]]						ifNone: [nil].			undeclared notNil ifTrue: 					[result addSearchString: undeclared key.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method refersToLiteral: trueBinding)				or: [method refersToLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BlockLintRule class methodsFor: 'bugs' stamp: 'bh 5/1/2000 16:56'!variableNotDefined	| detector |	detector := self new.	detector name: 'Variable used, but not defined anywhere'.self needsWork."	detector methodBlock: [:context :result | context compiledMethod withAllBlockMethodsDo: [:each | each				literalsDo: [:lit | lit isVariableBinding						ifTrue: [((Smalltalk associationAt: lit key ifAbsent: [])								== lit or: [(Undeclared associationAt: lit key ifAbsent: [])									== lit])								ifFalse: [(context selectedClass fullBindingFor: lit key)										== lit										ifFalse: 											[result addClass: context selectedClass selector: context selector.											result addSearchString: lit key]]]]]]."	^ detector	! !!CompositeLintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^rules gather: [ :r  | r changes ]! !!CompositeLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRule methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRule methodsFor: 'accessing'!rules	^rules! !!CompositeLintRule methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRule methodsFor: 'testing'!isComposite	^true! !!CompositeLintRule methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRule methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRule methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	rules do: [:each | each viewResults]! !!CompositeLintRule class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRule class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	| allRules |	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: aProtocol asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy)				at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRule class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRule protocols				collect: [:each | self ruleFor: BasicLintRule protocol: each])		name: 'Lint checks'! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:54'!performAllTransformationsOn: anEnvironment	| transformations rc |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].	rc := RefactoryChangeManager instance.	RefactoryChangeManager undoSize: (RefactoryChangeManager undoSize max: transformations changes size).	transformations changes do: [ :c | rc performChange: c ].	^self inform: ('{1} transformations performed' format: transformations problemCount)! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:52'!previewAllTransformationsOn: anEnvironment	"	CompositeLintRule previewAllTransformationsOn: (BrowserEnvironment new forClasses: {RefactoryTestDataApp})	"	| transformations changes |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].self halt.	changes := String streamContents: 					[:stream | 					stream						header;						timeStamp;						nextPutAll: '"Result of running all transformations"!!'.					transformations changes do: [ :ch | stream cr; print: ch  ]].	FileContentsBrowser browseStream: changes readStream		named: 'Prospective replacements'! !!CompositeLintRule class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRule protocol: 'transformations'! !!LintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ('.	self problemCount printOn: nameStream.	nameStream nextPut: $).	^nameStream contents! !!LintRuleTest methodsFor: 'accessing'!name	^name! !!LintRuleTest methodsFor: 'accessing'!name: aString 	name := aString! !!LintRuleTest methodsFor: 'accessing' stamp: 'bh 3/25/2000 02:00'!openEditor	| rules |	rules := self failedRules.	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name! !!LintRuleTest methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRuleTest methodsFor: 'accessing'!run	^Object printOn: self! !!LintRuleTest methodsFor: 'accessing'!runOnEnvironment: anEnvironment 	^Object printOn: self onEnvironment: anEnvironment! !!LintRuleTest methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRuleTest methodsFor: 'private'!viewResults	self subclassResponsibility! !!LintRuleTest methodsFor: 'testing'!hasConflicts	^false! !!LintRuleTest methodsFor: 'testing'!isComposite	^false! !!LintRuleTest methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRuleTest methodsFor: 'testing' stamp: 'bh 4/3/2000 22:39'!junk	^RefactoryTestDataApp printString copyFrom: 1 to: CR! !!LintRuleTest methodsFor: 'initialize-release'!initialize	name := ''! !!LintRuleTest methodsFor: 'initialize-release'!resetResult! !!LintRuleTest methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!BasicLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'accessing' stamp: 'bh 4/3/2000 10:19'!foobar	^#( true false )! !!BasicLintRuleTest methodsFor: 'accessing'!problemCount	^result problemCount! !!BasicLintRuleTest methodsFor: 'accessing'!result	^result! !!BasicLintRuleTest methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock testMethod1! !!BasicLintRuleTest methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ].	self resultClass: SelectorEnvironment! !!BasicLintRuleTest methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!BasicLintRuleTest methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRuleTest methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRuleTest methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRuleTest methodsFor: 'testing'!isEmpty	^result isEmpty! !!BasicLintRuleTest methodsFor: 'private'!viewResults	result openEditor! !!BasicLintRuleTest class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:38'!missingYourself	| detector matcher |	detector := self new.	detector name: 'Possible missing "; yourself"'.	matcher := ParseTreeSearcher new.	matcher		addSearch:			'``@xobject `@messages: ``@args'				-> [ :aNode :answer | answer or: [ aNode parent isCascade and: [ aNode isDirectlyUsed and: [ aNode selector ~~ #yourself ] ] ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'nk 2/24/2005 13:31'!modifiesCollection	| detector addSearcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	addSearcher := ParseTreeLintRule modifiesCollection.	detector methodBlock: 			[:context :result | 			addSearcher executeTree: context parseTree initialAnswer: false.			addSearcher answer 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:38'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher		addSearch:			'^``@xObject'				-> [ :aNode :answer | 					answer						add: aNode value;						yourself ].	detector		methodBlock: [ :context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new)				do: [ :each | 					hasBool := hasBool						or: [ 							(each isLiteral								and: [ 									{true.									false} includes: each value ]) or: [ each isMessage and: [ #(#and: #or:) includes: each selector ] ] ].					hasSelf := hasSelf						or: [ 							(each isVariable and: [ each name = 'self' ])								or: [ 									each isLiteral										and: [ 											({true.											false} includes: each value) not ] ] ] ].			hasSelf & hasBool				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sentNotImplementedInApplication	| detector |	detector := self new.	detector name: 'Messages sent but not implemented in application'.	detector methodBlock: 			[:context :result | 			| message class block |			message := context messages						detect: [:each | (context isItem: each in: context application) not]						ifNone: [nil].			class := context selectedClass.			block := 					[:each | 					| app |					app := context application.					(self canCall: each						in: class						from: app) not].			message isNil ifTrue: [message := context selfMessages detect: block ifNone: [nil]].			message isNil ifTrue: 					[class := class superclass.					class isNil						ifTrue: 							[context superMessages isEmpty ifFalse: [message := context superMessages asArray first]]						ifFalse: [message := context superMessages detect: block ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!superSends	| detector |	detector := self new.	detector name: 'Missing super sends'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass not				and: [self superMessages includes: context selector]) ifTrue: 						[(context selectedClass superclass notNil							and: [context selectedClass superclass canUnderstand: context selector])								ifTrue: 									[(context superMessages includes: context selector)										ifFalse: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := ParseTreeSearcher new		addArgumentSearch:				'`xxxvar'						-> [ :aNode :answer | 							answer								or: [ 									varName := aNode name.									vars includes: varName ] ];		yourself.	detector		methodBlock: [ :context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ 					result addClass: context selectedClass selector: context selector.					result addSearchString: varName ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector		methodBlock: [ :context :result | 			| variables |			variables := ParseTreeSearcher nonBlockTempsIn: context parseTree.			variables isEmpty				ifFalse: [ 					(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree)						do: [ :each | 							result addClass: context selectedClass selector: context selector.							result addSearchString: each ] ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := ParseTreeSearcher new		addSearch:				'``@x @ ``@y'						-> [ :aNode :answer | 							answer								or: [ 									| current |									current := aNode parent.									[ current isNil or: [ current isMessage and: [ current selector == #@ or: [ current selector isInfix not ] ] ] ]										whileFalse: [ current := current parent ].									(current isNil or: [ current isMessage and: [ current selector isInfix not ] ]) not ] ];		yourself.	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:38'!usesAdd	| detector addSearcher |	detector := self new.	detector name: 'Uses the result of an add: message'.	addSearcher := ParseTreeSearcher usesResultOfAdd.	detector		methodBlock: [ :context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass and: 					[(context selector						indexOfSubCollection: context selectedClass primaryInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'bh 4/8/2000 19:05'!fullBlocks"skip this test in squeak.""	| detector |	detector := self new.	detector name: 'Method with full blocks'.	detector methodBlock: 			[:context :result | 			context compiledMethod withAllBlockMethodsDo: 					[:method | 					method needsHybridFrame						ifTrue: [result addClass: context selectedClass selector: context selector]]].	^detector"! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!ifTrueBlocks	| detector matcher |	detector := self new.	detector name: 'Non-blocks in ifTrue:/ifFalse: messages'.	matcher := ParseTreeSearcher new.	matcher		addSearches:			#('``@condition ifTrue: ``@block' '``@condition ifFalse: ``@block' '``@condition ifTrue: ``@block1 ifFalse: ``@block2' '``@condition ifFalse: ``@block1 ifTrue: ``@block2')				-> [ :aNode :answer | answer or: [ (aNode arguments detect: [ :each | each isBlock not ] ifNone: [ nil ]) notNil ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector name: 'Instance variables defined in all subclasses'.	detector result: nil pullUpInstVar.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							(sels occurrencesOf: val) == subs size								ifTrue: [result addInstVar: val for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher		addSearch:			'`.Stmt'				-> [ :aNode :answer | (aNode children inject: answer into: [ :sum :each | matcher executeTree: each initialAnswer: sum ]) + 1 ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: 0) >= self longMethodSize				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:38'!precedence	| detector matcher |	detector := self new.	detector name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'.	matcher := ParseTreeSearcher new.	matcher		addSearches:			#('``@A + ``@B * ``@C' '``@A - ``@B * ``@C') -> [ :aNode :answer | answer or: [ aNode receiver parentheses isEmpty ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMetaclass						ifTrue: [context selectedClass primaryInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels isEmpty ifFalse: 					[result addSearchString: className.					sels do: [:each | result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher addSearch: '`@receiver , `@argument' -> [ :aNode :answer | true ].	matcher		addSearches:			#('``@collection do: [:`each | | `@temps | ``@.Statements]' '``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' '``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' '``@collection select: [:`each | | `@temps | ``@.Statements]' '``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')				-> [ :aNode :answer | 					answer						or: [ 							(aNode arguments								detect: [ :each | each isBlock and: [ concatenationMatcher executeTree: each initialAnswer: false ] ]								ifNone: [ nil ]) notNil ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:38'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	detector		methodBlock: [ :context :result | 			(context selectedClass isMetaclass | (context selector numArgs == 0)				or: [ 					(context protocols						detect: [ :each | (self utilityProtocols detect: [ :protocol | protocol match: each ] ifNone: [ nil ]) notNil ]						ifNone: [ nil ]) notNil ])				ifFalse: [ 					(self subclassOf: context selectedClass overrides: context selector)						ifFalse: [ 							(context superMessages isEmpty and: [ context selfMessages isEmpty ])								ifTrue: [ 									(ParseTreeSearcher										references: context selectedClass allInstVarNames , context selectedClass allClassVarNames asArray , #('self')										in: context parseTree) isEmpty										ifTrue: [ result addClass: context selectedClass selector: context selector ] ] ] ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:38'!variableAssignedLiteral	| detector |	detector := self new.	detector name: 'Variable is only assigned a single literal value'.	detector result: nil references.	detector		classBlock: [ :context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames				do: [ :each | 					| defClass selector |					(allSubclasses						inject: 0						into: [ :sum :class | 							| sels |							sels := class whichSelectorsWrite: each.							sels size == 1								ifTrue: [ 									selector := sels asArray first.									defClass := class ].							sum + sels size ]) == 1						ifTrue: [ 							| tree searcher |							searcher := ParseTreeSearcher new.							searcher addSearch: (each , ' := ``@object') -> [ :aNode :answer | answer isNil and: [ aNode value isLiteral ] ].							tree := defClass parseTreeFor: selector.							tree notNil								ifTrue: [ 									(searcher executeTree: tree initialAnswer: nil) == true										ifTrue: [ result addInstVar: each for: context selectedClass ] ] ] ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!yourselfNotUsed	| detector addSearcher |	detector := self new.	detector name: 'Doesn''t use the result of a yourself message'.	addSearcher := ParseTreeSearcher new.	addSearcher addSearch: '`@object yourself' -> [ :aNode :answer | answer or: [ aNode isUsed not ] ].	detector		methodBlock: [ :context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher		addSearches:			(#(#add: #remove: #addAll: #removeAll:)				collect: [ :each | ('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) asString ])				-> [ :aNode :answer | 					answer						or: [ 							(aNode receiver selector copyFrom: 1 to: (aNode receiver selector size min: 2)) ~= 'as'								and: [ 									| receiver |									receiver := aNode receiver receiver.									receiver isVariable not										or: [ ((#('self' 'super') includes: receiver name) or: [ Smalltalk includesKey: receiver name asSymbol ]) not ] ] ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil') 		name: 'Uses "size = 0" or "= nil" instead of "isEmpty" or "isNil"'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!guardingClause	^self		createParseTreeRule: 				#('`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 				'`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		method: true		name: 'Guarding clauses'! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher		addSearches:			#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' '| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2')				-> [ :aNode :answer | 					answer						or: [ 							| node |							node := (aNode statements at: aNode statements size - 1) arguments first body statements last value.	"``@value1"							(node isLiteral								and: [ 									{true.									false} includes: node value ])								or: [ 									node := aNode statements last value.									node isLiteral										and: [ 											{true.											false} includes: node value ] ] ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher		addSearches:			#('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]')				-> [ :aNode :answer | 					answer						or: [ 							(#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aNode selector)								and: [ #(#< #<= #> #>=) includes: aNode receiver selector ] ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector name: 'Method defined in all subclasses, but not in superclass'.	detector resultClass: MultiEnvironment.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMetaclass not ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size								and: [(context selectedClass canUnderstand: each) not]) ifTrue: 										[| envName |										envName := context selectedClass name , '>>', each.										subs do: 												[:subClass | 												result addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher		addSearch:			'1 to: ``@object size do: [:`each | | `@temps | `@.Statements]'				-> [ :aNode :answer | 					answer						or: [ 							| varName variableMatcher |							varName := aNode arguments last arguments first name.	"`each"							variableMatcher := ParseTreeSearcher new.							variableMatcher								addSearch: varName -> [ :node :ans | ans and: [ node parent isMessage and: [ node parent selector == #at: ] ] ].							variableMatcher executeTree: aNode arguments last body initialAnswer: true ] ].	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!BasicLintRuleTest class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BasicLintRuleTest class methodsFor: 'private'!canCall: aSelector in: aClass from: anApplication 	| methodApp root |	(aClass canUnderstand: aSelector) ifFalse: [^false].	root := anApplication rootApplication.	methodApp := ((aClass whichClassIncludesSelector: aSelector) compiledMethodAt: aSelector)				application rootApplication.	^methodApp == root or: [root isBasedOn: methodApp]! !!BasicLintRuleTest class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BasicLintRuleTest class methodsFor: 'private' stamp: 'jws 10/23/2016 05:39'!createMatcherFor: codeStrings method: aBoolean	| matcher |	matcher := ParseTreeSearcher new.	aBoolean		ifTrue: [ matcher addMethodSearches: codeStrings -> [ :aNode :answer | true ] ]		ifFalse: [ matcher addSearches: codeStrings -> [ :aNode :answer | true ] ].	^ matcher! !!BasicLintRuleTest class methodsFor: 'private'!longMethodSize	^10! !!BasicLintRuleTest class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BasicLintRuleTest class methodsFor: 'private' stamp: 'nk 2/23/2005 16:09'!new	^super new! !!BasicLintRuleTest class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	| subs |	subs := aClass subclasses.	1 to: subs size		do: 			[:i | 			| each |			each := subs at: i.			(each includesSelector: aSelector) ifTrue: [^true].			(self subclassOf: each overrides: aSelector) ifTrue: [^true]].	^false! !!BasicLintRuleTest class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BasicLintRuleTest class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BasicLintRuleTest class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!BasicLintRuleTest class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMetaclass				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector name: 'Subclass responsibility not defined'.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method referencesLiteral: trueBinding)				or: [method referencesLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMetaclass				or: [context isApplication				or: [context selectedClass subclasses isEmpty not]])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:38'!endTrueFalse	| detector matcher |	detector := self new.	detector name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := ParseTreeSearcher new		addSearches:				#('`@object 						ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 						ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 						ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 						ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' '`@object 						ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 						ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 						ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 						ifTrue: [| `@temps2 | `.Statement. `@.Statement2]')						-> [ :aNode :answer | 							answer								or: [ 									| node |									node := aNode arguments first body statements last.									(node isVariable and: [ node = aNode arguments last body statements last ]) not ] ];		yourself.	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:39'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := ParseTreeSearcher new		addSearches:				#('true' 'false')						-> [ :aNode :answer | answer or: [ aNode parent isMessage and: [ #(#= #== #~= #~~) includes: aNode parent selector ] ] ];		yourself.	detector		methodBlock: [ :context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!extraBlock	^self		createParseTreeRule: (#('value' 'value: `@value' 'value: `@value1 value: `@value2' 'value: `@value1 value: `value2 value: `@value3' 'valueWithArguments: `@values')				collect: [:each | '[:`@params | | `@temps | `@.statements] ' , each])		name: 'Block immediately evaluated'! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:39'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector		methodBlock: [ :context :result | 			(context parseTree tag isNil and: [ matcher executeMethod: context parseTree initialAnswer: false ])				ifTrue: [ result addClass: context selectedClass selector: context selector ] ].	^ detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector name: 'Instance variables not read AND written'.	detector result: nil references.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| reads writes |					reads := false.					writes := false.					allSubclasses detect: 							[:class | 							reads ifFalse: [reads := (class whichSelectorsRead: each) isEmpty not].							writes ifFalse: [writes := (class whichSelectorsWrite: each) isEmpty not].							reads & writes]						ifNone: [result addInstVar: each for: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector name: 'Variables not referenced'.	detector result: nil unreferenced.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addInstVar: each for: context selectedClass]].			context selectedClass isMetaclass ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each)								ifFalse: [result addClassVar: each key for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester readBeforeWritten: (Array with: each) in: tree) 											isEmpty 												ifTrue: 													[result addClass: defClass selector: selector.													result addSearchString: each]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	| detector matcher |	detector := self new.	detector name: aName.	matcher := self createMatcherFor: codeStrings method: aBoolean.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self createParseTreeRule: codeStrings		method: false		name: aName! !!BasicLintRuleTest class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!CompositeLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRuleTest methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRuleTest methodsFor: 'accessing'!rules	^rules! !!CompositeLintRuleTest methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRuleTest methodsFor: 'testing'!isComposite	^true! !!CompositeLintRuleTest methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRuleTest methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRuleTest methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRuleTest methodsFor: 'private'!viewResults	rules do: [:each | each viewResults]! !!CompositeLintRuleTest class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRuleTest class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	^self		rules: (((BrowserEnvironment new selectorsFor: aProtocol asSymbol in: aClass class)				collect: [:selector | aClass perform: selector])					asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy) at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRuleTest class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRuleTest protocols				collect: [:each | self ruleFor: BasicLintRuleTest protocol: each])		name: 'Lint checks'! !!CompositeLintRuleTest class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRuleTest protocol: 'transformations'! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:44'!accepted	^accepted! !!MethodNameEditor methodsFor: 'accessing' stamp: 'vd 5/19/2004 18:08'!accepted: anObject	bodyPane accept.		accepted := anObject! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:34'!arguments	^methodName arguments! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:46'!methodPreview	| stream |	stream := String new writeStream.	self selector numArgs > 0 		ifTrue: 			[self selector keywords with: self argumentList				do: 					[:keyword :arg | 					stream						nextPutAll: keyword;						nextPut: $ ;						nextPutAll: arg;						nextPut: $ ]]		ifFalse: [stream nextPutAll: self selector].	^stream contents! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/29/2001 14:52'!modalView	^modalView! !!MethodNameEditor methodsFor: 'accessing' stamp: 'mga 8/27/2001 15:20'!modalView: aSystemWindow	modalView := aSystemWindow	! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:36'!selector	^methodName selector! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 14:14'!selector: aString 	methodName selector: aString asString.	self changed: #selector.	self changed: #methodPreview.	^true.! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:51'!addArgumentListTo: window 	| anArgumentListMorph |	(anArgumentListMorph := PluggableListMorph new) 		on: self		list: #argumentList		selected: #argumentListIndex		changeSelected: #argumentListIndex:		menu: nil		keystroke: nil.	window addMorph: anArgumentListMorph frame: (0 @ 0.1 corner: 0.9 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!addCancelButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #cancel)				label: 'cancel';				onColor: Color white offColor: Color white)		frame: (0.5 @ 0.8 corner: 1 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addDownButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #downActivated				action: #down)				label: 'down';				setBalloonText: 'move argument down';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.4 corner: 1 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addOkButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #okEnabled				action: #ok)				label: 'ok';				setBalloonText: 'accept selector as shown in the preview';				onColor: Color white offColor: Color lightGray)		frame: (0 @ 0.8 corner: 0.5 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addPreviewPaneTo: window 	| methodPreview |	methodPreview := PluggableTextMorph 				on: self				text: #methodPreview				accept: nil				readSelection: nil				menu: nil.	window addMorph: methodPreview frame: (0 @ 0.7 corner: 1.0 @ 0.8)! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!addSelectorPaneTo: window 		bodyPane := PluggableTextMorph 				on: self				text: #selector				accept: #selector:				readSelection: nil				menu: nil.	bodyPane acceptOnCR: true.	window addMorph: bodyPane frame: (0 @ 0 corner: 1.0 @ 0.1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addUpButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #upActivated				action: #up)				label: 'up';				setBalloonText: 'move argument up';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.1 corner: 1 @ 0.4)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:44'!cancel	self modalView delete.! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!ok	self okEnabled 		ifFalse: 			[self modalView flash.			^self].	self accepted: true.	self modalView delete! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:04'!okEnabled	^self selector isEmpty not and: [self methodName isValid]! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!openAsMorph	"self new openAsMorph"	| window |	window := (SystemWindow labelled: 'Selector editor') model: self.	self addSelectorPaneTo: window.	self addArgumentListTo: window.	self addUpButtonTo: window.	self addDownButtonTo: window.	self addPreviewPaneTo: window.	self addOkButtonTo: window.	self addCancelButtonTo: window.	window		center: Display center;		extent: 100 @ 100.	self selectionChanged.	window openInWorld.	window setProperty: #methodNameEditorModel toValue: self.	^window! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:40'!argumentList	^ methodName arguments! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:35'!argumentList: aCollection	methodName argumentList: aCollection! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 00:57'!argumentListIndex	^argumentListIndex! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 13:21'!argumentListIndex: anInteger	argumentListIndex := anInteger.	self selectionChanged.! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:02'!down	self downActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex + 1.	self argumentListIndex: self argumentListIndex + 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:32'!for: aMethodName 	self methodName: aMethodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:41'!initialize	argumentListIndex := 1.	accepted := false! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName	^methodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName: aSelector	methodName := aSelector! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 11:08'!selectionChanged	self 		changed: #argumentListIndex;		changed: #argumentList;		changed: #upActivated;		changed: #downActivated;		changed: #methodPreview	! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:00'!up	self upActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex - 1.	self argumentListIndex: self argumentListIndex - 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:10'!downActivated	| newIndex |	newIndex := argumentListIndex + 1.	^newIndex between: 1 and: self arguments size! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:09'!upActivated	| newIndex |	newIndex := argumentListIndex - 1.	^newIndex between: 1 and: self arguments size! !!MethodNameEditor class methodsFor: 'examples' stamp: 'mga 8/27/2001 01:36'!example	self new		argumentList: #('1' '2');		argumentListIndex: 1;		openAsMorph! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'dvf 9/1/2001 18:51'!for: aMethodName 	| editor newMethodName |	newMethodName := aMethodName deepCopy.	newMethodName arguments 		ifNil: [newMethodName arguments: OrderedCollection new].	newMethodName selector		ifNil: [newMethodName selector: String new].	editor := self new.	editor for: newMethodName.	^editor! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'mga 8/27/2001 17:23'!forMethodName: aMethodName	^self modalEditorForMethodName: aMethodName ! !!MethodNameEditor class methodsFor: '-- all --' stamp: 'dvf 9/1/2001 20:43'!modalEditorForMethodName: aMethodName 	| editor window |	editor := self for: aMethodName.	window := editor openAsMorph.	editor modalView: window.	[window world notNil] 		whileTrue: [window outermostWorldMorph doOneCycleNow].	^editor accepted ifFalse: [nil] ifTrue: [(window valueOfProperty: #methodNameEditorModel) methodName]! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass		selector: aSymbol! !!MultiEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:04'!asSelectorEnvironment	| s |	s := SelectorEnvironment new.	s label: self label.	environmentDictionaries do: [:each | | env |			env := each asSelectorEnvironment. 			env classesDo: [:cls | env selectorsForClass: cls do:  [:sel | s addClass: cls selector: sel]]].	^ s	  ! !!MultiEnvironment methodsFor: 'accessing'!environments	^environmentDictionaries keys! !!MultiEnvironment methodsFor: 'accessing'!problemCount	^environmentDictionaries size! !!MultiEnvironment methodsFor: 'accessing'!selectEnvironment: aValue 	environment := environmentDictionaries at: aValue				ifAbsent: [SelectorEnvironment new]! !!MultiEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	environmentDictionaries := Dictionary new.	environment := SelectorEnvironment new! !!MultiEnvironment methodsFor: 'testing'!isEmpty	^environmentDictionaries isEmpty! !!MultiEnvironment methodsFor: 'GUI' stamp: 'lr 12/13/2005 15:00'!openEditor	self explore.! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsent: [SelectorEnvironment new]) 		removeClass: aClass! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		removeClass: aClass		selector: aSelector! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/18/2000 18:34'!anySelected	^selection includes:true.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:31'!selectAll	1 to: list size do:[:each | selection at: each put: true].	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:30'!selectNone	selection := Dictionary new.	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'nk 3/1/2005 09:21'!selectedItem	primary isZero ifTrue: [ ^nil ].	^list at: primary.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/19/2000 11:43'!selectedItems	| index |	index := 0.	^list select:		[:each | index := index + 1.		 self listSelectionAt: index]! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'ls 11/8/2003 16:20'!selectionsChanged	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 17:03'!list	^list collect:[:each| each asString]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:12'!listSelectionAt: anIndex	^selection at: anIndex ifAbsent:[^false]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'ls 11/8/2003 16:20'!listSelectionAt: anIndex put: aValue 	selection at: anIndex put: aValue.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection	^primary! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection: aNumber	primary := aNumber! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:57'!trueIndexes	| indexList |	indexList := Set new.	selection keysAndValuesDo:[:eachKey :eachValue | eachValue ifTrue: [indexList add: eachKey]].	^indexList! !!MultipleSelectionModel methodsFor: 'user interface' stamp: 'nk 3/1/2005 09:13'!listMorph	| m |	m := PluggableListMorphOfMany				on: self				list: #list				primarySelection: #primarySelection				changePrimarySelection: #primarySelection:				listSelection: #listSelectionAt:				changeListSelection: #listSelectionAt:put:				menu: #menu:.	m color: Color transparent; borderWidth: 0.	^ m! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menu: aMenu 	aMenu		add: 'Select All' action: #selectAll;		add: 'Select None' action: #selectNone.	getMenu ifNotNil: 			[model perform: getMenu				withArguments: { 						aMenu.						self}].	^aMenu! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menuGetter: aSelector	getMenu := aSelector! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:06'!perform: selector orSendTo: otherTarget	^(self respondsTo: selector)		ifTrue: [ self perform: selector]		ifFalse: [ otherTarget perform: selector]! !!MultipleSelectionModel methodsFor: 'initialization' stamp: 'nk 3/1/2005 09:14'!model: aModel list: aList message: aSelector selection: anArray 	model := aModel.	list := aList.	getList := aSelector.	selection := anArray.	primary := 0! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 14:15'!refreshList	| newList oldSelection newSelection index |	newSelection := Dictionary new.	(model notNil and: [getList notNil]) 		ifTrue: 			[newList := model perform: getList.			oldSelection := self selectedItems collect: [:each | each asString].			index := 0.			(newList collect: [:each | each asString]) do: 					[:each | 					index := index + 1.					(oldSelection includes: each) ifTrue: [newSelection at: index put: true]].			list := newList.			self changed: #list].	selection := newSelection.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 15:31'!update: aSelector 	self refreshList! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:03'!withModel: aModel withList: aList	^self withModel: aModel withList: aList withMessage: nil! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:02'!withModel: aModel  withList: aList  withMessage: aSelector 	^super new 		model: aModel		list: aList		message: aSelector		selection: Dictionary new! !!NotEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesClass: aClass 	(environment includesClass: aClass) ifFalse: [^true].	aClass selectorsAndMethodsDo: 			[:each :meth | 			(environment includesSelector: each in: aClass) ifFalse: [^true]].	^false! !!NotEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) not! !!NotEnvironment methodsFor: 'environments'!not	^environment! !!NotEnvironment methodsFor: 'printing'!storeOn: aStream	environment storeOn: aStream.	aStream nextPutAll: ' not'! !!NumberParser methodsFor: 'accessing' stamp: 'YuriyTymchuk 10/29/2013 11:08'!allowPlusSign	"return a boolean indicating if plus sign is allowed or not"	^false! !!NumberParser methodsFor: 'accessing' stamp: 'nice 2/12/2010 23:56'!allowPlusSignInExponent	"return a boolean indicating if plus sign is allowed or not in exponent"	^self allowPlusSign! !!NumberParser methodsFor: 'accessing' stamp: 'YuriyTymchuk 10/29/2013 11:08'!exponentLetters	"answer the list of possible exponents for Numbers.	Note: this parser will not honour precision attached to the exponent.	different exponent do not lead to different precisions.	only IEEE 754 floating point numbers will be created"		^'edq'! !!NumberParser methodsFor: 'accessing' stamp: 'nice 5/1/2006 01:58'!failBlock: aBlockOrNil	failBlock := aBlockOrNil! !!NumberParser methodsFor: 'accessing' stamp: 'nice 5/1/2006 01:59'!requestor: anObjectOrNil	requestor := anObjectOrNil! !!NumberParser methodsFor: 'error' stamp: 'nice 2/25/2010 02:39'!expected: aString 	| errorString |	errorString := aString , ' expected'.	requestor isNil		ifFalse: [requestor				notify: errorString				at: sourceStream position + 1				in: sourceStream].	failBlock ifNotNil: [^failBlock cull: errorString cull: sourceStream position + 1].	self error: 'Reading a number failed: ' , errorString! !!NumberParser methodsFor: 'error' stamp: 'NikoSchwarz 10/17/2009 10:45'!fail	failBlock ifNotNil: [^failBlock value].	self error: 'Reading a number failed'! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:22'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	^(k positive		ifTrue: [m * (aRadix raisedToInteger: k)]		ifFalse: [Fraction numerator: m denominator: (aRadix raisedToInteger: k negated)]) asFloat! !!NumberParser methodsFor: 'parsing-private' stamp: 'NicolaiHess 3/24/2015 08:47'!makeIntegerOrScaledInteger	"at this point, there is no digit, nor fractionPart.	maybe it can be a scaled decimal with fraction omitted..."	self flag:'to be removed in favor of makeIntegerOrScaledIntegerOrFloat'.	neg		ifTrue: [integerPart := integerPart negated].	self readExponent		ifTrue: [^integerPart * (base raisedToInteger: exponent)].	(self readScaleWithDefaultNumberOfDigits: 0)		ifTrue: [^integerPart asScaledDecimal: scale].	^ integerPart! !!NumberParser methodsFor: 'parsing-private' stamp: 'NicolaiHess 3/24/2015 08:43'!makeIntegerOrScaledIntegerOrFloat	"at this point, there is no digit, nor fractionPart.	maybe it can be a scaled decimal with fraction omitted...	integer with negative exponent can be floats not fractions"		neg		ifTrue: [integerPart := integerPart negated].	self readExponent ifTrue:		["Check that the result is an integer, otherwise answer a Float.  Fractions are /not/ valid literals."		 (exponent >= 0 or: [(integerPart * (base raisedToInteger: exponent)) isInteger]) ifFalse:			[base := base asFloat].		^integerPart * (base raisedToInteger: exponent)].	(self readScaleWithDefaultNumberOfDigits: 0)		ifTrue: [^integerPart asScaledDecimal: scale].	^ integerPart! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 10/7/2009 01:40'!makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart	"at this point integerPart fractionPart and scale have been read out (in inst var).	Form a ScaledDecimal.	Care of eliminating trailing zeroes from the fractionPart"		| decimalMultiplier decimalFraction |	decimalMultiplier := base raisedToInteger: numberOfNonZeroFractionDigits.	decimalFraction := integerPart * decimalMultiplier + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)) / decimalMultiplier.	neg		ifTrue: [decimalFraction := decimalFraction negated].	^decimalFraction asScaledDecimal: scale! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 2/12/2010 23:57'!peekSignIsMinus	"Peek an optional sign from sourceStream.	Answer true if it is minus sign"	| isMinus |	isMinus := sourceStream peekFor: $-.	isMinus ifFalse: [self allowPlusSign ifTrue: [sourceStream peekFor: $+]].	^isMinus! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 16:03'!readExponent	"read the exponent if any (stored in instVar).	Answer true if found, answer false if none.	If exponent letter is not followed by a digit,	this is not considered as an error.	Exponent are always read in base 10."		| eneg epos |	exponent := 0.	sourceStream atEnd ifTrue: [^ false].	(self exponentLetters includes: sourceStream peek)		ifFalse: [^ false].	sourceStream next.	eneg := sourceStream peekFor: $-.	epos := eneg not and: [self allowPlusSignInExponent and: [sourceStream peekFor: $+]].	exponent := self nextUnsignedIntegerOrNilBase: 10.	exponent ifNil: ["Oops, there was no digit after the exponent letter.Ungobble the letter"		exponent := 0.		sourceStream						skip: ((eneg or: [epos])								ifTrue: [-2]								ifFalse: [-1]).					^ false].	eneg		ifTrue: [exponent := exponent negated].	^ true! !!NumberParser methodsFor: 'parsing-private' stamp: 'YuriyTymchuk 10/29/2013 11:08'!readNamedFloatOrFail	"This method is used when there is no digit encountered:	It try and read a named Float NaN or Infinity.	Negative sign for -Infinity has been read before sending this method, and is indicated in the neg inst.var.	Fail if no named Float is found"			neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].	(sourceStream nextMatchAll: 'Infinity')		ifTrue: [^ neg			ifTrue: [Float infinity negated]			ifFalse: [Float infinity]].	^self expected: 'a digit between 0 and ' , (String with: (Character digitValue: base - 1))! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 3/15/2014 15:45'!readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart	"at this stage, sign integerPart and a decimal point have been read.	try and form a number with a fractionPart"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |	fractionPart := self nextUnsignedIntegerOrNilBase: base.	fractionPart ifNil: ["No fractionPart found,ungobble the decimal point and return the integerPart"					sourceStream skip: -1.					^ neg						ifTrue: [integerPart negated]						ifFalse: [integerPart]].	numberOfNonZeroFractionDigits := lastNonZero.	numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.	self readExponent		ifFalse: [(self readScaleWithDefaultNumberOfDigits: nDigits)				ifTrue: [^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits					andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart]].	fractionPart isZero		ifTrue: [mantissa := integerPart						// (base raisedToInteger: numberOfTrailingZeroInIntegerPart).			exponent := exponent + numberOfTrailingZeroInIntegerPart]		ifFalse: [mantissa := integerPart						* (base raisedToInteger: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).			exponent := exponent - numberOfNonZeroFractionDigits].	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.	^ neg		ifTrue: [value isZero				ifTrue: [Float negativeZero]				ifFalse: [value negated]]		ifFalse: [value]! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 3/15/2014 15:43'!readScaleWithDefaultNumberOfDigits: anInteger	"Read the scale if any and store it into scale instance Variable.	Answer true if found, answer false if none.	The scale is specified by letter s, optionnally followed by a positive integer in base 10.	If no integer is specified, that means using as many digits as provided after the fraction separator, as provided by parameter anInteger.	A letter s followed by another letter is not considered as a scale specification, because it could be part of a message."	scale := 0.	sourceStream atEnd		ifTrue: [ ^ false ].	(sourceStream peekFor: $s)		ifFalse: [ ^ false ].	scale := self nextUnsignedIntegerOrNilBase: 10.	scale		ifNil: [ 			scale := anInteger.			(sourceStream peek ifNil: [ false ] ifNotNil: [ :nextChar | nextChar isLetter ])				ifTrue: [ 					sourceStream skip: -1.	"ungobble the s"					^ false ]				ifFalse: [ ^ true ] ].	^ true! !!NumberParser methodsFor: 'parsing-large int' stamp: 'nice 3/15/2010 00:14'!nextElementaryLargeIntegerBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading if end of digits or if a LargeInteger is formed.	Count the number of digits and the position of lastNonZero digit and store them in instVar."	| value digit char |	value := 0.	nDigits := 0.	lastNonZero := 0.	[value isLarge or: [(char := sourceStream next) == nil		or: [digit := char digitValue.			(0 > digit or: [digit >= aRadix])				and: [sourceStream skip: -1.					true]]]]		whileFalse: [			nDigits := nDigits + 1.			0 = digit				ifFalse: [lastNonZero := nDigits].			value := value * aRadix + digit].	^value! !!NumberParser methodsFor: 'parsing-large int' stamp: 'nice 1/14/2014 03:27'!nextLargeIntegerBase: aRadix nPackets: nPackets 	"Form a Large integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading when no more digits or when nPackets elementary LargeInteger have been encountered.	Count the number of digits and the lastNonZero digit and store them in instVar"		| high nDigitsHigh lastNonZeroHigh low nDigitsLow halfPackets |	halfPackets := nPackets bitShift: -1.	halfPackets = 0 ifTrue: [^self nextElementaryLargeIntegerBase: aRadix].	high := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	high isLarge ifFalse: [^high].	nDigitsHigh := nDigits.	lastNonZeroHigh := lastNonZero.	low := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	nDigitsLow := nDigits.	nDigits := nDigitsHigh + nDigitsLow.	lastNonZero := lastNonZero = 0		ifTrue: [lastNonZeroHigh]		ifFalse: [lastNonZero + nDigitsHigh].	^high * (aRadix raisedToInteger: nDigitsLow) + low! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/30/2011 16:11'!nextFraction	| numerator denominator |	numerator := self nextInteger.	(sourceStream peekFor: $/) ifFalse: [^numerator].	denominator := self nextInteger.	^numerator / denominator! !!NumberParser methodsFor: 'parsing-public' stamp: 'MarcusDenker 7/23/2014 22:29'!nextInteger	"Main method for reading an Integer.	This won't try to read a Float nor a ScaledDecimal."		base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [self fail].	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			| oldNeg pos |			pos := sourceStream position.			(base := integerPart) < 2				ifTrue: ["A radix currently need to be greater than 1, ungobble the r and return the integer part"					sourceStream skip: -1.					^neg						ifTrue: [base negated]						ifFalse: [base]].			oldNeg := neg.			self peekSignIsMinus ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerOrNilBase: base.			integerPart ifNil: [self fail]].	neg		ifTrue: [integerPart := integerPart negated].	self readExponent		ifTrue: [^integerPart * (base raisedToInteger: exponent)].	^ integerPart! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25'!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 8/27/2010 20:51'!nextIntegerBase: aRadix ifFail: aBlock	"Form an integer with optional sign and following digits from sourceStream."		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^aBlock value].	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!NumberParser methodsFor: 'parsing-public' stamp: 'NicolaiHess 3/24/2015 08:44'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledIntegerOrFloat]! !!NumberParser methodsFor: 'parsing-public' stamp: 'NicolaiHess 3/24/2015 08:45'!nextNumberBase: b	"Method for reading a number without radix prefix.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := b.	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledIntegerOrFloat]! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 3/15/2014 15:46'!nextScaledDecimal	"Main method for reading a (scaled) decimal number.	Good Gracious, do not accept a decimal in another base than 10!!	In other words, do not accept radix notation like 2r1.1, even not 10r5.3	Do not accept exponent notation neither, like 1.0e-3"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart |	base := 10.	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base.	(sourceStream peekFor: $.)		ifTrue: [fractionPart := self nextUnsignedIntegerOrNilBase: base.			fractionPart ifNil: ["Oops, the decimal point seems not part of this number"							sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated asScaledDecimal: 0]								ifFalse: [integerPart asScaledDecimal: 0]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			(self readScaleWithDefaultNumberOfDigits: nDigits)				ifFalse: ["No scale were provided. use number of digits after decimal point as scale"					scale := nDigits].			^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart].	self readScaleWithDefaultNumberOfDigits: 0.	neg	ifTrue: [integerPart := integerPart negated].	^integerPart asScaledDecimal: scale! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Fail if no digit found.	Count the number of digits and the lastNonZero digit and store int in instVar "		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))].	^value! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or execute errorBlock if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^errorBlock value].	^value! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 7/26/2009 00:21'!nextUnsignedIntegerOrNilBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or nil if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| nPackets high nDigitsHigh lastNonZeroHigh low |	"read no more digits than one elementary LargeInteger"	high :=  self nextElementaryLargeIntegerBase: aRadix.	nDigits = 0 ifTrue: [^nil].		"Not enough digits to form a LargeInteger, stop iteration"	high isLarge ifFalse: [^high].	"We now have to engage arithmetic with LargeInteger	Decompose the integer in a high and low packets of growing size:"	nPackets := 1.	nDigitsHigh := nDigits.	lastNonZeroHigh := lastNonZero.	[	low := self nextLargeIntegerBase: aRadix nPackets: nPackets .	high := high * (aRadix raisedToInteger: nDigits) + low.	lastNonZero = 0 ifFalse: [lastNonZeroHigh := lastNonZero + nDigitsHigh].	nDigitsHigh := nDigitsHigh + nDigits.	low isLarge]		whileTrue: [nPackets := nPackets * 2].	nDigits := nDigitsHigh.	lastNonZero := lastNonZeroHigh.	^high! !!NumberParser methodsFor: 'initialize-release' stamp: 'damiencassou 5/30/2008 10:56'!on: aStringOrStream 	sourceStream := aStringOrStream isString 		ifTrue: [ aStringOrStream readStream ]		ifFalse: [ aStringOrStream ].	base := 10.	neg := false.	integerPart := fractionPart := exponent := scale := 0.	requestor := failBlock := nil! !!NumberParser class methodsFor: 'instance creation' stamp: 'nice 5/1/2006 00:45'!on: aStringOrStream	^self new on: aStringOrStream! !!NumberParser class methodsFor: 'instance creation' stamp: 'MarcusDenker 8/28/2013 10:44'!parse: aStringOrStream 	^self new		on: aStringOrStream;		nextNumber! !!NumberParser class methodsFor: 'instance creation' stamp: 'nice 5/1/2006 02:02'!parse: aStringOrStream onError: failBlock 	^(self new)		on: aStringOrStream;		failBlock: failBlock;		nextNumber! !!NumberParser class methodsFor: 'instance creation' stamp: 'NikoSchwarz 10/23/2009 13:21'!squeezeNumberOutOfString: stringOrStream	"Try and find a number in this string. First, look if the string 	starts with a number. Then, see if it ends with a number. Then,	remove a character from the front and see if the remaining 	string makes a number. Repeat the process until no characters	are left or the number has been found. As soon as a number is	found, it is returned. Otherwise, the method fails."	^ self squeezeNumberOutOfString: stringOrStream onError: [self error: 'Reading a number failed']! !!NumberParser class methodsFor: 'instance creation' stamp: 'MarcusDenker 12/2/2013 14:07'!squeezeNumberOutOfString: stringOrStream onError: errorBlock	"Try and find a number in this string. First, look if the string 	starts with a number. Then, see if it ends with a number. Then,	remove a character from the front and see if the remaining 	string makes a number. Repeat the process until no characters	are left or the number has been found. As soon as a number is	found, it is returned. Otherwise, the method fails."		| string |	string := stringOrStream.					stringOrStream size timesRepeat: [		(self parse: string onError: [ nil ])			ifNotNil: [ :result| ^ result ].		string := string allButFirst ].		^ errorBlock value! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!asSelectorEnvironment	| result |	result := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: [ :class :selector | 		result addClass: class selector: selector ].	^ result.! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesAndSelectorsDo: aBlock	self package coreMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].	self package extensionMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesDo: aBlock	self package classesAndMetaClasses do: [ :each |		(self includesClass: each)			ifTrue: [ aBlock value: each ] ].	self package extensionClasses do: [ :each |		(self environment includesClass: each)			ifTrue: [ aBlock value: each ].		(self environment includesClass: each class)			ifTrue: [ aBlock value: each class ] ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!package	^ package! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesCategory: aCategory	^ (super includesCategory: aCategory) 		and: [ self package includesSystemCategory: aCategory ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesClass: aClass	^ (super includesClass: aClass) 		and: [ self package includesClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesProtocol: aProtocol in: aClass	^ (self environment includesProtocol: aProtocol in: aClass) 		and: [ self package includesMethodCategory: aProtocol ofClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesSelector: aSelector in: aClass	^ (self environment includesSelector: aSelector in: aClass) 		and: [ self package includesMethod: aSelector ofClass: aClass ].! !!PackageEnvironment methodsFor: 'private' stamp: 'lr 1/3/2006 12:12'!package: aPackageInfo	package := aPackageInfo! !!PackageEnvironment methodsFor: 'printing' stamp: 'lr 1/3/2006 12:06'!storeOn: aStream 	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPutAll: ' packageNamed: '; print: self package packageName; nextPut: $).! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment package: aPackageInfo	^ (self onEnvironment: anEnvironment)		package: aPackageInfo;		yourself.! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment packageNamed: aString	^ self onEnvironment: anEnvironment package: (PackageInfo named: aString).! !!ParseTreeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(matcher canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	(matcher executeTree: aSmalllintContext parseTree initialAnswer: nil) 		notNil 			ifTrue: 				[result addClass: aSmalllintContext selectedClass					selector: aSmalllintContext selector]! !!ParseTreeLintRule methodsFor: 'private'!defaultResultClass	^ParseTreeEnvironment! !!ParseTreeLintRule methodsFor: 'initialize-release'!matcher: aParseTreeMatcher	matcher := aParseTreeMatcher! !!ParseTreeLintRule methodsFor: 'initialize-release'!resetResult	result := ParseTreeEnvironment new.	result		label: self name;		matcher: matcher! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!asOrderedCollectionNotNeeded	^self 		createParseTreeRule: #('`@node addAll: `{:node | node isMessage and: [#(asOrderedCollection asArray) includes: node selector]}')		name: '#asOrderedCollection/#asArray not needed'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ensure: `@block' 			'[| `@temps | `@.Statements. ^`@object] ensure: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ifCurtailed: `@block' 			'[| `@temps | `@.Statements. ^`@object] ifCurtailed: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!ifTrueBlocks	^self 		createParseTreeRule: #(				'`@condition ifTrue: `{:node | node isBlock not} ifFalse: `@block' 				'`@condition ifTrue: `@block ifFalse: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not} ifTrue: `@block' 				'`@condition ifFalse: `@block ifTrue: `{:node | node isBlock not}' 				'`@condition ifTrue: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not}')		name: 'Non-blocks in ifTrue:/ifFalse: messages'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!precedence	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node hasParentheses not and: [#(#+ #-) includes: node selector]]} * `@C')		name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'! !!ParseTreeLintRule class methodsFor: 'miscellaneous' stamp: 'jws 10/23/2016 05:39'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher matches: '`@receiver , `@argument' do: [ :aNode :answer | true ].	matcher		matchesAnyOf:			#('``@collection do: [:`each | | `@temps | ``@.Statements]' '``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' '``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' '``@collection select: [:`each | | `@temps | ``@.Statements]' '``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					(aNode arguments						detect: [ :each | each isBlock and: [ concatenationMatcher executeTree: each initialAnswer: false ] ]						ifNone: [ nil ]) notNil						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedAndOr	^self 		createParseTreeRule: #('(`@a and: `@b) and: `@c' '(`@a or: `@b) or: `@c')		name: 'Uses "(a and: [b]) and: [c]" instead of "a and: [b and: [c]]"'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedToDo	^self createParseTreeRule: #('(`@a to: `@b) do: `@c')		name: 'Uses (to:)do: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!yourselfNotUsed	^self createParseTreeRule: #('`{:node | node parent isUsed not} yourself')		name: 'Doesn''t use the result of a yourself message'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectSelectNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(#(#select: #collect: #reject:) includes: node selector) and: [node isUsed not]]}')		name: 'Doesn''t use the result of a collect:/select:'! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			(#(#add: #remove: #addAll: #removeAll:)				collect: [ :each | ('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) asString ])		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					((aNode receiver selector copyFrom: 1 to: (aNode receiver selector size min: 2)) ~= 'as'						and: [ 							| receiver |							receiver := aNode receiver receiver.							receiver isVariable not								or: [ ((#('self' 'super') includes: receiver name) or: [ Smalltalk includesKey: receiver name asSymbol ]) not ] ])						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil'				'`@collection at: 1'				'`@collection at: `@collection size') 		name: 'Uses "size = 0", "= nil",  or "at: 1" instead of "isEmpty",  "isNil", or "first"'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!guardingClause	| detector matcher |	detector := self new.	detector name: 'Guarding clauses'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyMethodOf:			#('`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' '`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ aNode body statements last ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' '| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					| node |					node := (aNode statements at: aNode statements size - 1) arguments first body statements last value.	"``@value1"					((node isLiteral						and: [ 							{true.							false} includes: node value ])						or: [ 							node := aNode statements last value.							node isLiteral								and: [ 									{true.									false} includes: node value ] ])						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!literalArrayCharacters	| detector matcher |	detector := self new.	detector name: 'Literal array contains only characters'.	matcher := ParseTreeSearcher new.	matcher		matches: '`#literal'		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					(aNode value class == Array and: [ self isArrayOfCharacters: aNode value ])						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			#('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]' '(`@x `message: `@y) `ifTrue: [`v := `@x] `ifFalse: [`v := `@y]')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					((#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aNode selector)						and: [ #(#< #<= #> #>=) includes: aNode receiver selector ])						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!searchingLiteral	| detector matcher |	detector := self new.	detector name: 'Uses or''s instead of a searching literal'.	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			#('``@object = `#literal or: [``@expression]' '``@object == `#literal or: [``@expression]' '`#literal = ``@object or: [``@expression]' '`#literal == ``@object or: [``@expression]' '``@expression | (``@object = `#literal)' '``@expression | (``@object == `#literal)' '``@expression | (`#literal = ``@object)' '``@expression | (`#literal == ``@object)')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					(self isSearchingLiteralExpression: aNode)						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'jws 10/23/2016 05:39'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher		matches: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]'		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					| varName variableMatcher |					varName := aNode arguments last arguments first.	"`each"					variableMatcher := ParseTreeSearcher new.					variableMatcher						matchesTree: varName						do: [ :node :ans | ans and: [ node parent isMessage and: [ node parent selector == #at: ] ] ].					(variableMatcher executeTree: aNode arguments last body initialAnswer: true)						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoCollect	^self 		createParseTreeRule: #(			'| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `@size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3'					"-------------"			 '| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `collection size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3')		name: 'to:do: doesn''t use collect:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoWithIncrement	^self 		createParseTreeRule: #(				'`@i to: `@j do: [:`e | | `@temps | `@.Stmts. `x := `x + 1. `@.Stmts2]' 				'`@i to: `@j by: `@k do: [:`e | | `@temps | `@.Stmts. `x := `x + `@k. `@.Stmts2]')		name: 'to:do: loop also increments a counter'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!ParseTreeLintRule class methodsFor: 'bugs' stamp: 'jws 10/23/2016 05:39'!sendsUnknownMessageToGlobal	| detector matcher |	detector := self new.	detector name: 'Sends unknown message to global'.	matcher := ParseTreeSearcher new.	matcher		matches: '`{:node :context | node isVariable and: [ Smalltalk includesKey: node name asSymbol ] } `@message: `@args'		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					| what |					what := Smalltalk at: aNode receiver name asSymbol.					(what notNil and: [ what ~~ Preferences and: [ (what respondsTo: aNode selector) not ] ])						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:20'!codeCruftLeftInMethods	^(self createParseTreeRule: {				'`@whatever doOnlyOnce: `@stuff'.				'Transcript `@msg: `@args'.				'`@any halt'.				'true ifTrue: `@stuff'.				'`@any flag: `#lit'.				'`@any needsWork'.			}		name: 'Debugging code left in methods')		rationale: 'Halts, Transcript writes, doOnlyOnce:, etc. should not be left in production code.';		yourself! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:46'!missingTranslationsInMenus	^(self createParseTreeRule: {				'`@menu add: `#label action: `#sym'.				'`@menu add: `#label selector: `#sym arguments: `@stuff'.				'`@menu add: `#label subMenu: `@stuff'.				'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.				'`@menu add: `#label target: `@targ action: `#sel'.				'`@menu add: `#label target: `@targ selector `#sel'.				'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.				'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.				'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.				'`@menu addTitle: `#label'.				'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.				'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.				'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.				'`@menu balloonTextForLastItem: `#label'.				'`@menu labels: `#lit lines: `@lines selections: `@sels'.				'`@menu title: `#title'			}		name: 'Menus missing translations')		rationale: 'Literal strings shown to users in menus should be translated.';		yourself! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 7/30/2004 19:09'!sendsDeprecatedMethodToGlobal	| nav patterns pattern wellKnownGlobals |	nav := SystemNavigation default.	patterns := OrderedCollection new.	wellKnownGlobals := IdentityDictionary new.	Smalltalk		keysAndValuesDo: [:k :v | v isBehavior				ifFalse: [(wellKnownGlobals						at: v class						ifAbsentPut: [Set new])						add: k]].	#(#deprecated: 'deprecated:explanation:' 'deprecated:block:' )		do: [:sym | (nav allCallsOn: sym)				do: [:mr | mr classIsMeta						ifTrue: [mr actualClass								withAllSubclassesDo: [:cls | patterns										add: (String												streamContents: [:s | s nextPutAll: cls theNonMetaClass name;																												nextPutAll: (self genericPatternForSelector: mr methodSymbol)])]]						ifFalse: [wellKnownGlobals								keysAndValuesDo: [:gcls :gnames | (gcls includesBehavior: mr actualClass)										ifTrue: [gnames												do: [:gname | pattern := String																streamContents: [:s | 																	s nextPutAll: gname.																	s																		nextPutAll: (self genericPatternForSelector: mr methodSymbol)]].											patterns add: pattern]]]]].	patterns add: 'self beep: `@object1';		 add: 'self beep'.	^ self createParseTreeRule: patterns name: 'Sends a deprecated message to a known global'! !!ParseTreeLintRule class methodsFor: 'private' stamp: 'jws 10/23/2016 05:39'!createMatcherFor: codeStrings method: aBoolean	| matcher |	matcher := ParseTreeSearcher new.	aBoolean		ifTrue: [ matcher matchesAnyMethodOf: codeStrings do: [ :aNode :answer | aNode ] ]		ifFalse: [ matcher matchesAnyOf: codeStrings do: [ :aNode :answer | aNode ] ].	^ matcher! !!ParseTreeLintRule class methodsFor: 'private' stamp: 'nk 7/30/2004 09:55'!genericPatternForSelector: sel	"	ParseTreeLintRule genericPatternForSelector: #a	ParseTreeLintRule genericPatternForSelector: #a:b:c:	"	^String streamContents: [ :s |		sel keywords withIndexDo: [ :k :i | s space; nextPutAll: k.			(k last = $:) ifTrue: [ s space; nextPutAll: '`@object'; print: i  ]]]! !!ParseTreeLintRule class methodsFor: 'private'!isArrayOfCharacters: anArray 	anArray isEmpty ifTrue: [^false].	1 to: anArray size		do: [:each | (anArray at: each) class == Character ifFalse: [^false]].	^true! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aMessageNode 	| equalNode expressionNode |	equalNode := aMessageNode selector = #| 				ifTrue: [aMessageNode arguments first]				ifFalse: [aMessageNode receiver].	expressionNode := equalNode receiver isLiteral 				ifTrue: [equalNode arguments first]				ifFalse: [equalNode receiver].	^self isSearchingLiteralExpression: aMessageNode for: expressionNode! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aSearchingNode for: anObjectNode 	| argument arguments |	aSearchingNode isMessage ifFalse: [^false].	arguments := aSearchingNode arguments.	arguments size = 1 ifFalse: [^false].	argument := arguments first.	(#(#= #==) includes: aSearchingNode selector) 		ifTrue: 			[^(aSearchingNode receiver = anObjectNode 				and: [aSearchingNode arguments first isLiteral]) or: 						[aSearchingNode arguments first = anObjectNode 							and: [aSearchingNode receiver isLiteral]]].	aSearchingNode selector = #| 		ifTrue: 			[^(self isSearchingLiteralExpression: aSearchingNode receiver				for: anObjectNode) 					and: [self isSearchingLiteralExpression: argument for: anObjectNode]].	aSearchingNode selector = #or: ifFalse: [^false].	argument isBlock ifFalse: [^false].	argument body statements size = 1 ifFalse: [^false].	^(self isSearchingLiteralExpression: aSearchingNode receiver		for: anObjectNode) and: 				[self isSearchingLiteralExpression: argument body statements first					for: anObjectNode]! !!ParseTreeLintRule class methodsFor: 'private' stamp: 'jws 10/23/2016 05:39'!modifiesTree: aCollectionTree in: aParseTree	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBVariableNode named: '`@object').	notifier		matchesAnyTreeOf:			(#(#add: #addAll: #remove: #removeAll:)				collect: [ :each | RBMessageNode receiver: aCollectionTree selector: each arguments: args ])		do: [ :aNode :answer | true ].	^ notifier executeTree: aParseTree initialAnswer: false! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	^(self new)		name: aName;		matcher: (self createMatcherFor: codeStrings method: aBoolean);		yourself! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self 		createParseTreeRule: codeStrings		method: false		name: aName! !!ParseTreeLintRule class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:39'!endTrueFalse	| detector matcher |	detector := self new.	detector name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := ParseTreeSearcher new		matchesAnyOf:				#('`@object 								ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 								ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 								ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 								ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' '`@object 								ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 								ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 								ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 								ifTrue: [| `@temps2 | `.Statement. `@.Statement2]')			do: [ :aNode :answer | 				answer isNil					ifTrue: [ 						| node |						node := aNode arguments first body statements last.						(node isVariable and: [ node = aNode arguments last body statements last ])							ifTrue: [ nil ]							ifFalse: [ aNode ] ]					ifFalse: [ answer ] ];		yourself.	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'unnecessary code' stamp: 'jws 10/23/2016 05:39'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := ParseTreeSearcher new		matchesAnyOf: #('true' 'false')			do: [ :aNode :answer | 					answer isNil						ifTrue: [ 							(aNode parent isMessage and: [ #(#= #== #~= #~~) includes: aNode parent selector ])								ifTrue: [ aNode ]								ifFalse: [ nil ] ]						ifFalse: [ answer ] ];		yourself.	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!extraBlock	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node receiver isBlock and: [node parent isCascade not and: [#(#value #value: #value:value: #value:value:value: #valueWithArguments) includes: node selector]]]}')		name: 'Block immediately evaluated'! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!unnecessaryAssignment	^self 		createParseTreeRule: #('^`{:aNode | aNode isAssignment and: [(aNode whoDefines: aNode variable name) notNil]}')		name: 'Unnecessary assignment to a temporary variable'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!equalNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node isUsed not and: [#(#= #== #~= #~~ #< #> #<= #>=) includes: node selector]]}')		name: 'Doesn''t use the result of a =, ~=, etc.'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]'				'[| `@temps | 					`var := `@object.  					`@.statements] 							ensure: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							ifCurtailed: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'bh 4/2/2000 22:17'!missingYourself	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node parent isCascade and: [node isDirectlyUsed and: [node selector ~~ #yourself]]]}')		name: 'Possible missing "; yourself"'! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!modifiesCollection	| detector matcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	matcher := ParseTreeSearcher new		matchesAnyOf:				#('`@object do: [:`each | | `@temps | ``@.Statements]' '`@object collect: [:`each | | `@temps | ``@.Statements]' '`@object select: [:`each | | `@temps | ``@.Statements]' '`@object reject: [:`each | | `@temps | ``@.Statements]' '`@object inject: `@value into: [:`sum :`each | | `@temps | ``@.Statements]')			do: [ :aNode :answer | 					answer isNil						ifTrue: [ 							(self modifiesTree: aNode receiver in: aNode arguments last)								ifTrue: [ aNode ]								ifFalse: [ nil ] ]						ifFalse: [ answer ] ];		yourself.	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!returnInEnsure	| detector matcher returnMatcher |	detector := self new.	detector name: 'Contains a return in an ensure: block'.	returnMatcher := ParseTreeSearcher new.	returnMatcher matches: '^`@object' do: [ :aNode :answer | true ].	matcher := ParseTreeSearcher new.	matcher		matchesAnyOf:			#('``@rcv ensure: [| `@temps | ``@.Stmts]' '``@rcv valueNowOrOnUnwindDo: [| `@temps | ``@.Stmts]' '``@rcv ifCurtailed: [| `@temps | ``@.Stmts]' '``@rcv valueOnUnwindDo: [| `@temps | ``@.Stmts]')		do: [ :aNode :answer | 			answer isNil				ifTrue: [ 					(returnMatcher executeTree: aNode arguments first initialAnswer: false)						ifTrue: [ aNode ]						ifFalse: [ nil ] ]				ifFalse: [ answer ] ].	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'jws 10/23/2016 05:39'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := ParseTreeSearcher new		matches: '``@x @ ``@y'			do: [ :aNode :answer | 					answer isNil						ifTrue: [ 							| current |							current := aNode parent.							[ current isNil or: [ current isMessage and: [ current selector == #@ or: [ current selector isInfix not ] ] ] ]								whileFalse: [ current := current parent ].							(current isNil or: [ current isMessage and: [ current selector isInfix not ] ])								ifTrue: [ nil ]								ifFalse: [ aNode ] ]						ifFalse: [ answer ] ];		yourself.	detector matcher: matcher.	^ detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!usesAdd	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(node selector == #add: or: [node selector == #addAll:]) and: [node isDirectlyUsed]]}')		name: 'Uses the result of an add: message'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!expressionParserString	^'%left "+" "-" ;%left "*" "/" ;%right "^" ;Expression: Expression ''first'' "+" Expression ''last'' {first + last}	| Expression "-" Expression {''1'' - ''3''}	| Expression "*" Expression {''1'' * ''3''}	| Expression "/" Expression {''1'' / ''3''}	| Expression "^" Expression {''1'' raisedTo: ''3''} 	| "(" Expression ")" {''2''}	| <number> {''1'' value asNumber};'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!expressionScannerString	^'<number>	:	[0-9]+ (\. [0-9]+) ? ;<whitespace>	:	\s+;'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testBadCharacterBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler buildScanner: '<foo> : [a-] ;' andParser: 'Start : <foo>;'.			parserCompiler compileInto: TestScanner andParser: TestParser]		raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testBadSmalltalkBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler buildScanner: '<foo> : foo ;' andParser: 'Start : <foo> {self printOn: };'.			parserCompiler compileInto: TestScanner andParser: TestParser]		raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testBraceRepeatToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <%<IDENTIFIER>%>;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a b c') collect: [:each | each value]) asArray 				= #('a' 'b' 'c').	self assert: (TestParser parse: '') size = 0! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testBracketOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> [":"] begin {''1'' value , ''3''} | <IDENTIFIER> {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileDefinitionComments;		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a b : c') = 'abc'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testComments	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : /* q */ /***/ /****/ a # b ;' andParser: '/* */ /***/ /****/#this is a commentbegin : <a> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'a')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testCrLf	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : \r? \n | \r ;'		andParser: 'A : <a> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self 		assert: (TestParser parse: (String with: Character cr with: Character lf)).	self 		should: [TestParser parse: (String with: Character cr with: Character cr)]		raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testErrorToken	| parserCompiler countingBlock |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<name> : [a-zA-Z]+; <whitespace>: \s+;'		andParser: '%left "+"; Expression : <name> | Expression "+" Expression {[Notification signal] on: Error do: [:ex | ex return: (Notification raise)]} | error "+" Expression ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	countingBlock := 			[:string | 			| count |			count := 0.						[[TestParser parse: string] on: Notification				do: 					[:ex | 					count := count + 1.					[ex resume] on: Error						do: 							[:ex1 | 							ex isResumable: true.							ex1 retry]]] 					on: SmaCCParserError					do: [:ex | ex return].			count].	#(#('a + b + c' 2) #('+ a + b + c' 2) #('a + b +' 1) #('a + 1 / 2 + b + c + 3' 2) #('1 + 1 / 2 + b + c + 3' 1)) 		do: [:each | self assert: (countingBlock value: each first) = each last]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testErrors	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: self expressionScannerString		andParser: self expressionParserString.	parserCompiler compileInto: TestScanner andParser: TestParser.	TestParser parse: '+3*4' onError: [:str :pos | position := pos].	self assert: position = 1.	TestParser parseStream: (ReadStream on: '1+a+4')		onError: [:str :pos | position := pos].	self assert: position = 3! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testExcludeScannerState	| parserCompiler parser |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '					%excludes a;					<foo> : b;					a <bar> : a;'		andParser: '				Start : <foo> {true} | <bar> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'b').	self should: [TestParser parse: 'a'] raise: SmaCCParserError.	parser := TestParser on: (ReadStream on: 'a').	parser scanner state: #a.	self deny: parser parse.	parser := TestParser on: (ReadStream on: 'b').	parser scanner state: #a.	self should: [parser parse] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testExpressions	#(#LR1 #LALR1) do: 			[:each | 			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler buildScanner: self expressionScannerString				andParser: self expressionParserString.			parserCompiler compileInto: TestScanner andParser: TestParser.			self assert: (TestParser parse: '2 + 3 * 4 / 5 ^ 3 ^ 2') 						= (2 + (3 * 4 / (5 raisedTo: (3 raisedTo: 2)))).			self assert: (TestParser parse: '1.0*2/3+4.0^2^3+3') 						= (1.0 * 2 / 3 + (4.0 raisedTo: (2 raisedTo: 3)) + 3).			self assert: (TestParser parse: '(((1 + 2) * 3) ^ 2) ^ 3') 						= (((1 + 2) * 3 raisedTo: 2) raisedTo: 3)]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testIgnoreCaseKeywords	| parserCompiler case |	case := SmaCCGrammar ignoreCase.	SmaCCGrammar ignoreCase: true.		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<identifier> : [a-z_]+ ; <whitespace> : \s+ ;'		andParser: 'Start ::= "Foo" {true} | <identifier> <identifier> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'FOo').	self deny: (TestParser parse: 'FoObAr ASDS')] 			ensure: [SmaCCGrammar ignoreCase: case]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testImplicitParserTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '' andParser: 'A : <isLetter> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'a').	self should: [TestParser parse: ' '] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testImplicitScannerTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : <isLetter> + ;'		andParser: 'A : <a> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'asdfssdafADSFS').	self should: [TestParser parse: ' asdf asdf'] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testImplicitTokenPrecedence	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : . ;'		andParser: 'A : <a> {true} | <isLetter> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	0 to: 255		do: [:each | self assert: (TestParser parse: (String with: (Character value: each)))]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testInvertedCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<A> : a{1,3} ;						<ID> : [^a]+ ;						<comment> : \s+ ;'		andParser: 'begin : {0} | begin <A> {''1'' + 1} | begin <ID> {''1'' - 1};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'aa') = 1.	self assert: (TestParser parse: 'aaaa') = 2.	self assert: (TestParser parse: 'a bab') = 0! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testKeywords	| parserCompiler size case |	size := SmaCCGrammar maximumCharacterValue.	case := SmaCCGrammar ignoreCase.	SmaCCGrammar ignoreCase: true.	self supportsUnicodeStrings 		ifTrue: [SmaCCGrammar maximumCharacterValue: (2 raisedTo: 16) - 1].		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '' andParser: 'Start ::= "Foo" "bar";'.	parserCompiler compileInto: TestScanner andParser: TestParser.	TestParser parse: 'FoObAr'] 			ensure: 				[SmaCCGrammar					ignoreCase: case;					maximumCharacterValue: size]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testLALRErrorHandler	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<whitespace> : \s+ ;'		andParser: 'Start : Foo "]" Foo ")";					Foo : "a" Bar ;					Bar : "b" | error ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: 'a ] a b )'] raise: SmaCCParserError.	self should: [TestParser parse: 'a ) a b )'] raise: SmaCCParserError.	self should: [TestParser parse: 'a b ] a  ]'] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testMultipleStartingPositions	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<name> : \w+;'		andParser: '%start plus ;					multiply: plus "*" plus {true};					plus: <name> {false} | <name> "+" <name> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'a*a').	self assert: (TestParser parse: 'a+a*a').	self should: [TestParser parse: 'a+a'] raise: SmaCCParserError.	self 		deny: (TestParser parse: 'a+a' startingAt: TestParser startingStateForplus).	TestParser 		parse: 'a*a'		startingAt: TestParser startingStateForplus		onError: [:str :pos | position := pos].	self assert: position = 2! !!ParserGeneratorTest methodsFor: 'testing' stamp: 'lr 1/6/2007 21:32'!testNodeAccess	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildScanner: ''		andParser: 'start : "a" ''x'' { Array with: ''1'' value with: ''1'' value with: x value with: x value } ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'a') = #( 'a'  'a'  'a'  'a' )! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testNonAssociativeTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<IDENTIFIER> : \w+ ; <whitespace> : \s+ ;'		andParser: '%left "and" ;					%nonassoc "=" "<=";					%left "+" ;					expr : expr "=" expr {true} | expr "<=" expr {true} | expr "and" expr {true} | expr "+" expr {true} | <IDENTIFIER> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: 'a=b=c'] raise: SmaCCParserError.	self should: [TestParser parse: 'a=b<=c'] raise: SmaCCParserError.	self should: [TestParser parse: 'a=b+c=d'] raise: SmaCCParserError.	self assert: (TestParser parse: 'a=b and c=d')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> ":" ? begin {''1'' value , ''3''} | <IDENTIFIER> {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a b : c') = 'abc'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testParenthesesOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> (":" | "|") begin {''1'' value , ''3''} | <IDENTIFIER> {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a | b : c') = 'abc'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testPriority	| parserCompiler |	TestScanner 		compile: 'all ^self recordAndReportMatch: (Array with: self allId)'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : \{ | \< \% ;						<all> : .;'		andParser: '%id <all> <a>;  begin : A {true}							| All {false};					A : <a> ;					All: <all>;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: '{').	self assert: (TestParser parse: '<%').	self deny: (TestParser parse: '}')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testRecursiveRule	#(#LR1 #LALR1) do: 			[:each | 			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler buildScanner: self expressionScannerString				andParser: 'Test: Test1 Recursive;							Test1: <number> {''1'' value};							Recursive: | Recursive "|" <number> {''1'' add: ''3'' value; yourself};'.			parserCompiler compileInto: TestScanner andParser: TestParser.			self 				assert: ((parserCompiler grammar nonTerminalSymbolNamed: 'Recursive') 						firstTerminals 							includes: (parserCompiler grammar keywordTerminalNamed: '"|"')).			self 				assert: (TestParser parse: '2|3|4') = (OrderedCollection 								with: '2'								with: '3'								with: '4')]! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testReduceReduceConflict	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<letter> : \w ;						<whitespace>: \s+	;'		andParser: 'begin : Foo <letter> {true} | Bar <letter> {false};					Foo :  ;					Bar : ;'.	self 		assert: (			[parserCompiler compileInto: TestScanner andParser: TestParser.			false] 					on: SmaCCCompilationNotification					do: 						[:ex | 						('*Reduce/Reduce*' match: ex messageText) 							ifTrue: [ex return: true]							ifFalse: [ex resume: nil]])! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testReduceRules	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '					<char> : [a-zA-Z] ; 					<ws> : \s ;'		andParser: '				Start ::= Chars {#liftFirstValue:};				Chars : WS A WS {#liftSecondValue:};				A : WS WS C {#liftLastValue:} | C WS {#liftLastValue:};				WS : <ws> {#nil};				C : <char> {#stringValue:};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: ' a  ') = nil.	self assert: (TestParser parse: '   a ') = 'a'! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testRepeatMultipleToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>){1,2}	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> + ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a1 bb c44') collect: [:each | each value]) 				asArray = #('a1' 'bb' 'c44').	self 		assert: ((TestParser parse: 'aaaaa') collect: [:each | each value]) asArray 				= #('aaa' 'aa').	self should: [TestParser parse: ''] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testRepeatToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> * ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a b c') collect: [:each | each value]) asArray 				= #('a' 'b' 'c').	self assert: (TestParser parse: '') size = 0! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testRepeatingCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<A> : a{1,3} ;						<ID> : \w+ ;						<whitespace> : \s+ ;'		andParser: 'begin : {true} | begin <A> {''1''} | begin <ID> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'aa').	self deny: (TestParser parse: 'aaaa')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testReuseCompositeToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTERDIGIT> : [a-zA-Z_] \d ;						<AAorBB> :  aa | bb;						<IDENTIFIER>: <LETTERDIGIT> | <AAorBB>	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> begin {false} | <IDENTIFIER> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: 'aa').	self assert: (TestParser parse: 'bb').	self assert: (TestParser parse: 'a4').	self should: [TestParser parse: 'ab'] raise: SmaCCParserError.	self should: [TestParser parse: '4b'] raise: SmaCCParserError! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testReuseSimpleToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '<LETTER> : [a-zA-Z_\\] ;						<DIGIT> : [0-9] ;						<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;						<whitespace>: \s+	;'		andParser: 'begin : <IDENTIFIER> begin {false} | <IDENTIFIER> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: '\')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testScannerState	| parserCompiler parser |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '					%states a ;					<foo> : b;					a <bar> : a;'		andParser: '				Start : <foo> {true} | <bar> {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'b').	self should: [TestParser parse: 'a'] raise: SmaCCParserError.	parser := TestParser on: (ReadStream on: 'a').	parser scanner state: #a.	self deny: parser parse.	parser := TestParser on: (ReadStream on: 'b').	parser scanner state: #a.	self assert: parser parse! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testSimple	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<a> : a ;' andParser: 'begin : <a> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: 'a')! !!ParserGeneratorTest methodsFor: 'testing' stamp: ' 6/1/07 21:20'!testSpecialCharacters	| parserCompiler |	[String with: (Character value: 16rFF00)] on: Error do: [:ex | ^self].	"Unicode characters not supported"	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '<name> : \x3g \x20 \xFF \xFF1 \xFF00 \cC;'		andParser: 'begin ::= <name> {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser 				parse: (String withAll: (#(3 103 16r20 16rFF 16rFF1 16rFF00 2) 								collect: [:each | Character value: each])))! !!ParserGeneratorTest methodsFor: 'private' stamp: 'lr 1/8/2007 21:49'!removeAllSelectorsFrom: aClass 	aClass selectors do: [ :each | aClass removeSelector: each ].	aClass organization removeEmptyCategories! !!ParserGeneratorTest methodsFor: 'private' stamp: ' 6/1/07 21:20'!supportsUnicodeStrings	^	[String with: (Character value: 16rFF00).	true] on: Error			do: [:ex | ex return: false]! !!ParserGeneratorTest methodsFor: 'running' stamp: 'lr 1/8/2007 21:46'!runCase	SystemChangeNotifier uniqueInstance 		doSilently: [ super runCase ]! !!ParserGeneratorTest methodsFor: 'running' stamp: 'lr 1/7/2007 11:19'!tearDown	super tearDown.	self		removeAllSelectorsFrom: TestParser;		removeAllSelectorsFrom: TestParser class;		removeAllSelectorsFrom: TestScanner;		removeAllSelectorsFrom: TestScanner class! !!ParserRecompiler class methodsFor: 'public' stamp: 'lr 1/8/2007 22:45'!bootstrap	| scanner grammer |	scanner := self		buildScanner: SmaCCScannerScanner		andParser: SmaCCScannerParser.	grammer := self		buildScanner: SmaCCGrammarScanner		andParser: SmaCCGrammarParser.	scanner compileChanges.	grammer compileChanges! !!ParserRecompiler class methodsFor: 'public' stamp: 'lr 1/8/2007 11:54'!examples	| class |	#( CParser JavaParser StParser ) do: [ :each |		class := Smalltalk classNamed: each.		(self			buildScanner: class scannerClass			andParser: class)				compileChanges ]! !!ParserRecompiler class methodsFor: 'private' stamp: 'lr 1/22/2007 13:12'!buildScanner: aScannerClass andParser: aParserClass	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildScanner: (self			definitionFrom: aScannerClass			selector: #scannerDefinitionComment)		andParser: (self			definitionFrom: aParserClass			selector: #parserDefinitionComment).	parserCompiler		scannerClass: aScannerClass;		parserClass: aParserClass.	[ parserCompiler		createChanges;		compileDefinitionComments ]			on: SmaCCCompilationNotification			do: [ :notification |				Transcript show: notification messageText; cr.				notification resume ].	^ parserCompiler! !!ParserRecompiler class methodsFor: 'private' stamp: 'lr 1/6/2007 22:50'!definitionFrom: aClass selector: aSymbol	| source input output |	source := aClass class sourceCodeAt: aSymbol.	input := ReadStream on: source.	output := WriteStream with: String new.	input upTo: $".	[ input atEnd ] whileFalse: [		(input peekFor: $")			ifTrue: [ output nextPut: $" ].		output nextPutAll: (input upTo: $") ].	^ output contents! !!ProtocolEnvironment methodsFor: 'initialize-release'!class: aClass protocols: aCollection	class := aClass.	protocols := aCollection! !!ProtocolEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	stream nextPutAll: class name;		nextPut: $>.	protocols do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ProtocolEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| aClass |						aClass := Smalltalk at: each ifAbsent: [nil].						aClass == class or: [aClass class == class]]]]! !!ProtocolEnvironment methodsFor: 'testing'!includesClass: aClass	^aClass == class and: [super includesClass: aClass]! !!ProtocolEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^aClass == class and: [(super includesProtocol: aProtocol in: aClass)			and: [protocols includes: aProtocol]]! !!ProtocolEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(super includesSelector: aSelector in: aClass) and: 			[protocols 				includes: (environment whichProtocolIncludes: aSelector in: aClass)]! !!ProtocolEnvironment methodsFor: 'testing'!isEmpty	^protocols isEmpty! !!ProtocolEnvironment methodsFor: 'copying'!postCopy	protocols := protocols copy.	^super postCopy! !!ProtocolEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream		nextPutAll: ' class: ';		nextPutAll: class name;		nextPutAll: ' protocols: '.	protocols asArray storeOn: aStream.	aStream nextPut: $)! !!ProtocolEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment class: aClass protocols: aCollection	^(self onEnvironment: anEnvironment)		class: aClass protocols: aCollection; yourself! !!RBAbstractClass methodsFor: 'comparing'!= aRBClass 	^self class = aRBClass class 		and: [self name = aRBClass name and: [self model = aRBClass model]]! !!RBAbstractClass methodsFor: 'comparing'!hash	^self name hash bitXor: self class hash! !!RBAbstractClass methodsFor: 'variable accessing'!addInstanceVariable: aString 	self privateInstanceVariableNames add: aString.	model addInstanceVariable: aString to: self! !!RBAbstractClass methodsFor: 'variable accessing'!removeInstanceVariable: aString 	self privateInstanceVariableNames remove: aString.	model removeInstanceVariable: aString from: self! !!RBAbstractClass methodsFor: 'variable accessing'!renameInstanceVariable: oldName to: newName around: aBlock 	self privateInstanceVariableNames 		at: (self privateInstanceVariableNames indexOf: oldName asString)		put: newName asString.	model 		renameInstanceVariable: oldName		to: newName		in: self		around: aBlock! !!RBAbstractClass methodsFor: 'variable accessing'!typeOfClassVariable: aSymbol 	^model classNamed: #Object! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesClassVariable: aString 	| sprClass |	(self directlyDefinesClassVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesClassVariable: aString]! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesInstanceVariable: aString 	| sprClass |	(self directlyDefinesInstanceVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'method accessing'!addMethod: aRBMethod 	self newMethods at: aRBMethod selector put: aRBMethod.	removedMethods notNil 		ifTrue: [removedMethods remove: aRBMethod selector ifAbsent: []]! !!RBAbstractClass methodsFor: 'method accessing'!allSelectors	| class selectors |	class := self.	selectors := Set new.	[class notNil] whileTrue: 			[selectors addAll: class selectors.			class := class superclass].	^selectors! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!bindingOf: aString 	^self realClass classPool associationAt: aString asSymbol		ifAbsent: [self realClass classPool associationAt: aString asString ifAbsent: [nil]]! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString 	^self compile: aString		classified: (self protocolsFor: (RBParser parseMethodPattern: aString))! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString classified: aSymbolCollection 	| change method |	change := model 				compile: aString				in: self				classified: aSymbolCollection.	method := RBMethod 				for: self				source: aString				selector: change selector.	self addMethod: method! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode 	^self compileTree: aBRMethodNode		classified: (self protocolsFor: aBRMethodNode selector)! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode classified: aSymbolCollection 	| method source |	source := aBRMethodNode formattedCode.	model 		compile: source		in: self		classified: aSymbolCollection.	method := RBMethod 				for: self				source: source				selector: aBRMethodNode selector."	method parseTree: aBRMethodNode."	self addMethod: method! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'bh 4/8/2000 18:58'!existingMethodsThatReferTo: aSymbol 	| existingMethods |	existingMethods := self realClass thoroughWhichSelectorsReferTo: aSymbol special:false byte:0.	(newMethods isNil and: [removedMethods isNil]) ifTrue: [^existingMethods].	^existingMethods 		reject: [:each | (self hasRemoved: each) or: [self newMethods includesKey: each]]! !!RBAbstractClass methodsFor: 'method accessing'!methodFor: aSelector 	^self newMethods at: aSelector		ifAbsent: 			[| compiledMethod class |			(self hasRemoved: aSelector) ifTrue: [^nil].			class := self realClass.			class isNil ifTrue: [^nil].			compiledMethod := class compiledMethodAt: aSelector ifAbsent: [nil].			compiledMethod isNil 				ifTrue: [nil]				ifFalse: 					[RBMethod 						for: self						fromMethod: compiledMethod						andSelector: aSelector]]! !!RBAbstractClass methodsFor: 'method accessing'!parseTreeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) parseTree! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'jmb 1/23/2003 15:50'!protocolsFor: aSelector 	| change |	change := self isMeta 				ifTrue: [model changes changeForMetaclass: name selector: aSelector]				ifFalse: [model changes changeForClass: name selector: aSelector].	^change isNil 		ifTrue: 			[self isDefined 				ifTrue: 					[Array with: (BrowserEnvironment new whichProtocolIncludes: aSelector in: self realClass)]				ifFalse: [#(#accessing)]]		ifFalse: [change protocols]! !!RBAbstractClass methodsFor: 'method accessing'!removeMethod: aSelector 	self newMethods removeKey: aSelector ifAbsent: [].	model removeMethod: aSelector from: self.	self removedMethods add: aSelector! !!RBAbstractClass methodsFor: 'method accessing'!selectors	| selectors |	selectors := Set new.	selectors addAll: self newMethods keys.	self isDefined 		ifTrue: 			[selectors addAll: self realClass selectors.			removedMethods notNil 				ifTrue: [removedMethods do: [:each | selectors remove: each ifAbsent: []]]].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!sourceCodeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) source! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToClass: aRBClass 	| selectors |	selectors := Set new.	self newMethods do: 			[:each | 			(each refersToClassNamed: aRBClass name) 				ifTrue: [selectors add: each selector]].	(self isDefined and: [aRBClass isDefined]) 		ifTrue: 			[selectors addAll: (self existingMethodsThatReferTo: aRBClass classBinding).			selectors addAll: (self existingMethodsThatReferTo: aRBClass name)].	^selectors! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!whichSelectorsReferToClassVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[| binding |			binding := self bindingOf: aString.			binding isNil ifTrue: [^selectors].			selectors addAll: ((self realClass whichSelectorsReferTo: binding) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToInstanceVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[selectors addAll: ((self realClass whichSelectorsAccess: aString) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToSymbol: aSymbol 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToSymbol: aSymbol) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: [selectors addAll: (self existingMethodsThatReferTo: aSymbol)].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whoDefinesMethod: aSelector 	| sprClass |	(self directlyDefinesMethod: aSelector) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesMethod: aSelector]! !!RBAbstractClass methodsFor: 'private'!addSubclass: aRBClass 	self subclasses add: aRBClass! !!RBAbstractClass methodsFor: 'private'!privateInstanceVariableNames	instanceVariableNames isNil 		ifTrue: 			[self isDefined 				ifTrue: [self instanceVariableNames: self realClass instVarNames]				ifFalse: [instanceVariableNames := OrderedCollection new]].	^instanceVariableNames! !!RBAbstractClass methodsFor: 'private'!superclass: aRBClass 	self superclass notNil ifTrue: [self superclass removeSubclass: self].	superclass := aRBClass.	superclass notNil ifTrue: [superclass addSubclass: self].! !!RBAbstractClass methodsFor: 'accessing'!allClassVariableNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!allInstanceVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self instanceVariableNames]		ifFalse: [sprClass allInstanceVariableNames , self instanceVariableNames]! !!RBAbstractClass methodsFor: 'accessing'!allPoolDictionaryNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!allSubclasses	| allSubclasses index |	index := 1.	allSubclasses := self subclasses asOrderedCollection.	[index <= allSubclasses size] whileTrue: 			[allSubclasses addAll: (allSubclasses at: index) subclasses.			index := index + 1].	^allSubclasses! !!RBAbstractClass methodsFor: 'accessing'!allSuperclasses	| supers sprClass |	supers := OrderedCollection new.	sprClass := self superclass.	[sprClass notNil] whileTrue: 			[supers add: sprClass.			sprClass := sprClass superclass].	^supers! !!RBAbstractClass methodsFor: 'accessing'!classBinding	^Smalltalk associationAt: self name! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames	^self privateInstanceVariableNames copy! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames: aCollectionOfStrings 	instanceVariableNames := aCollectionOfStrings asOrderedCollection! !!RBAbstractClass methodsFor: 'accessing'!metaclass	^model metaclassNamed: self name! !!RBAbstractClass methodsFor: 'accessing'!model	^model! !!RBAbstractClass methodsFor: 'accessing'!name	^name! !!RBAbstractClass methodsFor: 'accessing'!name: aSymbol 	name := aSymbol! !!RBAbstractClass methodsFor: 'accessing'!newMethods	^newMethods isNil 		ifTrue: [newMethods := IdentityDictionary new]		ifFalse: [newMethods]! !!RBAbstractClass methodsFor: 'accessing'!nonMetaclass	^model classNamed: self name! !!RBAbstractClass methodsFor: 'accessing'!primaryInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'accessing'!realClass	^realClass! !!RBAbstractClass methodsFor: 'accessing'!realClass: aClass 	realClass := aClass.	superclass isNil ifTrue: [superclass := LookupSuperclass]! !!RBAbstractClass methodsFor: 'accessing'!removeSubclass: aRBClass 	self subclasses remove: aRBClass ifAbsent: []! !!RBAbstractClass methodsFor: 'accessing'!removedMethods	^removedMethods isNil 		ifTrue: [removedMethods := Set new]		ifFalse: [removedMethods]! !!RBAbstractClass methodsFor: 'accessing'!soleInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'accessing'!subclasses	^subclasses isNil 		ifTrue: 			[subclasses := self isDefined 						ifTrue: 							[(self realClass subclasses collect: [:each | model classFor: each]) 								asOrderedCollection]						ifFalse: [OrderedCollection new]]		ifFalse: [subclasses]! !!RBAbstractClass methodsFor: 'accessing'!superclass	^superclass == LookupSuperclass 		ifTrue: [model classFor: self realClass superclass]		ifFalse: [superclass]! !!RBAbstractClass methodsFor: 'accessing'!withAllSubclasses	^(self allSubclasses)		add: self;		yourself! !!RBAbstractClass methodsFor: 'accessing'!withAllSuperclasses	^(self allSuperclasses)		add: self;		yourself! !!RBAbstractClass methodsFor: 'testing'!definesClassVariable: aSymbol 	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesClassVariable: aSymbol]! !!RBAbstractClass methodsFor: 'testing'!definesInstanceVariable: aString 	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'testing'!definesMethod: aSelector 	(self directlyDefinesMethod: aSelector) ifTrue: [^true].	^self superclass notNil and: [self superclass definesMethod: aSelector]! !!RBAbstractClass methodsFor: 'testing'!definesPoolDictionary: aSymbol 	(self directlyDefinesPoolDictionary: aSymbol) ifTrue: [^true].	^self inheritsPoolDictionaries and: 			[self superclass notNil 				and: [self superclass definesPoolDictionary: aSymbol]]! !!RBAbstractClass methodsFor: 'testing'!definesVariable: aVariableName 	^(self definesClassVariable: aVariableName) 		or: [self definesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesInstanceVariable: aString 	^self instanceVariableNames includes: aString! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesMethod: aSelector 	self isDefined 		ifTrue: 			[(self hasRemoved: aSelector) ifTrue: [^false].			(self realClass includesSelector: aSelector) ifTrue: [^true]].	^newMethods notNil and: [newMethods includesKey: aSelector]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesVariable: aVariableName 	^(self directlyDefinesClassVariable: aVariableName) 		or: [self directlyDefinesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'testing'!hasRemoved: aSelector 	^removedMethods notNil and: [removedMethods includes: aSelector]! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesClassVariable: aString 	(self definesClassVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesClassVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesInstanceVariable: aString 	(self definesInstanceVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesInstanceVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesMethod: aSelector 	(self definesMethod: aSelector) ifTrue: [^true].	^self subclassRedefines: aSelector! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesPoolDictionary: aString 	(self definesPoolDictionary: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesPoolDictionary: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesVariable: aString 	(self definesVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!includesClass: aRBClass 	| currentClass |	currentClass := self.	[currentClass notNil and: [currentClass ~= aRBClass]] 		whileTrue: [currentClass := currentClass superclass].	^currentClass = aRBClass! !!RBAbstractClass methodsFor: 'testing'!inheritsPoolDictionaries	^false! !!RBAbstractClass methodsFor: 'testing'!isAbstract	(self whichSelectorsReferToSymbol: #subclassResponsibility) isEmpty 		ifFalse: [^true].	model allReferencesToClass: self do: [:each | ^false].	^true! !!RBAbstractClass methodsFor: 'testing'!isDefined	^self realClass notNil! !!RBAbstractClass methodsFor: 'testing'!isMeta	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!subclassRedefines: aSelector 	"Return true, if one of your subclasses redefines the method with name, aMethod"	self allSubclasses 		do: [:each | (each directlyDefinesMethod: aSelector) ifTrue: [^true]].	^false! !!RBAbstractClass methodsFor: 'initialize-release'!initialize	name := #'Unknown Class'! !!RBAbstractClass methodsFor: 'initialize-release'!model: aRBSmalltalk	model := aRBSmalltalk! !!RBAbstractClass methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass methodsFor: 'printing'!storeOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass class methodsFor: 'class initialization'!initialize	LookupSuperclass := Object new! !!RBAbstractCondition methodsFor: 'logical operations'!& aCondition 	^RBConjunctiveCondition new left: self right: aCondition! !!RBAbstractCondition methodsFor: 'logical operations'!not	^RBNegationCondition on: self! !!RBAbstractCondition methodsFor: 'logical operations'!| aCondition 	"(A | B) = (A not & B not) not"	^(self not & aCondition not) not! !!RBAbstractCondition methodsFor: 'checking'!check	self subclassResponsibility! !!RBAbstractCondition methodsFor: 'accessing'!errorBlock	^self errorBlockFor: false! !!RBAbstractCondition methodsFor: 'accessing'!errorString	^self errorStringFor: false! !!RBAbstractCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^nil! !!RBAbstractCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: ['unknown']		ifFalse: [errorMacro]! !!RBAbstractCondition methodsFor: 'private'!errorMacro: aString 	errorMacro := aString! !!RBAbstractCondition methodsFor: 'private'!errorStringFor: aBoolean	^self errorMacro expandMacrosWith: aBoolean! !!RBClass methodsFor: 'variable accessing'!addClassVariable: aString 	self privateClassVariableNames add: aString asSymbol.	model addClassVariable: aString to: self! !!RBClass methodsFor: 'variable accessing'!addPoolDictionary: aString 	self privatePoolDictionaryNames add: aString asSymbol.	model addPool: aString to: self! !!RBClass methodsFor: 'variable accessing'!removeClassVariable: aString 	self privateClassVariableNames remove: aString asSymbol.	model removeClassVariable: aString from: self! !!RBClass methodsFor: 'variable accessing'!removePoolDictionary: aString 	self privatePoolDictionaryNames remove: aString asSymbol! !!RBClass methodsFor: 'variable accessing'!renameClassVariable: oldName to: newName around: aBlock 	self privateClassVariableNames 		at: (self privateClassVariableNames indexOf: oldName asSymbol)		put: newName asSymbol.	model 		renameClassVariable: oldName		to: newName		in: self		around: aBlock! !!RBClass methodsFor: 'accessing'!allClassVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self classVariableNames]		ifFalse: [sprClass allClassVariableNames , self classVariableNames]! !!RBClass methodsFor: 'accessing'!allPoolDictionaryNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self poolDictionaryNames]		ifFalse: [sprClass allPoolDictionaryNames , self poolDictionaryNames]! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:22'!category	^category isNil 		ifTrue: 			[self isDefined				ifTrue: [category := self realClass category]				ifFalse: [model environment whichCategoryIncludes: self name]]		ifFalse: [category]! !!RBClass methodsFor: 'accessing'!category: aSymbol 	category := aSymbol! !!RBClass methodsFor: 'accessing'!classVariableNames	^self privateClassVariableNames copy! !!RBClass methodsFor: 'accessing'!classVariableNames: aCollectionOfStrings 	classVariableNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 14:38'!definitionString	| definitionStream |	definitionStream := WriteStream on: ''.	definitionStream		nextPutAll: self superclass printString;		nextPutAll: ' subclass: #';		nextPutAll: self name;		nextPutAll: '	instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	classVariableNames: '''.	self classVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	poolDictionaries: '''.	self poolDictionaryNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	category: #'''.	definitionStream nextPutAll: self category asString.	definitionStream nextPut: $'.	^definitionStream contents! !!RBClass methodsFor: 'accessing'!nonMetaclass	^self! !!RBClass methodsFor: 'accessing'!poolDictionaryNames	^self privatePoolDictionaryNames copy! !!RBClass methodsFor: 'accessing'!poolDictionaryNames: aCollectionOfStrings 	poolDictionaryNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'accessing'!sharedPools	^self allPoolDictionaryNames 		collect: [:each | Smalltalk at: each asSymbol ifAbsent: [Dictionary new]]! !!RBClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self classVariableNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self poolDictionaryNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!isMeta	^false! !!RBClass methodsFor: 'private'!privateClassVariableNames	(self isDefined and: [classVariableNames isNil]) 		ifTrue: [self classVariableNames: self realClass classVarNames].	^classVariableNames! !!RBClass methodsFor: 'private'!privatePoolDictionaryNames	(self isDefined and: [poolDictionaryNames isNil]) 		ifTrue: 			[self poolDictionaryNames: (self realClass sharedPools 						collect: [:each | Smalltalk keyAtValue: each])].	^poolDictionaryNames! !!RBClass methodsFor: 'initialize-release'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol)! !!RBClass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBClass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBComment methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 11:03'!contents	^ contents! !!RBComment methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 16:35'!size	^ contents size + 2 "must take into account quotation marks"! !!RBComment methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 11:03'!start	^ start.! !!RBComment methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 16:35'!stop	^ start + self size - 1! !!RBComment methodsFor: 'initialize-release' stamp: 'PabloHerrero 11/7/2013 17:30'!with: aString at: startPosition	start := startPosition.	contents := aString.! !!RBComment class methodsFor: 'instance creation' stamp: 'PabloHerrero 11/7/2013 17:31'!with: aString at: startPosition	^ self new		with: aString at: startPosition;		yourself. 	! !!RBCondition methodsFor: 'checking'!check	^block value! !!RBCondition methodsFor: 'initialize-release'!errorBlock: anObject	errorBlock := anObject! !!RBCondition methodsFor: 'initialize-release' stamp: 'dvf 11/24/2001 13:14'!type: aSymbol block: aBlock errorString: aString 	self needsWork.  "replaced value with fixTemps. This should simulate closures well enough, we hope."	type := aSymbol.	block := aBlock fixTemps.	self errorMacro: aString! !!RBCondition methodsFor: 'initialize-release'!withBlock: aBlock 	block := aBlock.	type := #(#generic)! !!RBCondition methodsFor: 'accessing'!errorBlockFor: aBoolean	^errorBlock! !!RBCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:51'!printOn: aStream 	aStream nextPutAll: type asString! !!RBCondition class methodsFor: 'instance creation'!canUnderstand: aSelector in: aClass	^self new		type: (Array with: #understandsSelector with: aClass with: aSelector)		block: [aClass definesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!definesClassVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesClassVar				with: aClass				with: aString)		block: [aClass definesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesSelector: aSelector in: aClass 	^self new		type: (Array with: #definesSelector with: aClass with: aSelector)		block: [aClass directlyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >define<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!definesTempVar: aString in: aClass ignoreClass: subclass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVarIgnoring with: aClass with: aString with: subclass)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :aSelector | class includesClass: subclass].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!definesTemporaryVariable: aString in: aClass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVar with: aClass with: aString)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :selector | false].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesClassVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesClassVar with: aClass with: aString)		block: [aClass directlyDefinesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesInstanceVariable with: aClass with: aString)		block: [aClass directlyDefinesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!empty	"Returns an empty condition"	^self new 		type: (Array with: #empty)		block: [true]		errorString: 'Empty'! !!RBCondition class methodsFor: 'instance creation'!hasSubclasses: aClass	^self new		type: (Array with: #hasSubclasses with: aClass)		block: [aClass subclasses isEmpty not]		errorString: aClass printString , ' has <1?:no >subclasses'! !!RBCondition class methodsFor: 'instance creation'!hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: aClass printString , ' has <1?a:no> superclass'! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass canUnderstand: aSelector	^self new		type: (Array with: #hierarchyUnderstandsSelector with: aClass with: aSelector)		block: [aClass hierarchyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?or a subclass:and all subclasses do not> understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: aClass printString 				, ' or one of its subclasses <1?:does not >define<1?s:> variable ' 					, aString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[(aClass withAllSubclasses 				detect: [:each | (each whichSelectorsReferToInstanceVariable: aString) isEmpty not]				ifNone: [nil]) notNil]		errorString: aClass printString 				, ' or subclass <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: aClass printString , ' is <1?:not >an abstract class'! !!RBCondition class methodsFor: 'instance creation'!isClass: anObject	^self new		type: (Array with: #IsClass with: anObject)		block: [anObject isBehavior]		errorString: anObject printString , ' is <1?:not >a behavior'! !!RBCondition class methodsFor: 'instance creation'!isEmptyClass: anObject 	^self new type: (Array with: #IsEmptyClass with: anObject)		block: 			[anObject classVariableNames isEmpty				and: [anObject instanceVariableNames isEmpty and: [anObject selectors isEmpty]]]		errorString: anObject printString , ' is <1?:not > empty'! !!RBCondition class methodsFor: 'instance creation'!isGlobal: aString in: aRBSmalltalk 	^self new 		type: (Array with: #isGlobal with: aString)		block: [aRBSmalltalk includesGlobal: aString asSymbol]		errorString: aString , ' is <1?:not >a class or global variable'! !!RBCondition class methodsFor: 'instance creation'!isImmediateSubclass: subclass of: superClass	^self new		type: (Array with: #immediateSubclass with: superClass with: subclass)		block: [subclass superclass = superClass]		errorString: subclass printString , ' is <1?:not >an immediate subclass of ' , superClass printString! !!RBCondition class methodsFor: 'instance creation'!isMetaclass: anObject 	^self new type: (Array with: #IsMetaclass with: anObject)		block: [anObject isMeta]		errorString: anObject printString , ' is <1?:not >a metaclass'! !!RBCondition class methodsFor: 'instance creation'!isSymbol: aString	^self new		type: (Array with: #isSymbol with: aString)		block: [aString isSymbol]		errorString: aString , ' is <1?:not >a symbol'! !!RBCondition class methodsFor: 'instance creation'!isValidClassName: aString	^self new		type: (Array with: #validClassName with: aString)		block: [self validClassName: aString]		errorString: aString , ' is <1?:not >a valid class name'! !!RBCondition class methodsFor: 'instance creation'!isValidClassVarName: aString for: aClass	^self new		type: (Array with: #validClassVarName with: aString with: aClass)		block: [self checkClassVarName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid class variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidInstanceVariableName: aString for: aClass 	^self new 		type: (Array 				with: #validInstVarName				with: aString				with: aClass)		block: [self checkInstanceVariableName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid instance variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidMethodName: aString for: aClass	^self new		type: (Array with: #validMethodName with: aString with: aClass)		block: [self checkMethodName: aString in: aClass]		errorString: aString printString , ' is <1?:not >a valid method name'! !!RBCondition class methodsFor: 'instance creation'!referencesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #referencesInstVar with: aClass with: aString)		block: [(aClass whichSelectorsReferToInstanceVariable: aString) isEmpty not]		errorString: aClass printString 				, ' <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[(aClass subclasses detect: 					[:each | 					(each selectors detect: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]						ifNone: [nil]) notNil]				ifNone: [nil]) notNil]		errorString: '<1?:no:a> subclass of ' , aClass printString , ' refers to ' 				, aSelector printString! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock	^self new withBlock: aBlock! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock errorString: aString 	^self new type: #unknown		block: aBlock		errorString: aString! !!RBCondition class methodsFor: 'utilities'!checkClassVarName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	(self reservedNames includes: string) ifTrue: [^false].	string isEmpty ifTrue: [^false].	string first isUppercase ifFalse: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	string isEmpty ifTrue: [^false].	(self reservedNames includes: string) ifTrue: [^false].	string first isUppercase ifTrue: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^aName isString and: [RBScanner isSelector: aName]! !!RBCondition class methodsFor: 'utilities' stamp: 'jws 10/23/2016 05:39'!methodDefiningTemporary: aString in: aClass ignore: aBlock	| searcher method |	searcher := ParseTreeSearcher new.	method := nil.	"Shut-up the warning"	searcher matches: aString do: [ :aNode :answer | ^ method ].	aClass withAllSubclasses		do: [ :class | 			class selectors				do: [ :each | 					(aBlock value: class value: each)						ifFalse: [ 							| parseTree |							method := class methodFor: each.							parseTree := class parseTreeFor: each.							parseTree notNil								ifTrue: [ searcher executeTree: parseTree ] ] ] ].	^ nil! !!RBCondition class methodsFor: 'utilities'!reservedNames	^#('self' 'true' 'false' 'nil' 'thisContext' 'super')! !!RBCondition class methodsFor: 'utilities'!validClassName: aString 	"Class names and class variable names have the same restrictions"	^self checkClassVarName: aString in: self! !!RBConjunctiveCondition methodsFor: 'checking'!check	left check		ifFalse: 			[failed := #leftFailed.			^false].	right check		ifFalse: 			[failed := #rightFailed.			^false].	^true! !!RBConjunctiveCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^aBoolean		ifTrue: [nil]		ifFalse: 			[failed == #leftFailed ifTrue: [left errorBlock] ifFalse: [right errorBlock]]! !!RBConjunctiveCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: [self longMacro]		ifFalse: [super errorMacro]! !!RBConjunctiveCondition methodsFor: 'private'!errorStringFor: aBoolean 	^aBoolean		ifTrue: [self neitherFailed]		ifFalse: [self perform: failed]! !!RBConjunctiveCondition methodsFor: 'private'!leftFailed	^left errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!longMacro	^'(' , left errorMacro , ') <1?AND:OR> (' , right errorMacro , ')'! !!RBConjunctiveCondition methodsFor: 'private'!neitherFailed	^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)! !!RBConjunctiveCondition methodsFor: 'private'!rightFailed	^right errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!unknownFailed	^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)! !!RBConjunctiveCondition methodsFor: 'initialize-release'!left: aCondition right: aCondition2 	left := aCondition.	right := aCondition2.	failed := #unknownFailed! !!RBConjunctiveCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:52'!printOn: aStream 	aStream nextPutAll: left asString;		nextPutAll: ' & ';		nextPutAll: right asString! !!RBMetaclass methodsFor: 'accessing'!allClassVariableNames	^self nonMetaclass allClassVariableNames! !!RBMetaclass methodsFor: 'accessing'!allPoolDictionaryNames	^self nonMetaclass allPoolDictionaryNames! !!RBMetaclass methodsFor: 'accessing'!metaclass	^self! !!RBMetaclass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self nonMetaclass directlyDefinesClassVariable: aString! !!RBMetaclass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self nonMetaclass directlyDefinesPoolDictionary: aString! !!RBMetaclass methodsFor: 'testing'!isMeta	^true! !!RBMetaclass methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' class'! !!RBMetaclass methodsFor: 'printing'!storeOn: aStream 	super storeOn: aStream.	aStream nextPutAll: ' class'! !!RBMetaclass methodsFor: 'initialize-release'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol) class! !!RBMetaclass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBMetaclass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBMethod methodsFor: 'private'!literal: anObject containsReferenceTo: aSymbol 	anObject = aSymbol ifTrue: [^true].	anObject class = Array ifFalse: [^false].	anObject 		do: [:each | (self literal: each containsReferenceTo: aSymbol) ifTrue: [^true]].	^false! !!RBMethod methodsFor: 'accessing'!method	^compiledMethod! !!RBMethod methodsFor: 'accessing'!method: aCompiledMethod 	compiledMethod := aCompiledMethod! !!RBMethod methodsFor: 'accessing'!modelClass	^class! !!RBMethod methodsFor: 'accessing'!modelClass: aRBClass	class := aRBClass! !!RBMethod methodsFor: 'accessing'!parseTree	^RBParser parseMethod: self source onError: [:str :pos | ^nil]! !!RBMethod methodsFor: 'accessing'!selector	^selector! !!RBMethod methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol! !!RBMethod methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!source	^source isNil 		ifTrue: [source := (class realClass sourceCodeAt: selector) string]		ifFalse: [source]! !!RBMethod methodsFor: 'accessing'!source: aString 	source := aString! !!RBMethod methodsFor: 'printing'!printOn: aStream 	class printOn: aStream.	aStream		nextPutAll: '>>';		nextPutAll: self selector! !!RBMethod methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!refersToClassNamed: aSymbol	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aSymbol asString do: [ :node :answer | true ].	^ (searcher executeTree: self parseTree initialAnswer: false) or: [ self refersToSymbol: aSymbol ]! !!RBMethod methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!refersToSymbol: aSymbol	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [ :node :answer | true ];		matches: '`#literal' do: [ :node :answer | answer or: [ self literal: node value containsReferenceTo: aSymbol ] ].	(RBScanner isSelector: aSymbol)		ifTrue: [ searcher matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol) do: [ :node :answer | true ] ].	^ searcher executeTree: self parseTree initialAnswer: false! !!RBMethod methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!refersToVariable: aString	| searcher tree |	tree := self parseTree.	((tree defines: aString) or: [ tree body defines: aString ])		ifTrue: [ ^ false ].	searcher := ParseTreeSearcher new.	searcher		matches: aString do: [ :node :answer | true ];		matches: '[:`@vars | | `@temps | `@.Stmts]'			do: [ :node :answer | 					answer						or: [ 							((node defines: aString) or: [ node body defines: aString ]) not								and: [ searcher executeTree: node body initialAnswer: false ] ] ].	^ searcher executeTree: self parseTree initialAnswer: false! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass fromMethod: aCompiledMethod andSelector: aSymbol 	^(self new)		modelClass: aRBClass;		method: aCompiledMethod;		selector: aSymbol;		yourself! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass source: aString selector: aSelector 	^(self new)		modelClass: aRBClass;		selector: aSelector;		source: aString;		yourself! !!RBMethodName methodsFor: 'accessing'!arguments	^arguments! !!RBMethodName methodsFor: 'accessing'!arguments: nameCollection 	arguments := nameCollection.	self changed: #arguments! !!RBMethodName methodsFor: 'accessing'!moveArgument: aName before: anotherName 	arguments remove: aName ifAbsent: [^self].	arguments add: aName before: anotherName.	self changed: #arguments! !!RBMethodName methodsFor: 'accessing'!selector	^selector! !!RBMethodName methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol.	self changed: #selector! !!RBMethodName methodsFor: 'testing'!isValid	^(RBCondition checkMethodName: self selector in: self class) 		and: [self selector numArgs == self arguments size]! !!RBMethodName class methodsFor: 'instance creation'!selector: aSymbol arguments: stringCollection 	^(self new)		selector: aSymbol;		arguments: stringCollection;		yourself! !!RBNamespace methodsFor: 'private-changes'!addChangeToClass: aRBClass 	^changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass)! !!RBNamespace methodsFor: 'private-changes'!addClassVariable: aString to: aRBClass 	^changes addClassVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addInstanceVariable: aString to: aRBClass 	^changes addInstanceVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addPool: aString to: aRBClass 	^changes addPool: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!changeClass: aRBClass 	changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass).	self flushCaches! !!RBNamespace methodsFor: 'private-changes'!compile: aString in: aRBClass classified: aSymbol 	| change |	change := changes 				compile: aString				in: aRBClass				classified: aSymbol.	self flushCaches.	^change! !!RBNamespace methodsFor: 'private-changes'!flushCaches	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace methodsFor: 'private-changes'!performChange: aCompositeRefactoryChange around: aBlock 	| oldChanges |	changes addChange: aCompositeRefactoryChange.	oldChanges := changes.	changes := aCompositeRefactoryChange.	aBlock ensure: [changes := oldChanges].	^aCompositeRefactoryChange! !!RBNamespace methodsFor: 'private-changes'!removeClassVariable: aString from: aRBClass 	^changes removeClassVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeInstanceVariable: aString from: aRBClass 	^changes removeInstanceVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeMethod: aSelector from: aRBClass 	self flushCaches.	^changes removeMethod: aSelector from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!renameClassVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameClassVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'private-changes'!renameInstanceVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameInstanceVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'private-changes'!replaceClassNameIn: definitionString to: aSymbol 	| parseTree |	parseTree := RBParser parseExpression: definitionString.	parseTree receiver: (RBVariableNode named: aSymbol).	^parseTree formattedCode! !!RBNamespace methodsFor: 'accessing' stamp: 'mad 2/2/2007 10:22'!allClassesDo: aBlock 	| seen evalBlock |	seen := Set new.	evalBlock := 			[:each | 			seen add: each first name.			aBlock				value: each first;				value: each last].	newClasses do: evalBlock.	changedClasses do: evalBlock.	environment classesDo: 			[:each | 			(each isMeta or: [each isObsolete])				ifFalse: 					[((seen includes: each name) or: [self hasRemoved: (self classNameFor: each)]) 						ifFalse: 							[| class |							class := self classFor: each.							aBlock								value: class;								value: class metaclass]]]! !!RBNamespace methodsFor: 'accessing'!allImplementorsOf: aSelector 	^implementorsCache at: aSelector		ifAbsentPut: [self privateImplementorsOf: aSelector]! !!RBNamespace methodsFor: 'accessing'!allReferencesTo: aSymbol do: aBlock 	(sendersCache at: aSymbol		ifAbsentPut: 			[| refs |			refs := OrderedCollection new.			self allClassesDo: 					[:each | 					(each whichSelectorsReferToSymbol: aSymbol) 						do: [:sel | refs add: (each methodFor: sel)]].			refs]) 			do: aBlock! !!RBNamespace methodsFor: 'accessing'!allReferencesToClass: aRBClass do: aBlock 	self allClassesDo: 			[:each | 			(each whichSelectorsReferToClass: aRBClass) 				do: [:sel | aBlock value: (each methodFor: sel)]]! !!RBNamespace methodsFor: 'accessing'!changes	^changes! !!RBNamespace methodsFor: 'accessing'!environment	^environment! !!RBNamespace methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!RBNamespace methodsFor: 'accessing'!name	^changes name! !!RBNamespace methodsFor: 'accessing'!name: aString	^changes name: aString! !!RBNamespace methodsFor: 'accessing' stamp: 'bh 4/3/2000 15:47'!rootClasses	rootClasses isNil 		ifTrue: 			[rootClasses := OrderedCollection new.			Class rootsOfTheWorld do: 					[:each | 					| class |					class := self classFor: each.					(class notNil "and: [class superclass isNil] <- it's protoObject, not nil.") 						ifTrue: [rootClasses add: class]]].	^rootClasses! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'md 2/27/2006 00:51'!classFor: aBehavior 	| nonMetaclass class |	aBehavior isNil ifTrue: [^nil].	nonMetaclass := aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior].	class := aBehavior isMeta 		ifTrue: [self metaclassNamed: nonMetaclass name]		ifFalse: [self classNamed: nonMetaclass name].	^class ifNil: [nonMetaclass].! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'md 2/27/2006 00:55'!classNamed: aSymbol 	| class index classes |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) 		ifTrue: [^(newClasses at: aSymbol) first].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) first].	(class := environment at: aSymbol ifAbsent: [nil]) isBehavior 		ifTrue: 			[classes := self createNewClassFor: class.			^class isMeta ifTrue: [classes last] ifFalse: [classes first]].	(class := environment at: aSymbol ifAbsent: [nil]) isTrait 		ifTrue: 			[classes := self createNewClassFor: class.			^classes first].	index := aSymbol 				indexOfSubCollection: ' class'				startingAt: 1				ifAbsent: [^nil].	class := self classNamed: (aSymbol copyFrom: 1 to: index - 1) asSymbol.	^class isNil ifTrue: [nil] ifFalse: [class metaclass]! !!RBNamespace methodsFor: 'accessing-classes'!createNewClassFor: aBehavior 	| nonMeta meta className |	className := (aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior]) name.	nonMeta := (RBClass existingNamed: className)				model: self;				yourself.	meta := (RBMetaclass existingNamed: className)				model: self;				yourself.	^changedClasses at: className put: (Array with: nonMeta with: meta)! !!RBNamespace methodsFor: 'accessing-classes'!metaclassNamed: aSymbol 	| class |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) ifTrue: [^(newClasses at: aSymbol) last].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) last].	(class := environment at: aSymbol ifAbsent: [nil]) isBehavior 		ifTrue: [^(self createNewClassFor: class) last].	^nil! !!RBNamespace methodsFor: 'accessing-classes'!whichCategoryIncludes: aSymbol	^self environment whichCategoryIncludes: aSymbol! !!RBNamespace methodsFor: 'private'!classNameFor: aBehavior 	^(aBehavior isMeta ifTrue: [aBehavior soleInstance] ifFalse: [aBehavior]) 		name! !!RBNamespace methodsFor: 'private'!hasCreatedClassFor: aBehavior 	| className |	className := self classNameFor: aBehavior.	^(newClasses includesKey: className) 		or: [changedClasses includesKey: className]! !!RBNamespace methodsFor: 'private'!privateImplementorsOf: aSelector 	| classes |	classes := Set new.	self allClassesDo: 			[:each | 			(each directlyDefinesMethod: aSelector) ifTrue: [classes add: each]].	^classes! !!RBNamespace methodsFor: 'changes' stamp: 'jws 10/30/2016 22:56'!defineClass: aString 	| change newClass newClassName |	change := changes defineClass: aString.	newClassName := change changeClassName.	newClass := self classNamed: newClassName.	newClass isNil 		ifTrue: 			[| newMetaclass |			removedClasses				remove: newClassName ifAbsent: [];				remove: newClassName , ' class' ifAbsent: [].			newClass := RBClass named: newClassName.			newMetaclass := RBMetaclass named: newClassName.			newClass model: self.			newMetaclass model: self.			newClasses at: newClassName put: (Array with: newClass with: newMetaclass)].	newClass superclass: (self classNamed: change superclassName).	newClass superclass isNil 		ifTrue: 			[self rootClasses add: newClass.			newClass metaclass superclass: (self classFor: Object class superclass)]		ifFalse: [newClass metaclass superclass: newClass superclass metaclass].	newClass instanceVariableNames: change instanceVariableNames.	newClass classVariableNames: change classVariableNames.	newClass poolDictionaryNames: change poolDictionaryNames.	newClass category: change category.	^change! !!RBNamespace methodsFor: 'changes'!removeClass: aRBClass 	self removeClassNamed: aRBClass name! !!RBNamespace methodsFor: 'changes'!removeClassNamed: aSymbol 	(self classNamed: aSymbol) subclasses 		do: [:each | self removeClassNamed: each name].	removedClasses		add: aSymbol;		add: aSymbol , ' class'.	newClasses removeKey: aSymbol ifAbsent: [].	changedClasses removeKey: aSymbol ifAbsent: [].	self flushCaches.	^changes removeClassNamed: aSymbol! !!RBNamespace methodsFor: 'changes'!renameClass: aRBClass to: aSymbol around: aBlock 	| change value dict |	change := RenameClassChange rename: aRBClass name to: aSymbol.	self performChange: change around: aBlock.	self flushCaches.	dict := (newClasses includesKey: aSymbol) 				ifTrue: [newClasses]				ifFalse: [changedClasses].	removedClasses		add: aRBClass name;		add: aRBClass name , ' class'.	value := dict at: aRBClass name.	dict removeKey: aRBClass name.	dict at: aSymbol put: value.	value first name: aSymbol.	value last name: aSymbol.	value first subclasses do: [:each | each superclass: value first].	value last subclasses do: [:each | each superclass: value last].	^change! !!RBNamespace methodsFor: 'changes'!reparentClasses: aRBClassCollection to: newClass 	aRBClassCollection do: 			[:aClass | 			self defineClass: (self replaceClassNameIn: aClass definitionString						to: newClass name)]! !!RBNamespace methodsFor: 'testing'!hasRemoved: aSymbol 	^removedClasses includes: aSymbol! !!RBNamespace methodsFor: 'testing'!includesClassNamed: aSymbol 	^(self classNamed: aSymbol) notNil! !!RBNamespace methodsFor: 'testing'!includesGlobal: aSymbol 	(self hasRemoved: aSymbol) ifTrue: [^false].	(self includesClassNamed: aSymbol) ifTrue: [^true].	environment at: aSymbol ifAbsent: [^false].	^true! !!RBNamespace methodsFor: 'initialize-release'!initialize	changes := CompositeRefactoryChange new.	environment := BrowserEnvironment new.	newClasses := IdentityDictionary new.	changedClasses := IdentityDictionary new.	removedClasses := Set new.	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace class methodsFor: 'instance creation'!onEnvironment: aBrowserEnvironment 	^(self new)		environment: aBrowserEnvironment;		yourself! !!RBNegationCondition methodsFor: 'checking'!check	^condition check not! !!RBNegationCondition methodsFor: 'initialize-release'!condition: aCondition 	condition := aCondition.	self errorMacro: condition errorMacro! !!RBNegationCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^condition errorBlockFor: aBoolean not! !!RBNegationCondition methodsFor: 'private'!errorStringFor: aBoolean 	^condition errorStringFor: aBoolean not! !!RBNegationCondition methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'NOT ';		print: condition! !!RBNegationCondition class methodsFor: 'instance creation'!on: aCondition	^self new condition: aCondition! !!RBParseTreeRule methodsFor: 'matching'!canMatch: aProgramNode 	^true! !!RBParseTreeRule methodsFor: 'matching'!foundMatchFor: aProgramNode	^aProgramNode! !!RBParseTreeRule methodsFor: 'matching' stamp: 'jws 10/30/2016 23:08'!performOn: aProgramNode 	self context removeAll.	^((searchTree match: aProgramNode inContext: self context) 		and: [self canMatch: aProgramNode]) 			ifTrue:				[owner recusivelySearchInContext.				self foundMatchFor: aProgramNode]			ifFalse: [nil]					! !!RBParseTreeRule methodsFor: 'initialize-release'!methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString! !!RBParseTreeRule methodsFor: 'initialize-release'!owner: aParseTreeSearcher	owner := aParseTreeSearcher! !!RBParseTreeRule methodsFor: 'initialize-release'!searchString: aString 	searchTree := RBParser parseRewriteExpression: aString! !!RBParseTreeRule methodsFor: 'accessing'!sentMessages	^searchTree sentMessages! !!RBParseTreeRule methodsFor: 'private'!context	^owner context! !!RBParseTreeRule class methodsFor: 'instance creation'!methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself! !!RBParseTreeRule class methodsFor: 'instance creation'!search: aString 	^(self new)		searchString: aString;		yourself! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:49'!arrayNodeClass	^ RBArrayNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:49'!assignmentNodeClass	^ RBAssignmentNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:49'!blockNodeClass	^ RBBlockNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:49'!cascadeNodeClass	^ RBCascadeNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!literalArrayNodeClass	^ RBLiteralArrayNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!literalNodeClass	^ RBLiteralNode! !!RBParser methodsFor: 'private-classes' stamp: 'PabloHerrero 10/25/2013 17:21'!literalValueNodeClass	^ RBLiteralValueNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!messageNodeClass	^ RBMessageNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!methodNodeClass	^ RBMethodNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/9/2009 21:08'!pragmaNodeClass	^ RBPragmaNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!returnNodeClass	^ RBReturnNode! !!RBParser methodsFor: 'private-classes' stamp: 'CamilloBruni 8/23/2011 16:12'!selfNodeClass	^ RBSelfNode! !!RBParser methodsFor: 'private-classes' stamp: 'lr 11/1/2009 19:50'!sequenceNodeClass	^ RBSequenceNode! !!RBParser methodsFor: 'private-classes' stamp: 'CamilloBruni 8/23/2011 16:12'!superNodeClass	^ RBSuperNode! !!RBParser methodsFor: 'private-classes' stamp: 'CamilloBruni 8/30/2011 17:03'!thisContextNodeClass	^ RBThisContextNode! !!RBParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:15'!variableNodeClass	^ RBVariableNode! !!RBParser methodsFor: 'private'!addCommentsTo: aNode	aNode comments: aNode comments , comments.	comments := OrderedCollection new! !!RBParser methodsFor: 'private' stamp: 'ClementBera 7/26/2013 17:09'!addPragma: aPragma	pragmas ifNil: [ pragmas := OrderedCollection new ].	pragmas addLast: aPragma! !!RBParser methodsFor: 'private' stamp: 'PabloHerrero 11/7/2013 17:03'!extractCommentsFrom: aToken 	aToken comments 		collect: [:interval |			"RBComment from: interval first to: interval last" 			RBComment with: (source copyFrom: (interval first + 1) to: (interval last - 1)) at: interval first]		into: comments! !!RBParser methodsFor: 'private' stamp: 'ClementBera 7/26/2013 17:09'!nextToken	^nextToken ifNil: [nextToken := scanner next] ifNotNil: [nextToken]! !!RBParser methodsFor: 'private' stamp: 'lr 11/1/2009 20:03'!patchLiteralArrayToken	(currentToken isIdentifier and: 			[self nextToken isAssignment 				and: [currentToken stop + 1 = self nextToken start]]) 		ifTrue: 			[currentToken := RBLiteralToken 						value: (currentToken value , ':') asSymbol						start: currentToken start						stop: self nextToken start.			nextToken := RBLiteralToken 						value: #=						start: nextToken stop						stop: nextToken stop.			^self].	currentToken isAssignment 		ifTrue: 			[currentToken := RBLiteralToken 						value: #':'						start: currentToken start						stop: currentToken start.			nextToken := RBLiteralToken 						value: #=						start: currentToken stop						stop: currentToken stop.			^self].	currentToken isSpecial 		ifTrue: 			[currentToken := RBLiteralToken 						value: (String with: currentToken value) asSymbol						start: currentToken start						stop: currentToken stop.			^self].	(currentToken isIdentifier and: [currentToken value includes: $.]) 		ifTrue: 			[currentToken := RBLiteralToken 						value: currentToken value						start: currentToken start						stop: currentToken stop.			^self].	(currentToken isIdentifier 		or: [currentToken isBinary or: [currentToken isKeyword]]) 			ifFalse: [^self parserError: 'Invalid token'].	currentToken := RBLiteralToken 				value: currentToken value asSymbol				start: currentToken start				stop: currentToken stop! !!RBParser methodsFor: 'private'!patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value == nil 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]! !!RBParser methodsFor: 'private' stamp: 'lr 11/2/2009 23:37'!patchNegativeLiteral	"Handle the special negative number case for binary message sends."	currentToken value isNumber 		ifFalse: [^self].	currentToken value <= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source notEmpty 						and: [(source at: (currentToken start min: source size)) = $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	(nextToken isKindOf: RBNumberLiteralToken) 		ifTrue: 			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].	nextToken start: nextToken start + 1! !!RBParser methodsFor: 'private' stamp: 'PabloHerrero 11/7/2013 10:36'!step	(currentToken notNil and: [currentToken comments notNil]) 		ifTrue: [self extractCommentsFrom: currentToken].	nextToken notNil 		ifTrue: 			[currentToken := nextToken.			nextToken := nil]		ifFalse: [currentToken := scanner next].! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 11/13/2012 10:12'!basicParsePragma	^ currentToken isIdentifier		ifTrue: [ self parseUnaryPragma ]		ifFalse: [			currentToken isKeyword				ifTrue: [ self parseKeywordPragma ]				ifFalse: [ self parseBinaryPragma ] ]! !!RBParser methodsFor: 'private-parsing'!parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].	^args! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:36'!parseArray	| position node |	position := currentToken start.	self step.	node := self arrayNodeClass new.	node left: position.	self parseStatementList: false  into: node.	(currentToken isSpecial and: [currentToken value = $}]) 		ifFalse: [ ^ self parserError: 'expected }'].	node right: currentToken start.	self step.	^ node! !!RBParser methodsFor: 'private-parsing'!parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^self assignmentNodeClass 		variable: node		value: self parseAssignment		position: position! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/20/2013 05:14'!parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^self messageNodeClass 		receiver: aNode		selector:  binaryToken value		keywordsPositions: (Array with: binaryToken start)		arguments: (Array with: self parseUnaryMessage)! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 11/18/2013 19:13'!parseBinaryPattern	| binaryToken node args |	currentToken isBinary		ifFalse: [ ^ self parserError: 'Message pattern expected'].	binaryToken := currentToken.	self step.	args := Array with: self parseVariableNode.	node := self methodNodeClass		selector: binaryToken value asSymbol		keywordsPositions: (Array with: binaryToken start)		arguments: args.	node comments: node comments , args last comments.	args last comments ifNotEmpty: [ args last comments: #() ].	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/21/2013 15:52'!parseBinaryPragma	| binaryToken |	currentToken isBinary 		ifFalse: [ ^ self parserError: 'Message pattern expected' ].	binaryToken := currentToken.	self step.	^ self pragmaNodeClass		selector: binaryToken value asSymbol		keywordsPositions: (Array with: binaryToken start)		arguments: (Array with: self parsePragmaLiteral)! !!RBParser methodsFor: 'private-parsing' stamp: 'GiselaDecuzzi 6/3/2013 16:09'!parseBlock	| position node |	position := currentToken start.	self step.	node := self blockNodeClass new. 	self parseBlockArgsInto: node.	node left: position.	node body: self sequenceNodeClass new.	(self parseStatements: false into: node body).		(currentToken isSpecial and: [currentToken value = $]])		ifFalse: [^ self parserError: ''']'' expected' translated].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseBlockArgsInto: node 	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value = $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar 		ifTrue: 			[currentToken isBinary 				ifTrue: 					[node bar: currentToken start.					currentToken value = #| 						ifTrue: [self step]						ifFalse: 							[currentToken value = #'||' 								ifTrue: 									["Hack the current token to be the start 									of temps bar"									currentToken										value: #|;										start: currentToken start + 1]								ifFalse: [ ^ self parserError: '''|'' expected']]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value = $]]) 						ifFalse: [ ^ self parserError: '''|'' expected']]].	node		arguments: args;		colons: colons.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial 		and: [currentToken value = $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value = $;]] whileTrue: 			[semicolons add: currentToken start.			self step.			messages add: (currentToken isIdentifier 						ifTrue: [self parseUnaryMessageWith: receiver]						ifFalse: 							[currentToken isKeyword 								ifTrue: [self parseKeywordMessageWith: receiver]								ifFalse: 									[| temp |									currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].									currentToken isBinary ifFalse: [ ^ self parserError: 'Message expected'].									temp := self parseBinaryMessageWith: receiver.									temp == receiver ifTrue: [ ^ self parserError: 'Message expected'].									temp]])].	^self cascadeNodeClass messages: messages semicolons: semicolons! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 2/16/2015 00:45'!parseKeywordMessageWith: node 	| args isKeyword keywordsStartPositions selector|	args := OrderedCollection new: 3.	keywordsStartPositions := OrderedCollection new: 3.	selector := String new.		isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywordsStartPositions add: currentToken start.			selector := selector, currentToken value.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword		ifTrue: 			[self messageNodeClass 				receiver: node				selector: selector				keywordsPositions: keywordsStartPositions				arguments: args]		ifFalse: [node]! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 11/18/2013 19:13'!parseKeywordPattern	| selector positions args node |	selector := ''.	positions := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword]		whileTrue:			[selector := selector, currentToken value.			 positions add: currentToken start.			self step.			args add: self parseVariableNode].	node := self methodNodeClass		selector: selector asSymbol		keywordsPositions: positions asIntegerArray		arguments: args.	node comments: (node comments, args last comments).	args last comments ifNotEmpty: [ args last comments: #() ].	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/21/2013 15:59'!parseKeywordPragma	| selector positions arguments |	selector := ''.	positions := OrderedCollection new: 2.	arguments := OrderedCollection new: 2.	[ currentToken isKeyword ] whileTrue: [		selector := selector, currentToken value.		positions add: currentToken start.		self step.		arguments addLast: self parsePragmaLiteral ].	^ self pragmaNodeClass		selector: selector asSymbol		keywordsPositions: positions asIntegerArray		arguments: arguments.! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseLiteralArray	| stream start stop |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 		whileFalse: [stream nextPut: self parseLiteralArrayObject].	(currentToken isSpecial and: [currentToken value = $)]) 		ifFalse: [ ^ self parserError: ''')'' expected'].	stop := currentToken stop.	self step.	^self literalArrayNodeClass 		startPosition: start		contents: stream contents		stopPosition: stop		isByteArray: false! !!RBParser methodsFor: 'private-parsing' stamp: 'lr 11/2/2009 23:37'!parseLiteralArrayObject	currentToken isSpecial 		ifTrue: 			[currentToken value = $( ifTrue: [^self parseLiteralArray].			"currentToken value == $[ ifTrue: [^self parseLiteralByteArray]"].	currentToken isLiteralArrayToken 		ifTrue: 			[^currentToken isForByteArray 				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isLiteralToken ifFalse: [self patchLiteralArrayToken].	^self parsePrimitiveLiteral! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseLiteralByteArray	| stream start stop |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $]]]] 		whileFalse: [stream nextPut: self parseLiteralByteArrayObject].	(currentToken isSpecial and: [currentToken value = $]]) 		ifFalse: [^ self parserError: ''']'' expected'].	stop := currentToken stop.	self step.	^self literalArrayNodeClass 		startPosition: start		contents: stream contents		stopPosition: stop		isByteArray: true! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseLiteralByteArrayObject	(currentToken isLiteralToken and: 			[currentToken value isInteger and: [currentToken value between: 0 and: 255]]) 		ifFalse: [ ^ self parserError: 'Expecting 8-bit integer'].	^self parsePrimitiveLiteral! !!RBParser methodsFor: 'private-parsing'!parseMessagePattern	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	^currentToken isIdentifier 		ifTrue: [self parseUnaryPattern]		ifFalse: 			[currentToken isKeyword 				ifTrue: [self parseKeywordPattern]				ifFalse: [self parseBinaryPattern]]! !!RBParser methodsFor: 'private-parsing' stamp: 'ClementBera 7/26/2013 17:10'!parseMethod	| methodNode | 	methodNode := self parseMessagePattern.	self parsePragmas.	self addCommentsTo: methodNode.		methodNode body: self sequenceNodeClass new.	(self parseStatements: false into: methodNode body).		pragmas ifNotNil: [ methodNode pragmas: pragmas ].	^methodNode! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 2/16/2015 01:25'!parseNegatedNumber	(self nextToken isLiteralToken not or: [ self nextToken realValue isNumber not ])		ifTrue: [ ^ self parserError: 'The ''-'' prefix works only for literal numbers (use #negated instead)' ].	self step; step.	^ self literalValueNodeClass 			 	value: self nextToken realValue negated 				start: currentToken start 				stop: nextToken stop 				source: currentToken value, nextToken source.! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 2/16/2015 01:25'!parseNumberLiteral	| token |	token := currentToken.	self step.		^self literalValueNodeClass 		value: token value 		start: token start		stop: token stop		source: token source	! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	^(currentToken isSpecial and: [currentToken value = $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step.			node]		ifFalse: [ self parserError: ''')'' expected']! !!RBParser methodsFor: 'private-parsing' stamp: 'ClementBEra 1/30/2013 15:06'!parsePragma	| start pragma |	start := currentToken start.	self step.	pragma := self basicParsePragma.	(currentToken isBinary and: [ currentToken value == #> ]) 		ifFalse: [ ^ self parserError: '''>'' expected' ].	pragma left: start; right: currentToken start.	self addPragma: pragma.! !!RBParser methodsFor: 'private-parsing' stamp: 'lr 5/30/2010 14:40'!parsePragmaLiteral	^ self parseLiteralArrayObject! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 11/13/2012 10:22'!parsePragmas	[ currentToken isBinary and: [ currentToken value = #< ] ] whileTrue: [		self parsePragma.		self step ]! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/23/2013 16:16'!parsePrimitiveIdentifier	| token node |	token := currentToken.	self step.	node := self variableNodeClass identifierNamed: token value at: token start.	self addCommentsTo: node.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/28/2013 18:17'!parsePrimitiveLiteral	currentToken isNumberLiteralToken		ifTrue: [ ^ self parseNumberLiteral ]		ifFalse: [ ^ self parsePrimitiveValueLiteral ]! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/28/2013 14:12'!parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	(currentToken isLiteralToken and: [currentToken isMultiKeyword not]) 		ifTrue: [^self parsePrimitiveLiteral].	currentToken isLiteralArrayToken		ifTrue: 			[^currentToken isForByteArray 				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isSpecial		ifTrue: 			[currentToken value = $[ ifTrue: [^self parseBlock].			currentToken value = $( ifTrue: [^self parseParenthesizedExpression].			currentToken value = ${ ifTrue: [^self parseArray]].	(currentToken isBinary and: [ currentToken value = #- ]) 		ifTrue: [ ^self parseNegatedNumber ].	^ self parserError: 'Variable or expression expected'! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/28/2013 14:29'!parsePrimitiveValueLiteral	| token |	token := currentToken.	self step.	^self literalValueNodeClass 		value: token value 		start: token start		stop: token stop	! !!RBParser methodsFor: 'private-parsing' stamp: 'MarcusDenker 3/27/2014 11:08'!parseStatementList: pragmaBoolean into: sequenceNode 	| statements return periods returnPosition node |	return := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addCommentsTo: sequenceNode.	pragmaBoolean ifTrue: [self parsePragmas].	[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 		[periods add: currentToken start.		self step].	[self atEnd 		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 			whileFalse: [				return ifTrue: [ 					(self parserError: 'End of statement list encountered') 						ifNotNil: [ :errorNode | 								statements add: errorNode. 								sequenceNode statements: statements.								sequenceNode periods: periods.								self step.								^sequenceNode]					].				(currentToken isSpecial and: [currentToken value = $^]) 					ifTrue: 						[returnPosition := currentToken start.						self step.						node := self returnNodeClass return: returnPosition									value: self parseAssignment.						statements add: node.						return := true]					ifFalse: [						"check for pragmas"						(currentToken isBinary and: [ currentToken value == #<])							ifTrue: [ self parsePragma ]							ifFalse: [								node := self parseAssignment.								statements add: node ]].				(currentToken isSpecial and: [currentToken value = $.]) 					ifTrue: 						[periods add: currentToken start.						self step.						self addCommentsTo: node]					ifFalse: [						"check for closing pragmas"						(currentToken isBinary and: [ currentToken value == #>])							ifFalse: [ return := true ]							ifTrue: [ self step ]].				[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 					[periods add: currentToken start.					self step]				].	statements notEmpty ifTrue: [self addCommentsTo: statements last].	sequenceNode		statements: statements;		periods: periods.	^sequenceNode! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 12/15/2011 16:41'!parseStatements: pragmaBoolean	^ self parseStatements: pragmaBoolean into: self sequenceNodeClass new! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 11/8/2012 16:01'!parseStatements: pragmaBoolean into: aSequenceNode	| temps leftBar rightBar |	temps := #().	leftBar := rightBar := nil.	currentToken isBinary 		ifTrue: 			[currentToken value = #| 				ifTrue: 					[leftBar := currentToken start.					self step.					temps := self parseTemps.					(currentToken isBinary and: [currentToken value = #|]) 						ifFalse: [ ^ self parserError: '''|'' expected'].					rightBar := currentToken start.					self step]				ifFalse: 					[currentToken value = #'||' 						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	^self parseStatementList: pragmaBoolean		into: (aSequenceNode 				leftBar: leftBar				temporaries: temps				rightBar: rightBar)! !!RBParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 12/15/2011 16:18'!parseTemps	| temps |	temps := OrderedCollection new.	[currentToken isIdentifier] whileTrue: [temps add: self parsePrimitiveIdentifier].	^temps! !!RBParser methodsFor: 'private-parsing'!parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addCommentsTo: node.	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addCommentsTo: node.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/20/2013 05:12'!parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^self messageNodeClass		receiver: aNode		selector:  selector value		keywordsPositions: (Array with: selector start)		arguments: #()! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/21/2013 15:52'!parseUnaryPattern	| selector |	selector := currentToken.	self step.	^self methodNodeClass selector: selector value asSymbol keywordsPositions: (Array with: selector start) arguments: #()! !!RBParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/21/2013 15:52'!parseUnaryPragma	| selector |	selector := currentToken.	self step.	^ self pragmaNodeClass selector: selector value asSymbol keywordsPositions: (Array with: selector start) arguments: #()! !!RBParser methodsFor: 'private-parsing' stamp: 'GiselaDecuzzi 6/3/2013 16:08'!parseVariableNode	currentToken isIdentifier 		ifFalse: [ ^ self parserError: 'Variable name expected' translated].	^self parsePrimitiveIdentifier! !!RBParser methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]! !!RBParser methodsFor: 'accessing' stamp: 'GiselaDecuzzi 6/10/2013 11:42'!initializeParserWith: aString 	source := aString.	self scanner: (self scannerClass on: (ReadStream on: aString))		! !!RBParser methodsFor: 'accessing' stamp: 'CamilloBruni 10/31/2012 18:37'!parseExpression: aString 	| node |	node := self parseStatements: false.	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"	self atEnd ifFalse: [ ^ self parserError: 'Unknown input at end'].	^node! !!RBParser methodsFor: 'accessing' stamp: 'MarcusDenker 5/17/2013 14:15'!parseLiterals: aString 	| stream |	stream := WriteStream on: (Array new: 5).	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 		whileFalse: [stream nextPut: self parseLiteralArrayObject].		self atEnd ifFalse: [ ^ self parserError: 'Unknown input at end'].		^stream contents collect: [ :each | each value ]! !!RBParser methodsFor: 'accessing' stamp: 'GiselaDecuzzi 5/27/2013 18:55'!parseMethod: aString	| node errorNode |	node := self parseMethod.	self atEnd		ifFalse: [ 			errorNode := self parserError: 'Unknown input at end'.			errorNode ifNotNil: [ node statements: node statements, {errorNode }] ].	node source: aString.	^ node! !!RBParser methodsFor: 'accessing'!scannerClass	^RBScanner! !!RBParser methodsFor: 'error handling' stamp: 'ClementBera 7/26/2013 17:09'!errorBlock	^errorBlock ifNil: [[:message :position | ]] ifNotNil: [errorBlock]! !!RBParser methodsFor: 'error handling' stamp: 'GiselaDecuzzi 6/5/2013 09:31'!errorPosition	^currentToken ifNotNil: [ :token | token start] ifNil:[1]! !!RBParser methodsFor: 'error handling' stamp: 'PabloHerrero 10/24/2013 11:21'!parseErrorNode: aMessageString	| token sourceString |	currentToken isError 		ifTrue: [ ^ RBParseErrorNode errorMessage: currentToken cause value: currentToken value at: currentToken start ].	sourceString := source copyFrom: self errorPosition to: source size.	token := RBValueToken value: sourceString start: self errorPosition.	^ RBParseErrorNode		errorMessage: aMessageString value: token value at: token start! !!RBParser methodsFor: 'error handling' stamp: 'GiselaDecuzzi 6/10/2013 15:53'!parserError: aString 	"Let the errorBlock try to recover from the error."	| errorNode errorMessage errorPosition |	errorNode := self errorBlock cull: aString cull: self errorPosition cull: self.	errorNode ifNotNil: [ ^ errorNode ].	currentToken isError 		ifTrue: [ errorMessage := currentToken cause. errorPosition := currentToken location ] 		ifFalse: [errorMessage := aString. errorPosition := currentToken start].	SyntaxErrorNotification					inClass: Object					category: nil					withCode: source					doitFlag: false					errorMessage: errorMessage					location: errorPosition! !!RBParser methodsFor: 'testing'!atEnd	^currentToken class == RBToken! !!RBParser methodsFor: 'initialization' stamp: 'lr 11/1/2009 19:17'!initialize	comments := OrderedCollection new! !!RBParser methodsFor: 'initialize-release' stamp: 'GiselaDecuzzi 6/5/2013 09:43'!scanner: aScanner 	scanner := aScanner.	pragmas := nil.	self initialize.	self step.! !!RBExplicitVariableParser methodsFor: 'scoping' stamp: 'CamilloBruni 12/15/2011 16:27'!popScope	currentScope := currentScope scope! !!RBExplicitVariableParser methodsFor: 'scoping' stamp: 'CamilloBruni 12/15/2011 16:27'!pushScope: aNode	aNode scope: currentScope.	currentScope := aNode! !!RBExplicitVariableParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 10/31/2012 18:38'!parseBlock	| position node |	position := currentToken start.	self step.	node := self blockNodeClass new. 	self pushScope: node.		self useVariable: RBArgumentNode during: [ self parseBlockArgsInto: node ].	node left: position.		node body: self sequenceNodeClass new.	(self parseStatements: false into: node body).		(currentToken isSpecial and: [currentToken value = $]])		ifFalse: [  ^ self parserError: ''']'' expected'].	node right: currentToken start.		self step.	self popScope.	^node! !!RBExplicitVariableParser methodsFor: 'private-parsing' stamp: 'ClementBera 7/26/2013 17:10'!parseMethod	| methodNode | 		self useVariable: RBArgumentNode during: [methodNode := self parseMessagePattern].		self pushScope: methodNode.		self parsePragmas.	self addCommentsTo: methodNode.		methodNode body: self sequenceNodeClass new.	(self parseStatements: false into: methodNode body).		pragmas ifNotNil: [ methodNode pragmas: pragmas ].	^methodNode! !!RBExplicitVariableParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/23/2013 16:16'!parsePrimitiveIdentifier	| token node |	token := currentToken.	self step.	node := (self lookupVariableNodeClass: token value) identifierNamed: token value at: token start.	self addCommentsTo: node.	^node! !!RBExplicitVariableParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 12/15/2011 16:17'!parseTemps	| args |	args := OrderedCollection new.	self useVariable: RBTemporaryNode during: [		[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode]].	^args! !!RBExplicitVariableParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:16'!argumentNodeClass	^ RBArgumentNode! !!RBExplicitVariableParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:35'!lookupVariableNodeClass: aName	| scope |		currentVariableNodeClass notNil ifTrue: [ ^ currentVariableNodeClass ].	scope := currentScope.	[ scope isNil ]  whileFalse: [		(scope hasTemporaryNamed: aName) ifTrue: [ ^ RBTemporaryNode ].		(scope hasArgumentNamed: aName) ifTrue: [ ^ RBArgumentNode ].		scope := scope scope.	].		^ RBVariableNode! !!RBExplicitVariableParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:16'!temporaryNodeClass	^ RBTemporaryNode! !!RBExplicitVariableParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:15'!useVariable: aVariableNodeClass during: aBlock	currentVariableNodeClass := aVariableNodeClass.	^ aBlock ensure: [ currentVariableNodeClass := nil]! !!RBExplicitVariableParser methodsFor: 'private-classes' stamp: 'CamilloBruni 12/15/2011 16:15'!variableNodeClass	^ currentVariableNodeClass ifNil: [ RBVariableNode ]! !!RBParser class methodsFor: 'accessing' stamp: 'GiselaDecuzzi 5/28/2013 13:22'!errorNodeBlock	^ [ :aString :position :parser| parser parseErrorNode: aString ]! !!RBParser class methodsFor: 'accessing' stamp: 'MarcusDenker 12/21/2012 12:13'!parseCompiledMethod: aCompiledMethod	^ self parseMethod: aCompiledMethod sourceCode! !!RBParser class methodsFor: 'parsing'!parseExpression: aString 	^self parseExpression: aString onError: nil! !!RBParser class methodsFor: 'parsing' stamp: 'GiselaDecuzzi 5/28/2013 15:09'!parseExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	node := parser parseExpression: aString.	^(node statements size == 1 and: [node temporaries isEmpty]) 		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'parsing' stamp: 'CamilloBruni 10/31/2012 19:08'!parseFaultyExpression: aString 	^self parseExpression: aString onError: self errorNodeBlock! !!RBParser class methodsFor: 'parsing' stamp: 'GiselaDecuzzi 6/5/2013 09:53'!parseFaultyMethod: aString 	^self parseMethod: aString onError: self errorNodeBlock! !!RBParser class methodsFor: 'parsing' stamp: 'MarcusDenker 5/17/2013 14:08'!parseLiterals: aString 	| parser |	parser := self new.	parser initializeParserWith: aString.	^parser parseLiterals: aString! !!RBParser class methodsFor: 'parsing'!parseMethod: aString 	^self parseMethod: aString onError: nil! !!RBParser class methodsFor: 'parsing' stamp: 'GiselaDecuzzi 5/28/2013 15:09'!parseMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	^parser parseMethod: aString! !!RBParser class methodsFor: 'parsing'!parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString.	^parser parseMessagePattern selector! !!RBParser class methodsFor: 'parsing'!parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil! !!RBParser class methodsFor: 'parsing'!parseRewriteExpression: aString onError: aBlock 	^RBPatternParser parseExpression: aString onError: aBlock! !!RBParser class methodsFor: 'parsing'!parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil! !!RBParser class methodsFor: 'parsing'!parseRewriteMethod: aString onError: aBlock 	^RBPatternParser parseMethod: aString onError: aBlock! !!RBPatternParser methodsFor: 'private-classes'!messageNodeClass	^RBPatternMessageNode! !!RBPatternParser methodsFor: 'private-classes'!methodNodeClass	^RBPatternMethodNode! !!RBPatternParser methodsFor: 'private-classes' stamp: 'lr 5/30/2010 09:44'!pragmaNodeClass	^RBPatternPragmaNode! !!RBPatternParser methodsFor: 'private-classes'!variableNodeClass	^RBPatternVariableNode! !!RBPatternParser methodsFor: 'accessing'!scannerClass	^RBPatternScanner! !!RBPatternParser methodsFor: 'private-parsing' stamp: 'StephaneDucasse 3/29/2013 17:16'!parseError: aString	self error: aString! !!RBPatternParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/23/2013 16:15'!parseLiteralByteArrayObject	| node |	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: 			[node := self variableNodeClass identifierNamed: currentToken value at: currentToken start.			node isLiteralNode 				ifTrue: 					[self step.					^node]].	^super parseLiteralByteArrayObject! !!RBPatternParser methodsFor: 'private-parsing' stamp: 'CamilloBruni 11/8/2012 16:00'!parsePatternBlock: aClass 	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: aClass new.	node left: position.		node body: self sequenceNodeClass new.	(self parseStatements: false into: node body).		(currentToken isSpecial and: [currentToken value = $}]) 		ifFalse: [ ^ self parserError: '''}'' expected'].	node right: currentToken start.	self step.	^node! !!RBPatternParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/23/2013 16:15'!parsePragmaLiteral	| node |	currentToken isPatternBlock 		ifTrue: [ ^ self parsePatternBlock: RBPatternBlockNode ].	(currentToken isIdentifier and: [ currentToken isPatternVariable ]) ifTrue: [		node := self variableNodeClass identifierNamed: currentToken value at: currentToken start.		node isLiteralNode 			ifFalse: [ self parseError: 'Literal pattern expected' ].		self step.		currentToken isPatternBlock ifTrue: [			node := (self parsePatternBlock: RBPatternWrapperBlockNode)				wrappedNode: node;				yourself ].		^ node ].	^ super parsePragmaLiteral! !!RBPatternParser methodsFor: 'private-parsing' stamp: 'PabloHerrero 10/25/2013 15:58'!parsePrimitiveLiteral	| node |	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: 			[node := self variableNodeClass identifierNamed: currentToken value at: currentToken start.			node isLiteralNode 				ifTrue: 					[self step.					^node].			currentToken := RBLiteralToken 						value: currentToken value asSymbol						start: currentToken start						stop: currentToken stop].	^super parsePrimitiveLiteral! !!RBPatternParser methodsFor: 'private-parsing'!parsePrimitiveObject	currentToken isPatternBlock 		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].	^super parsePrimitiveObject! !!RBPatternParser methodsFor: 'private-parsing'!parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addCommentsTo: node.		[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isPatternBlock 		ifTrue: 			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)						wrappedNode: node;						yourself].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addCommentsTo: node.	^node! !!RBPatternParser methodsFor: 'private'!patchLiteralArrayToken	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: [^self].	super patchLiteralArrayToken! !!RBProgramNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first bestNodeFor: anInterval]		ifFalse: [self]! !!RBProgramNode methodsFor: 'querying' stamp: 'jws 10/29/2016 09:11'!selfMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'querying'!statementNode	"Return your topmost node that is contained by a sequence node."	(parent isNil or: [parent isSequence]) ifTrue: [^self].	^parent statementNode! !!RBProgramNode methodsFor: 'querying' stamp: 'jws 10/29/2016 09:11'!superMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]		ifFalse: [nil]! !!RBProgramNode methodsFor: 'querying'!whoDefines: aName 	^(self defines: aName) 		ifTrue: [self]		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]! !!RBProgramNode methodsFor: 'properties' stamp: 'lr 10/18/2009 17:19'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!RBProgramNode methodsFor: 'properties' stamp: 'lr 12/29/2009 12:45'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!RBProgramNode methodsFor: 'properties' stamp: 'ClementBera 7/26/2013 17:12'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties 		ifNil: [ aBlock value ]		ifNotNil: [ properties at: aKey ifAbsent: aBlock ]! !!RBProgramNode methodsFor: 'properties' stamp: 'lr 12/29/2009 12:45'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!RBProgramNode methodsFor: 'properties' stamp: 'jws 10/29/2016 09:10'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!RBProgramNode methodsFor: 'properties' stamp: 'md 3/29/2007 14:51'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].! !!RBProgramNode methodsFor: 'properties' stamp: 'ClementBera 7/26/2013 17:12'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties ifNil: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!RBProgramNode methodsFor: 'accessing'!allArgumentVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allArgumentVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!allDefinedVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allDefinedVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!allTemporaryVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allTemporaryVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:10'!asReturn	"Change the current node to a return node."	parent ifNil: [self error: 'Cannot change to a return without a parent node.'].	parent isSequence 		ifFalse: [self error: 'Parent node must be a sequence node.'].	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].	^parent addReturn! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:10'!blockVariables	^parent ifNil: [#()] ifNotNil: [parent blockVariables]! !!RBProgramNode methodsFor: 'accessing'!children	^#()! !!RBProgramNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/19/2013 01:55'!comments	"Answer the comments of the receiving parse tree node"		^ (self propertyAt: #comments ifAbsent: [ #() ]) ifNil:[ #() ]! !!RBProgramNode methodsFor: 'accessing' stamp: 'PabloHerrero 3/7/2015 21:00'!comments: aCollection	(aCollection ifNil: #())		ifEmpty: [ self removeProperty: #comments ifAbsent: [] ] 		ifNotEmpty: [ self propertyAt: #comments put: aCollection ].! !!RBProgramNode methodsFor: 'accessing' stamp: 'MarcusDenker 12/17/2012 15:53'!debugHighlightRange	^ self debugHighlightStart to: self debugHighlightStop .! !!RBProgramNode methodsFor: 'accessing'!debugHighlightStart	^ self start ! !!RBProgramNode methodsFor: 'accessing'!debugHighlightStop	^ self stop ! !!RBProgramNode methodsFor: 'accessing' stamp: 'lr 3/26/2010 17:29'!formattedCode	^ self formatterClass new format: self! !!RBProgramNode methodsFor: 'accessing' stamp: 'lr 3/26/2010 17:29'!formatterClass	^ self class formatterClass! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:11'!mappingFor: aNode	| method |	method := self methodNode.	method ifNil: [^aNode].	^method mappingFor: aNode! !!RBProgramNode methodsFor: 'accessing'!methodComments	^self comments! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:12'!methodNode	^parent ifNotNil: [parent methodNode]! !!RBProgramNode methodsFor: 'accessing'!newSource	^self formattedCode! !!RBProgramNode methodsFor: 'accessing'!parent	^parent! !!RBProgramNode methodsFor: 'accessing'!parent: aRBProgramNode 	parent := aRBProgramNode! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:12'!parents	^ parent 		ifNil: [ OrderedCollection with: self ]		ifNotNil: [ 			parent parents				addLast: self;				yourself ]! !!RBProgramNode methodsFor: 'accessing'!precedence	^6! !!RBProgramNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:22'!sentMessages	^ self children		inject: Set new		into: [ :messages :each | 			messages				addAll: each sentMessages;				yourself ]! !!RBProgramNode methodsFor: 'accessing'!source	^parent notNil ifTrue: [parent source] ifFalse: [nil]! !!RBProgramNode methodsFor: 'accessing' stamp: 'MarkRizun 10/20/2014 18:39'!sourceInterval	^ self start to: self stop! !!RBProgramNode methodsFor: 'accessing'!start	self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/7/2013 11:13'!statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	self children do: [:each | statementComments addAll: each statementComments].	^statementComments asSortedCollection: [:a :b | a start < b start]! !!RBProgramNode methodsFor: 'accessing'!stop	self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:13'!temporaryVariables	^parent ifNil: [#()] ifNotNil: [parent temporaryVariables]! !!RBProgramNode methodsFor: 'testing'!assigns: aVariableName 	^self children anySatisfy: [:each | each assigns: aVariableName]! !!RBProgramNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self start and: [anInterval last >= self stop]! !!RBProgramNode methodsFor: 'testing'!containsReturn	^self children anySatisfy: [:each | each containsReturn]! !!RBProgramNode methodsFor: 'testing'!defines: aName	^false! !!RBProgramNode methodsFor: 'testing'!directlyUses: aNode	^true! !!RBProgramNode methodsFor: 'testing'!evaluatedFirst: aNode 	self children do: 			[:each | 			each == aNode ifTrue: [^true].			each isImmediateNode ifFalse: [^false]].	^false! !!RBProgramNode methodsFor: 'testing'!hasMultipleReturns	| count |	count := 0.	self nodesDo: [:each | each isReturn ifTrue: [count := count + 1]].	^count > 1! !!RBProgramNode methodsFor: 'testing'!intersectsInterval: anInterval 	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]! !!RBProgramNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:31'!isArgument	^false! !!RBProgramNode methodsFor: 'testing'!isAssignment	^false! !!RBProgramNode methodsFor: 'testing'!isCascade	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'ClementBera 7/26/2013 17:11'!isDirectlyUsed	"This node is directly used as an argument, receiver, or part of an assignment."	^parent ifNil: [false] ifNotNil: [parent directlyUses: self]! !!RBProgramNode methodsFor: 'testing'!isEvaluatedFirst	"Return true if we are the first thing evaluated in this statement."	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]! !!RBProgramNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:27'!isFaulty	self subclassResponsibility! !!RBProgramNode methodsFor: 'testing'!isImmediateNode	^false! !!RBProgramNode methodsFor: 'testing'!isLast: aNode 	| children |	children := self children.	^children notEmpty and: [children last == aNode]! !!RBProgramNode methodsFor: 'testing'!isLiteralArray	^false! !!RBProgramNode methodsFor: 'testing'!isLiteralNode	^false! !!RBProgramNode methodsFor: 'testing'!isMessage	^false! !!RBProgramNode methodsFor: 'testing'!isMethod	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'lr 10/27/2009 14:33'!isPragma	^false! !!RBProgramNode methodsFor: 'testing'!isReturn	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:32'!isSelf	^ false! !!RBProgramNode methodsFor: 'testing'!isSequence	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'MarcusDenker 6/27/2013 16:59'!isSuper	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:32'!isTemp	^ false! !!RBProgramNode methodsFor: 'testing' stamp: 'ClementBera 7/26/2013 17:11'!isUsed	"Answer true if this node could be used as part of another expression. For example, you could use the 	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 	return values of blocks."	^parent ifNil: [false] ifNotNil: [parent uses: self]! !!RBProgramNode methodsFor: 'testing'!isValue	^false! !!RBProgramNode methodsFor: 'testing'!isVariable	^false! !!RBProgramNode methodsFor: 'testing'!lastIsReturn	^self isReturn! !!RBProgramNode methodsFor: 'testing'!references: aVariableName 	^self children anySatisfy: [:each | each references: aVariableName]! !!RBProgramNode methodsFor: 'testing'!uses: aNode	^true! !!RBProgramNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:30'!copyInContext: aDictionary	^ self copy! !!RBProgramNode methodsFor: 'matching'!copyList: matchNodes inContext: aDictionary 	| newNodes |	newNodes := OrderedCollection new.	matchNodes do: 			[:each | 			| object |			object := each copyInContext: aDictionary.			newNodes addAll: object].	^newNodes! !!RBProgramNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:40'!match: aNode inContext: aDictionary 	^ self = aNode! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes against: programNodes inContext: aDictionary 	^self		matchList: matchNodes		index: 1		against: programNodes		index: 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size < currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary 											keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size < programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'replacing' stamp: 'ClementBera 7/26/2013 17:10'!addReplacement: aStringReplacement	parent ifNil: [^self].	parent addReplacement: aStringReplacement! !!RBProgramNode methodsFor: 'replacing' stamp: 'ClementBera 7/26/2013 17:10'!clearReplacements	parent ifNil: [^self].	parent clearReplacements! !!RBProgramNode methodsFor: 'replacing'!removeDeadCode	self children do: [:each | each removeDeadCode]! !!RBProgramNode methodsFor: 'replacing'!replaceMethodSource: aNode 	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."	| method |	method := self methodNode.	method notNil ifTrue: [method map: self to: aNode].	aNode parent: self parent.	[self replaceSourceWith: aNode] on: Error		do: 			[:ex | 			self clearReplacements.			ex return]! !!RBProgramNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self error: 'I don''t store other nodes'! !!RBProgramNode methodsFor: 'replacing' stamp: 'ClementBera 7/26/2013 17:13'!replaceWith: aNode 	parent ifNil: [self error: 'This node doesn''t have a parent'].	self replaceMethodSource: aNode.	parent replaceNode: self withNode: aNode! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/21/2015 16:35'!afterLinks	^ self links select: [ :each | each control == #after ]! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/21/2015 16:35'!beforeLinks	^ self links select: [ :each | each control == #before ]! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/6/2015 15:35'!hasMetalink	^self hasProperty: #links! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/8/2015 09:14'!link: aMetaLink	(self propertyAt: #links ifAbsentPut: [ IdentitySet new ]) add: aMetaLink.	aMetaLink installOn: self.	self methodNode method installLink. ! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/1/2015 10:10'!links	^self propertyAt: #links ifAbsent: nil! !!RBProgramNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/8/2015 09:14'!removeLink: aMetaLink	self links remove: aMetaLink.	self links ifEmpty: [ self removeProperty: #links ].	self methodNode method removeLink. ! !!RBProgramNode methodsFor: 'testing-matching'!canMatchMethod: aCompiledMethod 	^self sentMessages allSatisfy: 			[:each | 			(self class optimizedSelectors includes: each) 				or: [aCompiledMethod refersToLiteral: each]]! !!RBProgramNode methodsFor: 'testing-matching'!isList	^false! !!RBProgramNode methodsFor: 'testing-matching'!isPatternNode	^false! !!RBProgramNode methodsFor: 'testing-matching'!recurseInto	^false! !!RBProgramNode methodsFor: 'meta variable-accessing'!cascadeListCharacter	^$;! !!RBProgramNode methodsFor: 'meta variable-accessing'!listCharacter	^$@! !!RBProgramNode methodsFor: 'meta variable-accessing'!literalCharacter	^$#! !!RBProgramNode methodsFor: 'meta variable-accessing'!recurseIntoCharacter	^$`! !!RBProgramNode methodsFor: 'meta variable-accessing'!statementCharacter	^$.! !!RBProgramNode methodsFor: '*SmartSuggestions' stamp: 'GiselaDecuzzi 4/5/2013 17:12'!specialCommands	^#().! !!RBProgramNode methodsFor: 'copying' stamp: 'PabloHerrero 11/18/2013 19:14'!copyCommentsFrom: aNode 	"Add all comments from aNode to us. If we already have the comment, then don't add it."	| newComments |	newComments := OrderedCollection new.	aNode nodesDo: [:each | newComments addAll: each comments].	self nodesDo: 			[:each | 			each comments do: [:comment | newComments remove: comment ifAbsent: []]].	newComments isEmpty ifTrue: [^self].	newComments := newComments asSortedCollection: [:a :b | a start < b start].	self comments: newComments! !!RBProgramNode methodsFor: 'copying' stamp: 'lr 12/29/2009 12:44'!postCopy	super postCopy.	properties := properties copy! !!RBProgramNode methodsFor: 'enumeration'!collect: aBlock 	"Hacked to fit collection protocols"	^aBlock value: self! !!RBProgramNode methodsFor: 'enumeration'!do: aBlock 	"Hacked to fit collection protocols"	aBlock value: self! !!RBProgramNode methodsFor: 'enumeration'!size	"Hacked to fit collection protocols"	^1! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 3/8/2015 09:24'!doSemanticAnalysis	^ self methodNode doSemanticAnalysis.	! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'CamilleTeruel 2/14/2014 14:33'!enclosingMethodOrBlockNode	^ self methodOrBlockNode ! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 12/18/2012 14:08'!irInstruction	"search for the first ir instruction that I generate"	self methodNode ir sourceNode == self  ifTrue: [^self methodNode ir].	^self methodNode ir firstInstructionMatching: [:instr | instr sourceNode == self ]	! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 8/5/2013 11:03'!isClean	^ self children allSatisfy: [ :child | child isClean ]! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:24'!methodOrBlockNode	^ parent ifNotNil: [ parent methodOrBlockNode ]! !!RBProgramNode methodsFor: '*opalcompiler-core'!owningScope	^ parent owningScope ! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:24'!printAsIfCompiledOn: aStream 	aStream nextPutAll: self formattedCode! !!RBProgramNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:24'!scope	^ self methodOrBlockNode scope! !!RBProgramNode methodsFor: 'private-replacing' stamp: 'lr 10/29/2010 11:37'!replaceSourceFrom: aNode	self == aNode		ifFalse: [ self clearReplacements ]! !!RBProgramNode methodsFor: 'private-replacing'!replaceSourceWith: aNode 	aNode replaceSourceFrom: self! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode exceptForVariables: variableNameCollection 	| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value | 			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].	^true! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode withMapping: aDictionary 	^self = aNode! !!RBProgramNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:47'!hashForCollection: aCollection	^ aCollection isEmpty ifTrue: [ 0 ] ifFalse: [ aCollection first hash ]! !!RBProgramNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/10/2014 11:25'!asReturnNode	^ RBReturnNode value: self! !!RBProgramNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/16/2014 13:25'!isIndirectTempVector	^ false! !!RBProgramNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/16/2014 13:30'!isJust: node	^ false! !!RBProgramNode methodsFor: '*OpalDecompiler' stamp: 'cb 7/29/2014 18:21'!toDoIncrement: variable	"Only meant for Messages or Assignments - else return nil"	^ nil! !!RBProgramNode methodsFor: 'printing' stamp: 'lr 11/1/2009 19:28'!printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self formattedCode;		nextPut: $)! !!RBProgramNode methodsFor: 'visiting'!acceptVisitor: aProgramNodeVisitor 	self subclassResponsibility! !!RBProgramNode methodsFor: 'iterating' stamp: 'lr 11/1/2009 20:49'!allChildren	| children |	children := OrderedCollection new.	self nodesDo: [ :each | children addLast: each ].	^ children! !!RBProgramNode methodsFor: 'iterating' stamp: 'lr 11/1/2009 20:49'!nodesDo: aBlock 	aBlock value: self.	self children do: [ :each | each nodesDo: aBlock ]! !!RBProgramNode methodsFor: '*NodeNavigation' stamp: 'GiselaDecuzzi 5/13/2013 11:12'!statements	^ #().! !!RBProgramNode methodsFor: 'deprecated'!isImmediate	^self isImmediateNode! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 3/8/2015 09:20'!compiledMethod	^ self ir compiledMethod! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 7/26/2013 15:25'!decompileString 	^ self formattedCode ! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 7/10/2013 15:55'!doSemanticAnalysis	self compilationContext ifNil: [ self methodClass: nil class ].	self		compilationContext semanticAnalyzerClass new		compilationContext: self compilationContext;		analyze: self! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 5/21/2013 14:30'!doSemanticAnalysisIn: behavior	self methodClass: behavior.	self doSemanticAnalysis! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 7/26/2013 15:25'!doSemanticAnalysisInContext: aCompilationContext	self compilationContext: aCompilationContext.	self doSemanticAnalysis.! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 7/26/2013 15:25'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^ self generate: CompiledMethodTrailer empty! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 11/20/2012 16:30'!generate: trailer	^ self generateIR compiledMethodWith: trailer.! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 7/26/2013 15:26'!generateIR	| ir |	scope ifNil: [self doSemanticAnalysisInContext: self compilationContext ]. 	ir := (self compilationContext astTranslatorClass new			visitNode: self)			ir.	^ self ir: ir! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 1/30/2013 13:13'!generateWithSource	"Answer a CompiledMethod with source encoded in trailer."		"for doits, we need to store the source pretty printed from the 	AST to get the return and methodName correct"	self selector isDoIt ifTrue: [source := self formattedCode].		^self generate: (CompiledMethodTrailer new sourceCode: source).! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'jorgeRessia 11/22/2009 10:30'!ir	^ self propertyAt: #ir ifAbsent: [self generateIR].! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'JorgeRessia 11/24/2009 19:05'!ir: aIRMethodNode	^ self propertyAt: #ir put: aIRMethodNode.! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 7/26/2013 15:27'!methodOrBlockNode	"^ self"! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 6/29/2012 16:04'!owningScope	^ self scope! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 7/5/2013 17:03'!properties	^self propertyAt: #methodProperties ifAbsent: nil! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'JorgeRessia 11/24/2009 18:56'!properties: aMethodeProperties 	^self propertyAt: #methodProperties put: aMethodeProperties! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'jws 10/29/2016 09:10'!rewriteTempsForContext: aContext		| rewriter  |	rewriter := ParseTreeRewriter new.	aContext tempNames withIndexDo: [ :tempName :index | 		rewriter 			replace: tempName, ' := ``@object'			with: 'ThisContext namedTempAt:', index asString,  'put: ``@object';			replace: tempName			with: 'ThisContext namedTempAt:', index asString ].	^ rewriter		executeTree: self;		tree! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 4/19/2013 08:32'!sourceNodeForPC: anInteger	^(self ir instructionForPC: anInteger) sourceNode! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 4/29/2013 15:06'!sourceText: aString	self source: aString! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'cb 6/27/2013 16:55'!startWithoutParentheses	^ 1! !!RBMethodNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 4/29/2013 15:25'!tempNames	"compatibility method to old MethodNode"	self flag: #Clean.	^ self argumentNames, self temporaryNames! !!RBMethodNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:37'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitMethodNode: self! !!RBMethodNode methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self formattedCode! !!RBMethodNode methodsFor: 'copying' stamp: 'lr 11/24/2009 23:22'!postCopy	super postCopy.	self arguments: (self arguments collect: [ :each | each copy ]).	self pragmas: (self pragmas collect: [ :each | each copy ]).	self body: self body copy! !!RBMethodNode methodsFor: 'matching' stamp: 'PabloHerrero 10/20/2013 07:20'!copyInContext: aDictionary	^ self class new		selector: self selector;		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);		pragmas: (self pragmas isEmpty			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);		body: (self body copyInContext: aDictionary);		source: (aDictionary at: '-source-' ifAbsentPut: [ self source ]);		yourself! !!RBMethodNode methodsFor: 'matching' stamp: 'lr 5/30/2010 12:22'!match: aNode inContext: aDictionary 	self class = aNode class ifFalse: [ ^ false ].	aDictionary at: '-source-' put: aNode source.	self selector = aNode selector ifFalse: [ ^ false ].	^ (self matchList: arguments against: aNode arguments inContext: aDictionary)		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)		and: [ body match: aNode body inContext: aDictionary ] ]! !!RBMethodNode methodsFor: 'matching' stamp: 'lr 5/30/2010 12:23'!matchPragmas: matchNodes against: pragmaNodes inContext: aDictionary	matchNodes isEmpty ifTrue: [ 		aDictionary at: '-pragmas-' put: pragmaNodes.		^ true ].	^ matchNodes allSatisfy: [ :matchNode |		pragmaNodes anySatisfy: [ :pragmaNode |			matchNode match: pragmaNode inContext: aDictionary ] ]! !!RBMethodNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 10/19/2013 07:09'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes	self 		arguments: valueNodes;		selector: aSymbol;		keywordsPositions: positionList.! !!RBMethodNode methodsFor: 'private-replacing' stamp: 'PabloHerrero 10/22/2013 14:02'!changeSourceSelector: oldSelector keywordsIntervals: oldIntervals arguments: oldArguments	"If this is the same number of arguments, we try a one to one replacement of selector parts and arguments. If this is not the case try to rewrite the signature as a whole, what unfortunately drops the comments within the signature."	[ (oldIntervals size = self keywordsPositions size and: [ oldArguments size = arguments size ])		ifTrue: [			self selectorParts keysAndValuesDo: [ :index :part |				self addReplacement: (RBStringReplacement 					replaceFrom: (oldIntervals at: index) first					to: (oldIntervals at: index) last					with: part) ].			oldArguments with: arguments do: [ :old :new | 				self addReplacement: (RBStringReplacement 					replaceFrom: old start					to: old stop					with: new name) ] ]		ifFalse: [			self addReplacement: (RBStringReplacement				replaceFrom: oldIntervals first first				to: (oldArguments notEmpty					ifTrue: [ oldArguments last stop ]					ifFalse: [ oldIntervals last last ])				with: (String streamContents: [ :stream |					self selectorParts keysAndValuesDo: [ :index :part |						index = 1 ifFalse: [ stream space ].						stream nextPutAll: part.						index <= arguments size							ifTrue: [ stream space; nextPutAll: (arguments at: index) name ] ] ])) ] ]		on: Error		do: [ :ex | ex return ]! !!RBMethodNode methodsFor: '*reflectivity' stamp: 'MarcusDenker 3/8/2015 09:26'!method	"return the method that I have been compiled for"	self compilationContext ifNil: [ ^nil ].	^self compilationContext getClass >> self selector! !!RBMethodNode methodsFor: 'comparing' stamp: 'lr 10/18/2009 16:03'!= anObject 	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	(self selector = anObject selector		and: [ self pragmas size = anObject pragmas size		and: [ self body = anObject body ] ])			ifFalse: [ ^ false ].	self arguments with: anObject arguments do: [ :first :second |		first = second 			ifFalse: [ ^ false ] ].	self pragmas with: anObject pragmas do: [ :first :second |		first = second 			ifFalse: [ ^ false ] ].	^ true! !!RBMethodNode methodsFor: 'comparing' stamp: 'lr 10/18/2009 15:44'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [ ^ false ].	(self selector = anObject selector		and: [ self pragmas size = anObject pragmas size		and: [ self body equalTo: anObject body withMapping: aDictionary ] ]) 			ifFalse: [ ^ false ].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second	withMapping: aDictionary)			ifFalse: [ ^ false ].		aDictionary removeKey: first name ].	self pragmas with: anObject pragmas do: [ :first :second |		(first equalTo: second	withMapping: aDictionary) 			ifFalse: [ ^ false ] ].	^ true! !!RBMethodNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:55'!hash	^ ((self selector hash bitXor: (self hashForCollection: self arguments)) bitXor: (self hashForCollection: self pragmas)) bitXor: self body hash! !!RBMethodNode methodsFor: 'initialization'!initialize	replacements := SortedCollection sortBlock: 					[:a :b | 					a startPosition < b startPosition 						or: [a startPosition = b startPosition and: [a stopPosition < b stopPosition]]].	nodeReplacements := IdentityDictionary new! !!RBMethodNode methodsFor: 'private' stamp: 'TestRunner 12/23/2009 21:13'!reformatSource	| stream newSource newTree |	stream := WriteStream on: (String new: source size + 100).	stream		nextPutAll: (source			copyFrom: (replacements				inject: 1				into: [ :sum :each | 					stream						nextPutAll: (source copyFrom: sum to: each startPosition - 1);						nextPutAll: (each string).					each stopPosition + 1 ])			to: source size).	newSource := stream contents.	newTree := RBParser 		parseMethod: newSource 		onError: [ :msg :pos | ^ self formattedCode ].	self = newTree		ifFalse: [ ^ self formattedCode ].	^ newSource! !!RBMethodNode methodsFor: 'replacing' stamp: 'ClementBera 7/26/2013 17:13'!addReplacement: aStringReplacement 	replacements ifNil: [^self].	replacements add: aStringReplacement! !!RBMethodNode methodsFor: 'replacing'!clearReplacements	replacements := nil! !!RBMethodNode methodsFor: 'replacing'!map: oldNode to: newNode 	nodeReplacements at: oldNode put: newNode! !!RBMethodNode methodsFor: 'replacing'!mappingFor: oldNode 	^nodeReplacements at: oldNode ifAbsent: [oldNode]! !!RBMethodNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	aNode == body ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMethodNode methodsFor: 'testing'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBMethodNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 16:32'!hasArgumentNamed: aString		^ self arguments anySatisfy: [ :argument| argument name = aString ]! !!RBMethodNode methodsFor: 'testing' stamp: 'CamilloBruni 3/6/2013 15:15'!hasPragmaNamed: aSymbol		self pragmaNamed: aSymbol ifAbsent: [ ^ false ].	^ true! !!RBMethodNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 16:32'!hasTemporaryNamed: aString		^ self temporaries anySatisfy: [ :temp| temp name = aString ]! !!RBMethodNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	(self arguments anySatisfy: #isFaulty) ifTrue:[ ^true].	(self pragmas anySatisfy: #isFaulty) ifTrue:[ ^true].	^self body isFaulty! !!RBMethodNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBMethodNode methodsFor: 'testing'!isMethod	^true! !!RBMethodNode methodsFor: 'testing' stamp: 'lr 11/1/2009 19:37'!isPrimitive	^ self pragmas anySatisfy: [ :each | each isPrimitive ]! !!RBMethodNode methodsFor: 'testing'!lastIsReturn	^body lastIsReturn! !!RBMethodNode methodsFor: 'testing' stamp: 'CamilloBruni 3/6/2013 15:14'!pragmaNamed: aSymbol		^ self pragmaNamed: aSymbol ifAbsent: [ KeyNotFound signalFor: aSymbol  ]! !!RBMethodNode methodsFor: 'testing' stamp: 'CamilloBruni 3/6/2013 15:15'!pragmaNamed: aSymbol ifAbsent: absentBlock	^ self pragmas 		detect: [ :pragma| pragma selector = aSymbol ]		ifNone: absentBlock! !!RBMethodNode methodsFor: 'testing' stamp: 'BenComan 1/28/2015 00:06'!pragmaNamed: aSymbol ifPresent: foundBlock	^ self pragmas 		detect: [ :pragma| pragma selector = aSymbol ]		ifFound: foundBlock! !!RBMethodNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBMethodNode methodsFor: 'testing'!uses: aNode 	^body == aNode and: [aNode lastIsReturn]! !!RBMethodNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 8/1/2014 10:24'!primitiveErrorVariableName	"Answer the primitive error code temp name, or nil if none."	self isPrimitive ifTrue: [ 		self pragmas do: [ :pragma | 			pragma selectorParts first = 'primitive:' ifTrue: [ 				^ pragma argumentAt: 'error:' ifAbsent: nil ] ] ].	^ nil! !!RBMethodNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 8/1/2014 10:25'!removeAndRenameLastTempIfErrorCode	self primitiveErrorVariableName ifNotNil: [ :primitiveErrorVariableName |		 body temporaries removeLast ].! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 1/4/2012 21:40'!addNode: aNode	^ body addNode: aNode! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 1/4/2012 21:38'!addReturn	^ body addReturn! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 1/4/2012 21:38'!addSelfReturn	^ body addSelfReturn! !!RBMethodNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBMethodNode methodsFor: 'accessing'!arguments	^arguments! !!RBMethodNode methodsFor: 'accessing'!arguments: variableNodes 	arguments := variableNodes.	arguments do: [:each | each parent: self]! !!RBMethodNode methodsFor: 'accessing'!body	^body! !!RBMethodNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 19:57'!children	^ OrderedCollection new		addAll: self arguments;		addAll: self pragmas;		add: self body;		yourself! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarcusDenker 5/17/2013 15:49'!compilationContext	^ compilationContext! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarcusDenker 5/13/2013 11:44'!compilationContext: aCompilationContext	compilationContext := aCompilationContext.! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/7/2013 11:14'!firstPrecodeComment	| comment  | 	self comments ifEmpty: [ ^nil ].	comment :=  self comments first.	^self source copyFrom: comment start to: comment stop.! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 12:47'!keywords	^ selector keywords.! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/28/2013 17:01'!keywordsIntervals	^selector keywords		with: self keywordsPositions 		collect: [:keyword :start| start to: (start = 0 ifTrue: [ -1 ] ifFalse: [ start + keyword size - 1]) ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/28/2013 17:01'!keywordsPositions	^keywordsPositions ifNil: [ (selector keywords collect: [:char| 0 ]) asIntegerArray ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/28/2013 17:01'!keywordsPositions: aPositionsList	keywordsPositions := aPositionsList ifNotNil: [:list| list asIntegerArray ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarcusDenker 5/17/2013 15:41'!methodClass	^self compilationContext getClass ! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarcusDenker 5/17/2013 15:49'!methodClass: aClass		compilationContext ifNil: [compilationContext := aClass compiler compilationContext].	self compilationContext class: aClass! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/7/2013 11:14'!methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	arguments do: [:each | methodComments addAll: each comments].	^methodComments asSortedCollection: [:a :b | a start < b start]! !!RBMethodNode methodsFor: 'accessing'!methodNode	^self! !!RBMethodNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:13'!newSource	replacements ifNil: [^self formattedCode].	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]! !!RBMethodNode methodsFor: 'accessing'!numArgs	^self selector numArgs! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 19:34'!pragmas	^ pragmas ifNil: [ #() ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 19:34'!pragmas: aCollection	pragmas := aCollection.	pragmas do: [ :each | each parent: self ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'TestRunner 11/5/2009 11:48'!primitiveSources	^ self pragmas collect: [ :each | self source copyFrom: each first to: each last ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/22/2013 09:48'!renameSelector: newSelector andArguments: varNodeCollection 	| oldIntervals oldArguments oldSelector |	oldSelector := selector.	oldIntervals := self keywordsIntervals.	oldArguments := arguments.	self		arguments: varNodeCollection;		selector: newSelector.	self changeSourceSelector: oldSelector keywordsIntervals: oldIntervals arguments: oldArguments! !!RBMethodNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/15/2011 16:28'!scope	^ scope! !!RBMethodNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/15/2011 16:28'!scope: aScopedNode	scope := aScopedNode! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/19/2013 06:41'!selector	^ selector! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/17/2013 18:39'!selector: aSelector	keywordsPositions := nil.	selector := aSelector asSymbol.! !!RBMethodNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 12:47'!selectorParts	^ self keywords collect: #asSymbol.! !!RBMethodNode methodsFor: 'accessing'!source	^source! !!RBMethodNode methodsFor: 'accessing'!source: anObject	source := anObject! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarcusDenker 4/12/2013 10:27'!sourceCode	"compatibility to MethodNode"	^source! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarkRizun 10/19/2014 11:32'!start	^ 1! !!RBMethodNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/3/2012 16:42'!statements	^ self body statements! !!RBMethodNode methodsFor: 'accessing' stamp: 'GiselaDecuzzi 5/27/2013 18:59'!statements: aCollection	self body statements: aCollection ! !!RBMethodNode methodsFor: 'accessing' stamp: 'MarkRizun 10/19/2014 11:32'!stop	^ self newSource size! !!RBMethodNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/3/2012 16:41'!temporaries	^ self body temporaries! !!RBMethodNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/8/2011 16:19'!temporaryNames	^ self body temporaryNames! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'g 6/24/2013 18:03'!binding: anOCTempVariable 	"only for compatibility"	! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'CamilloBruni 10/31/2012 18:52'!errorMessage	^ errorMessage! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'CamilloBruni 10/31/2012 18:52'!errorMessage: anObject	errorMessage := anObject! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^true.! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/23/2013 18:37'!start	^ start! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'PabloHerrero 2/10/2015 19:04'!start: aPosition	start := aPosition! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/8/2013 13:57'!stop	^ start + value size - 1.! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/23/2013 17:29'!value	^value.! !!RBParseErrorNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/23/2013 17:30'!value: aString	value := aString.! !!RBParseErrorNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:37'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor visitParseErrorNode: self.! !!RBPatternMethodNode methodsFor: 'private'!matchingClass	^RBMethodNode! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!copyInContext: aDictionary 	| keywordSelector |	keywordSelector := self isSelectorList 		ifTrue: [ aDictionary at: self selectorParts first ]		ifFalse: [ ('' join:(self selectorParts collect: [ :each | aDictionary at: each ])) asSymbol  ].	^ RBMethodNode new		selector: keywordSelector;		arguments: (self copyList: self arguments inContext: aDictionary);		pragmas: (self pragmas isEmpty			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);		body: (self body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!match: aNode inContext: aDictionary 	aNode class = self matchingClass 		ifFalse: [ ^ false ].	aDictionary at: '-source-' put: aNode source.	self isSelectorList ifTrue: [		^ (aDictionary at:  self selectorParts first ifAbsentPut: [ aNode selector ]) = aNode selector			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments			and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)			and: [ body match: aNode body inContext: aDictionary ] ] ] ].	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)		and: [ body match: aNode body inContext: aDictionary ] ]! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'lr 5/30/2010 10:35'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size = aNode arguments size		ifFalse: [ ^ false ].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [ ^ false ].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary) 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!matchSelectorAgainst: aNode inContext: aDictionary 	self selectorParts with: aNode selectorParts do: [ :first :second |		| keyword |		keyword := aDictionary			at: first			ifAbsentPut: [ 				first isPatternVariable 					ifTrue: [ second ]					ifFalse: [ first ] ].		keyword = second 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternMethodNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMethodNode methodsFor: 'testing'!isSelectorList	^isList! !!RBPatternMethodNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 10/20/2013 03:26'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes 	super selector: aSymbol keywordsPositions: positionList arguments: valueNodes.	isList := (aSymbol keywords first value at: 2) == self listCharacter! !!RBPragmaNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/26/2014 18:28'!argumentAt: keywordSelector	^ self 		argumentAt: keywordSelector		ifAbsent: [ KeyNotFound signalFor: keywordSelector ]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/26/2014 18:28'!argumentAt: keywordSelector ifAbsent: absentBlock	self selectorParts with: self arguments do: [ :selectorPart :argument |		selectorPart value = keywordSelector			ifTrue: [ ^ argument ]].	^ absentBlock value! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 10/18/2009 12:14'!arguments	^ arguments ifNil: [ #() ]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 10/13/2009 14:01'!arguments: aLiteralCollection 	arguments := aLiteralCollection.	arguments do: [ :each | each parent: self ]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 10/27/2009 11:57'!children	^ self arguments! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/22/2013 11:09'!keywordsIntervals	^selector keywords		with: self keywordsPositions 		collect: [:keyword :start| start to: (start = 0 ifTrue: [ -1 ] ifFalse: [ start + keyword size - 1]) ].! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/28/2013 17:01'!keywordsPositions	^keywordsPositions ifNil: [ (selector keywords collect: [:char| 0 ]) asIntegerArray ]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/20/2013 03:53'!keywordsPositions: aPositionsList	keywordsPositions := aPositionsList ifNotNil: [:list| list asIntegerArray ].! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 09:30'!numArgs	^ self selector numArgs! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/20/2013 04:21'!selector	^ selector! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/20/2013 04:13'!selector: aSelector 	keywordsPositions := nil.	selector := aSelector asSymbol.! !!RBPragmaNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/22/2013 14:02'!selectorParts	^ selector keywords collect: [:keyword| keyword asSymbol ].! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:22'!sentMessages	^ super sentMessages		add: self selector;		yourself! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 11/5/2009 10:41'!start	^ left! !!RBPragmaNode methodsFor: 'accessing' stamp: 'lr 11/5/2009 10:41'!stop	^ right! !!RBPragmaNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:38'!acceptVisitor: aProgramNodeVisitor 	^ aProgramNodeVisitor visitPragmaNode: self! !!RBPragmaNode methodsFor: 'initialization' stamp: 'PabloHerrero 10/19/2013 07:25'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes	aSymbol numArgs == valueNodes size		ifFalse: 			[self error: 'Attempting to assign selector with wrong number of arguments.'].	self 		arguments: valueNodes;		selector: aSymbol;		keywordsPositions: positionList.! !!RBPragmaNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/24/2014 23:17'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self selector = anObject selector ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	self arguments		with: anObject arguments		do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBPragmaNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/24/2014 23:22'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [ ^ false ].	self selector = anObject selector ifFalse: [ ^ false ].	self arguments size = anObject arguments size ifFalse: [ ^ false ].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary) 			ifFalse: [ ^ false ] ].	^ true! !!RBPragmaNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:47'!hash	^ self selector hash bitXor: (self hashForCollection: self arguments)! !!RBPragmaNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/14/2013 16:32'!asPragma	^ Pragma keyword: selector arguments: (arguments collect: [ :each | each value ]) asArray! !!RBPragmaNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/14/2013 13:48'!isCompilerOption	^ self selector = #compilerOptions:! !!RBPragmaNode methodsFor: '*opalcompiler-core' stamp: 'CamilloBruni 2/26/2014 16:20'!isPrimitiveError	^ #( primitive:error: primitive:module:error: primitive:error:module:) includes: self selector! !!RBPragmaNode methodsFor: 'matching' stamp: 'PabloHerrero 10/20/2013 07:02'!copyInContext: aDictionary 	^ self class		selector: self selector		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ])! !!RBPragmaNode methodsFor: 'matching' stamp: 'lr 5/30/2010 10:06'!match: aNode inContext: aDictionary 	aNode class = self class		ifFalse: [ ^ false ].	self selector = aNode selector		ifFalse: [ ^ false ].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [ ^ false ] ].	^ true! !!RBPragmaNode methodsFor: 'testing' stamp: 'lr 10/13/2009 14:00'!isBinary	^ (self isUnary or: [self isKeyword]) not! !!RBPragmaNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^self arguments anySatisfy: #isFaulty.! !!RBPragmaNode methodsFor: 'testing' stamp: 'PabloHerrero 10/20/2013 04:12'!isKeyword	^(selector indexOf: $:) ~= 0.! !!RBPragmaNode methodsFor: 'testing' stamp: 'lr 10/13/2009 14:00'!isPragma	^ true! !!RBPragmaNode methodsFor: 'testing' stamp: 'lr 11/9/2009 20:06'!isPrimitive	^ #(primitive: primitive:error: primitive:error:module: primitive:module: primitive:module:error:) includes: self selector! !!RBPragmaNode methodsFor: 'testing' stamp: 'lr 10/13/2009 14:01'!isUnary	^ arguments isEmpty! !!RBPragmaNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:37'!postCopy	super postCopy.	self arguments: (self arguments collect: [ :each | each copy ])! !!RBPragmaNode methodsFor: 'accessing-token' stamp: 'lr 11/5/2009 10:40'!left	^ left! !!RBPragmaNode methodsFor: 'accessing-token' stamp: 'lr 11/5/2009 10:40'!left: anInteger	left := anInteger! !!RBPragmaNode methodsFor: 'accessing-token' stamp: 'lr 11/5/2009 10:40'!right	^ right! !!RBPragmaNode methodsFor: 'accessing-token' stamp: 'lr 11/5/2009 10:40'!right: anInteger	right := anInteger! !!RBPragmaNode methodsFor: 'replacing' stamp: 'lr 10/13/2009 14:00'!replaceNode: aNode withNode: anotherNode 	self arguments: (arguments collect: [ :each | 		each == aNode 			ifTrue: [ anotherNode ]			ifFalse: [ each ] ])! !!RBPatternPragmaNode methodsFor: 'testing-matching' stamp: 'lr 5/30/2010 09:40'!isPatternNode	^ true! !!RBPatternPragmaNode methodsFor: 'testing-matching' stamp: 'lr 5/30/2010 09:40'!isSelectorList	^ isList! !!RBPatternPragmaNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:22'!sentMessages	^ super sentMessages		remove: self selector ifAbsent: [ ];		yourself! !!RBPatternPragmaNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!copyInContext: aDictionary 	| keywordSelector |	keywordSelector := self isSelectorList 		ifTrue: [ aDictionary at: self selectorParts first ]		ifFalse: [ ('' join: (self selectorParts collect: [ :each | aDictionary at: each ])) asSymbol ].	^ RBPragmaNode		selector: keywordSelector		arguments: (self copyList: self arguments inContext: aDictionary)! !!RBPatternPragmaNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!match: aNode inContext: aDictionary	aNode class = self matchingClass		ifFalse: [ ^ false ].	self isSelectorList ifTrue: [		^ (aDictionary at: self selectorParts first ifAbsentPut: [ aNode selector ]) = aNode selector			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments ] ].	^ self matchArgumentsAgainst: aNode inContext: aDictionary! !!RBPatternPragmaNode methodsFor: 'matching' stamp: 'lr 5/30/2010 10:07'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size = aNode arguments size		ifFalse: [ ^ false ].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [ ^ false ].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary) 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternPragmaNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!matchSelectorAgainst: aNode inContext: aDictionary 	self selectorParts with: aNode selectorParts do: [ :first :second |		| keyword |		keyword := aDictionary			at: first			ifAbsentPut: [ 				first isPatternVariable 					ifTrue: [ second ]					ifFalse: [ first ] ].		keyword = second 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternPragmaNode methodsFor: 'initialization' stamp: 'PabloHerrero 10/20/2013 03:25'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes	self 		arguments: valueNodes;		selector: aSymbol;		keywordsPositions: positionList.	isList := (aSymbol keywords first value at: 2) == self listCharacter! !!RBPatternPragmaNode methodsFor: 'private' stamp: 'lr 5/30/2010 09:40'!matchingClass	^ RBPragmaNode! !!RBProgramNode class methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 16:30'!formatterClass	^ FormatterClass 		ifNil: [ RBConfigurableFormatter ] 		ifNotNil: [ FormatterClass ]! !!RBProgramNode class methodsFor: 'accessing' stamp: 'MarcusDenker 12/16/2013 20:16'!formatterClass: aClass	FormatterClass := aClass		! !!RBProgramNode class methodsFor: 'accessing' stamp: 'lr 11/7/2009 15:37'!optimizedSelectors	^ #( and: caseOf: caseOf:otherwise: ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue: ifTrue:ifFalse: or: to:by:do: to:do: whileFalse whileFalse: whileTrue whileTrue: )! !!RBMethodNode class methodsFor: '*OpalCompiler-Core' stamp: 'ClementBera 11/18/2014 11:42'!errorMethodNode: selector errorMessage: messageText		| message |	message := RBMessageNode 		receiver: (RBSelfNode named: 'self')		selector: #error: 		arguments: {RBLiteralNode value: messageText}.	^ self 		selector: selector 		arguments: ((1 to: selector numArgs) collect: [ :i | RBArgumentNode named: 't' , i asString ]) 		body: (RBSequenceNode statements: {message}) ! !!RBMethodNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 3/7/2015 21:04'!selector: aSymbol arguments: valueNodes	^(self new)		selector: aSymbol;		arguments: valueNodes;		yourself! !!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol arguments: variableNodes body: aSequenceNode 	^(self new)		arguments: variableNodes;		selector: aSymbol;		body: aSequenceNode;		yourself! !!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol body: aSequenceNode 	^self 		selector: aSymbol		arguments: #()		body: aSequenceNode! !!RBMethodNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/17/2013 05:04'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes	^(self new)		selector: aSymbol			keywordsPositions: positionList 			arguments: valueNodes;		yourself.! !!RBParseErrorNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/23/2013 17:31'!errorMessage: aString value: aValue at: aPosition	^ self new		errorMessage: aString;		value: aValue;		start: aPosition;		yourself! !!RBPatternMethodNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 17:15'!selector: aSelector keywordsPositions: positionList arguments: valueNodes	^(aSelector isPatternVariable) 		ifTrue: [super selector: aSelector keywordsPositions: positionList arguments: valueNodes]		ifFalse: 			[RBMethodNode selector: aSelector keywordsPositions: positionList arguments: valueNodes]! !!RBPragmaNode class methodsFor: '*Modtalk-Compiler' stamp: 'JohnSarkela 5/5/2016 10:21:53'!selector: aSymbol arguments: anArrayOfArgs	^self new		arguments: anArrayOfArgs;		selector: aSymbol;		yourself! !!RBPragmaNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/20/2013 07:03'!selector: aSymbol keywordsPositions: positionList arguments: valueNodes	^ self new selector: aSymbol keywordsPositions: positionList arguments: valueNodes ! !!RBPatternPragmaNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 17:16'!selector: aSelector keywordsPositions: positionList arguments: valueNodes	^(aSelector isPatternVariable)		ifTrue: [ super selector: aSelector keywordsPositions: positionList arguments: valueNodes ]		ifFalse: [ RBPragmaNode selector: aSelector keywordsPositions: positionList arguments: valueNodes ]! !!RBReplaceRule methodsFor: 'matching'!canMatch: aProgramNode 	^verificationBlock value: aProgramNode! !!RBReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching'!replace: aProgramNode with: newNode 	aProgramNode replaceMethodSource: newNode! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:00'!searchFor: searchString replaceWith: replaceString 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:01'!searchFor: searchString replaceWith: replaceString when: aBlock 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:01'!searchForMethod: searchString replaceWith: replaceString 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:01'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:01'!searchForTree: aBRProgramNode replaceWith: replaceNode 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'matching' stamp: 'StephaneDucasse 3/29/2013 18:01'!searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'initialization'!initialize	super initialize.	verificationBlock := [:aNode | true]! !!RBBlockReplaceRule methodsFor: 'initialization'!initialize	super initialize.	replaceBlock := [:aNode | aNode]! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	| newNode |	newNode := replaceBlock value: aProgramNode.	aProgramNode replaceMethodSource: newNode.	^newNode! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: aRBProgramNode replaceWith: replaceBlock 	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceBlock		when: aBlock! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:21'!return	^ return! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:21'!return: anInteger	return := anInteger! !!RBReturnNode methodsFor: 'initialize-release'!return: returnInteger value: aValueNode 	return := returnInteger.	self value: aValueNode! !!RBReturnNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self value = anObject value! !!RBReturnNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	^self class = anObject class 		and: [self value equalTo: anObject value withMapping: aDictionary]! !!RBReturnNode methodsFor: 'comparing'!hash	^self value hash! !!RBReturnNode methodsFor: 'converting' stamp: 'MarcusDenker 1/29/2013 14:22'!asSequenceNode	^RBSequenceNode statements: {self} ! !!RBReturnNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/10/2014 11:25'!asReturnNode! !!RBReturnNode methodsFor: 'testing'!containsReturn	^true! !!RBReturnNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^self value isFaulty.! !!RBReturnNode methodsFor: 'testing'!isReturn	^true! !!RBReturnNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode]! !!RBReturnNode methodsFor: 'accessing'!children	^Array with: value! !!RBReturnNode methodsFor: 'accessing'!start	^return! !!RBReturnNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/6/2015 22:51'!stop	^ value stop! !!RBReturnNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/6/2015 22:50'!stop: anInteger	self value stop: anInteger! !!RBReturnNode methodsFor: 'accessing'!value	^value! !!RBReturnNode methodsFor: 'accessing'!value: valueNode 	value := valueNode.	value parent: self! !!RBReturnNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:34'!postCopy	super postCopy.	self value: self value copy! !!RBReturnNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:38'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitReturnNode: self! !!RBReturnNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:35'!copyInContext: aDictionary 	^ self class new		value: (self value copyInContext: aDictionary);		yourself! !!RBReturnNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:35'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	^value match: aNode value inContext: aDictionary! !!RBReturnNode class methodsFor: 'instance creation'!return: returnInteger value: aValueNode 	^self new return: returnInteger value: aValueNode! !!RBReturnNode class methodsFor: 'instance creation'!value: aNode	^self return: nil value: aNode! !!RBScanner methodsFor: 'private'!classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index > 255 		ifTrue: 			[^aCharacter isLetter 				ifTrue: [#alphabetic]				ifFalse: [aCharacter isSeparator ifTrue: [#separator] ifFalse: [nil]]].	^classificationTable at: index! !!RBScanner methodsFor: 'private' stamp: 'lr 11/2/2009 23:37'!previousStepPosition	^characterType = #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]! !!RBScanner methodsFor: 'private'!step	stream atEnd 		ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter! !!RBScanner methodsFor: 'accessing' stamp: 'lr 11/23/2009 14:18'!contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	[ self atEnd ]		whileFalse: [ contentsStream nextPut: self next ].	^ contentsStream contents! !!RBScanner methodsFor: 'accessing' stamp: 'GiselaDecuzzi 5/28/2013 13:28'!errorBlock: aBlock 	errorBlock := aBlock! !!RBScanner methodsFor: 'accessing'!flush! !!RBScanner methodsFor: 'accessing'!getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments! !!RBScanner methodsFor: 'accessing' stamp: 'GiselaDecuzzi 6/10/2013 14:53'!next	| token |	buffer reset.	tokenStart := stream position.	token := characterType = #eof 				ifTrue: 					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]				ifFalse: [self scanToken].	self stripSeparators.	token comments: self getComments.	^token! !!RBScanner methodsFor: 'accessing'!nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement! !!RBScanner methodsFor: 'accessing' stamp: 'GiselaDecuzzi 6/10/2013 10:22'!scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType = #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType = #digit 		or: [currentCharacter = $- and: [(self classify: stream peek) = #digit]]) 			ifTrue: [^self scanNumber].	characterType = #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType = #special ifTrue: [^self scanSpecialCharacter].	currentCharacter = $' ifTrue: [^self scanLiteralString].	currentCharacter = $# ifTrue: [^self scanLiteral].	currentCharacter = $$ ifTrue: [^self scanLiteralCharacter].	^self scanError: 'Unknown character' translated! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 11/2/2009 23:37'!scanAnySymbol	characterType = #alphabetic ifTrue: [^self scanSymbol].	characterType = #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 3/7/2010 11:41'!scanBinary: aClass 	| val |	buffer nextPut: currentCharacter.	self step.	[ characterType = #binary ] whileTrue: 		[ buffer nextPut: currentCharacter.		self step ].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart! !!RBScanner methodsFor: 'private-scanning' stamp: 'GiselaDecuzzi 6/10/2013 15:53'!scanError: theCause	currentCharacter ifNotNil: [ :char | buffer nextPut: char ].	^ RBErrorToken		value: buffer contents asString		start: tokenStart		cause: theCause		location: stream position + 1! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 3/7/2010 11:47'!scanIdentifierOrKeyword	| name |	self scanName.	(currentCharacter = $: and: [stream peek ~= $=]) 		ifTrue: [^self scanKeyword].	name := buffer contents.	name = 'true' 		ifTrue: 			[^RBLiteralToken 				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false' 		ifTrue: 			[^RBLiteralToken 				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil' 		ifTrue: 			[^RBLiteralToken 				value: nil				start: tokenStart				stop: self previousStepPosition].	^RBIdentifierToken value: name start: tokenStart! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 11/2/2009 23:37'!scanKeyword	| outputPosition inputPosition name |	[currentCharacter = $:] whileTrue: 			[buffer nextPut: currentCharacter.			outputPosition := buffer position.			inputPosition := stream position.			self step.	":"			[characterType = #alphabetic] whileTrue: [self scanName]].	buffer position: outputPosition.	stream position: inputPosition.	self step.	name := buffer contents.	^(name occurrencesOf: $:) == 1 		ifTrue: [RBKeywordToken value: name start: tokenStart]		ifFalse: 			[RBMultiKeywordLiteralToken 				value: name asSymbol				start: tokenStart				stop: tokenStart + name size - 1]! !!RBScanner methodsFor: 'private-scanning' stamp: 'GiselaDecuzzi 6/10/2013 10:47'!scanLiteral	self step.	self stripSeparators.	characterType = #alphabetic 		ifTrue: [ ^ self scanSymbol ].	characterType = #binary 		ifTrue: [ ^ (self scanBinary: RBLiteralToken) stop: self previousStepPosition ].	currentCharacter = $' 		ifTrue: [ ^ self scanStringSymbol ].	(currentCharacter = $( or: [ currentCharacter = $[ ]) 		ifTrue: [ ^ self scanLiteralArrayToken].	"Accept some strange literals like '#1', '# species' and '##species:'"	characterType = #digit		ifTrue: [ ^ self scanNumber ].	currentCharacter = $#		ifTrue: [ ^ self scanLiteral ].	^self scanError: 'Expecting a literal type' translated.! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArrayToken	| token |	token := RBLiteralArrayToken 				value: (String with: $# with: currentCharacter)				start: tokenStart.	self step.	^token! !!RBScanner methodsFor: 'private-scanning'!scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token! !!RBScanner methodsFor: 'private-scanning' stamp: 'GiselaDecuzzi 6/10/2013 11:05'!scanLiteralString	self step.		[currentCharacter isNil 		ifTrue: [^self scanError: 'Unmatched '' in string literal.' translated].	currentCharacter = $' and: [self step ~= $']] 			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken 		value: buffer contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 11/2/2009 23:37'!scanName	[characterType = #alphabetic or: [characterType = #digit]] whileTrue: 			[buffer nextPut: currentCharacter.			self step]! !!RBScanner methodsFor: 'private-scanning' stamp: 'YuriyTymchuk 10/29/2013 11:10'!scanNumber	| start number stop string |	start := stream position.	stream position: start - 1.	number := [NumberParser parse: stream] on: Error do: [:err | self scannerError: err messageText].	stop := stream position.	stream position: start - 1.	string := stream next: stop - start + 1.	stream position: stop.	self step.	^RBNumberLiteralToken 		value: number		start: start		stop: stop		source: string! !!RBScanner methodsFor: 'private-scanning' stamp: 'GiselaDecuzzi 6/10/2013 10:47'!scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter = ${ 		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType = #alphabetic] whileFalse: 			[characterType = #eof 				ifTrue: [self scanError: 'Meta variable expected'].			buffer nextPut: currentCharacter.			self step].	^self scanIdentifierOrKeyword! !!RBScanner methodsFor: 'private-scanning' stamp: 'CamilloBruni 11/13/2012 10:03'!scanSpecialCharacter	| character |	currentCharacter = $: 		ifTrue: [			self step.			^ currentCharacter = $= 				ifTrue: [					self step.					RBAssignmentToken start: tokenStart]				ifFalse: [ RBSpecialCharacterToken value: $: start: tokenStart ]].				currentCharacter = $_ ifTrue: [ 		self step.  		^ RBShortAssignmentToken start: tokenStart ].		character := currentCharacter.	self step.	^ RBSpecialCharacterToken value: character start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 11/16/2009 15:48'!scanSymbol	[ characterType = #alphabetic or: [ currentCharacter = $: ] ] whileTrue: [		self scanName.		currentCharacter = $: ifTrue: [			buffer nextPut: $:.			self step ] ].	^ RBLiteralToken 		value: buffer contents asSymbol		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'GiselaDecuzzi 6/10/2013 13:07'!stripComment	| start stop |	start := stream position.	[self step = $"] whileFalse: 			[characterType = #eof				ifTrue: [^self scannerError: 'Unmatched " in comment.' translated]].	stop := stream position.	self step.	comments add: (start to: stop)! !!RBScanner methodsFor: 'private-scanning' stamp: 'lr 11/2/2009 23:37'!stripSeparators		[[characterType = #separator] whileTrue: [self step].	currentCharacter = $"] 			whileTrue: [self stripComment]! !!RBScanner methodsFor: 'testing' stamp: 'lr 11/2/2009 23:37'!atEnd	^characterType = #eof! !!RBScanner methodsFor: 'testing'!isReadable	^true! !!RBScanner methodsFor: 'testing'!isWritable	^false! !!RBScanner methodsFor: 'error handling' stamp: 'GiselaDecuzzi 6/10/2013 13:11'!errorBlock	^errorBlock ifNil: [[:message :position | ]] ifNotNil: [errorBlock]! !!RBScanner methodsFor: 'error handling' stamp: 'GiselaDecuzzi 6/10/2013 13:12'!errorPosition	^stream position! !!RBScanner methodsFor: 'error handling' stamp: 'GiselaDecuzzi 6/10/2013 13:08'!scannerError: aString	(self errorBlock cull: aString cull: self errorPosition cull: self) ifNil: [ 		^ SyntaxErrorNotification					inClass: Object					category: nil					withCode: stream contents					doitFlag: false					errorMessage: aString					location: stream position + 1	]! !!RBScanner methodsFor: 'initialize-release' stamp: 'lr 11/1/2009 18:31'!on: aStream 	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	comments := OrderedCollection new! !!RBPatternScanner methodsFor: 'accessing' stamp: 'lr 11/7/2009 15:31'!scanToken	currentCharacter = PatternVariableCharacter 		ifTrue: [^self scanPatternVariable].	currentCharacter = $} ifTrue: [^self scanSpecialCharacter].	^super scanToken! !!RBScanner class methodsFor: 'class initialization' stamp: 'lr 12/23/2009 16:40'!initialize	self initializeClassificationTable! !!RBScanner class methodsFor: 'class initialization' stamp: 'lr 11/23/2009 14:46'!initializeChars: characters to: aSymbol 	characters do: [:c | classificationTable at: c asInteger put: aSymbol]! !!RBScanner class methodsFor: 'class initialization' stamp: 'lr 8/30/2010 11:54'!initializeClassificationTable	PatternVariableCharacter := $`.	classificationTable := Array new: 255.	self 		initializeChars: (Character allCharacters			select: [ :each | each isLetter ])		to: #alphabetic.	self initializeUnderscore.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!!%&*+,-/<=>?@\~|' to: #binary.	classificationTable at: 177 put: #binary.	"plus-or-minus"	classificationTable at: 183 put: #binary.	"centered dot"	classificationTable at: 215 put: #binary.	"times"	classificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]{}^' to: #special.	self		initializeChars: (Character allCharacters			select: [ :each | each isSeparator ])		to: #separator! !!RBScanner class methodsFor: 'class initialization' stamp: 'MarcusDenker 4/24/2013 15:51'!initializeUnderscore	self classificationTable		at: $_ asInteger		put: #alphabetic! !!RBScanner class methodsFor: 'testing'!isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteralToken ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/10/2013 11:42'!isVariable: aString 	| scanner token |	scanner := self on: (ReadStream on: aString).	token := scanner next.	token isIdentifier ifFalse: [^false].	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].	^(aString includes: $.) not! !!RBScanner class methodsFor: 'instance creation' stamp: 'lr 8/30/2010 11:56'!new	self initializeUnderscore.	^ super new! !!RBScanner class methodsFor: 'instance creation' stamp: 'lr 11/23/2009 14:50'!on: aStream 	| str |	str := self new on: aStream.	str		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation' stamp: 'GiselaDecuzzi 6/10/2013 13:00'!on: aStream errorBlock: aBlock 	| str |	str := self new on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 16:31'!classificationTable	classificationTable 		ifNil: [ self initializeClassificationTable ].	^ classificationTable! !!RBScanner class methodsFor: 'accessing' stamp: 'lr 11/7/2009 15:31'!patternVariableCharacter	^ PatternVariableCharacter! !!RBSearchRule methodsFor: 'testing'!canMatch: aProgramNode 	owner answer: (answerBlock value: aProgramNode value: owner answer).	^true! !!RBSearchRule methodsFor: 'initialize-release'!searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock! !!RBSequenceNode methodsFor: 'private'!indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]		ifNone: [statements indexOf: aNode]! !!RBSequenceNode methodsFor: 'querying'!bestNodeFor: anInterval 	| node |	node := super bestNodeFor: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBSequenceNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| node |	node := super whichNodeIsContainedBy: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBSequenceNode methodsFor: 'converting' stamp: 'MarcusDenker 1/29/2013 14:19'!asSequenceNode	^self! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:40'!addNode: aNode	aNode parent: self.	(statements notEmpty and: [ statements last isReturn ])		ifTrue: [ self error: 'Cannot add statement after return node' ].	statements := statements asOrderedCollection		add: aNode;		yourself.	^ aNode! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:41'!addNode: aNode before: anotherNode	| index |	index := self indexOfNode: anotherNode.	index = 0		ifTrue: [ ^ self addNode: aNode ].	statements := statements asOrderedCollection		add: aNode beforeIndex: index;		yourself.	aNode parent: self.	^ aNode! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:42'!addNodeFirst: aNode	aNode parent: self.	statements := statements asOrderedCollection		addFirst: aNode;		yourself.	^ aNode! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:43'!addNodes: aCollection	aCollection do: [ :each | each parent: self ].	(statements notEmpty and: [ statements last isReturn ])		ifTrue: [ self error: 'Cannot add statement after return node' ].	statements := statements asOrderedCollection		addAll: aCollection;		yourself.	^ aCollection! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:44'!addNodes: aCollection before: anotherNode	aCollection do: [ :each | self addNode: each before: anotherNode ].	^ aCollection! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:44'!addNodesFirst: aCollection	aCollection do: [ :each | each parent: self ].	statements := statements asOrderedCollection		addAllFirst: aCollection;		yourself.	^ aCollection! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:39'!addSelfReturn	| node |	self lastIsReturn		ifTrue: [ ^ self statements last ].	node := RBReturnNode value: (RBVariableNode named: 'self').	^ self addNode: node! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:45'!addTemporariesNamed: aCollection	^ aCollection collect: [ :each | self addTemporaryNamed: each ]! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:45'!addTemporaryNamed: aString 	| variableNode |	variableNode := RBVariableNode named: aString.	variableNode parent: self.	temporaries := temporaries copyWith: variableNode.	^ variableNode! !!RBSequenceNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:37'!postCopy	super postCopy.	self temporaries: (self temporaries collect: [ :each | each copy ]).	self statements: (self statements collect: [ :each | each copy ])! !!RBSequenceNode methodsFor: 'accessing' stamp: 'lr 1/4/2012 21:38'!addReturn	| node |	statements isEmpty		ifTrue: [ ^ nil ].	statements last isReturn		ifTrue: [ ^ statements last ].	node := RBReturnNode value: statements last.	statements at: statements size put: node.	node parent: self.	^ node! !!RBSequenceNode methodsFor: 'accessing'!allDefinedVariables	^(self temporaryNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing'!allTemporaryVariables	^(self temporaryNames asOrderedCollection)		addAll: super allTemporaryVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing'!children	^(OrderedCollection new)		addAll: self temporaries;		addAll: self statements;		yourself! !!RBSequenceNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/7/2013 11:27'!methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	temporaries do: [:each | methodComments addAll: each comments].	(parent notNil and: [parent isBlock]) 		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].	^methodComments asSortedCollection: [:a :b | a start < b start]! !!RBSequenceNode methodsFor: 'accessing'!removeTemporaryNamed: aName 	temporaries := temporaries reject: [:each | each name = aName]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:14'!start	^ leftBar 		ifNil: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]! !!RBSequenceNode methodsFor: 'accessing'!statements	^statements! !!RBSequenceNode methodsFor: 'accessing'!statements: stmtCollection 	statements := stmtCollection.	statements do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing'!stop	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])! !!RBSequenceNode methodsFor: 'accessing'!temporaries	^temporaries! !!RBSequenceNode methodsFor: 'accessing'!temporaries: tempCollection 	temporaries := tempCollection.	temporaries do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing'!temporaryNames	^temporaries collect: [:each | each name]! !!RBSequenceNode methodsFor: 'accessing'!temporaryVariables	^(super temporaryVariables asOrderedCollection)		addAll: self temporaryNames;		yourself! !!RBSequenceNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:38'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitSequenceNode: self! !!RBSequenceNode methodsFor: 'initialize-release'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	leftBar := leftInteger.	self temporaries: variableNodes.	rightBar := rightInteger! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 1/11/2010 15:42'!leftBar	^ leftBar! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:22'!leftBar: anInteger	leftBar := anInteger! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 20:30'!periods	^ periods! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:21'!periods: anArray	periods := anArray! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 1/11/2010 15:42'!rightBar	^ rightBar! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:22'!rightBar: anInteger	rightBar := anInteger! !!RBSequenceNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/19/2013 16:00'!transformLastToReturn	| last |	statements ifEmpty: [ ^self].	last := statements last.	last isReturn ifFalse: [self replaceNode: last withNode: (RBReturnNode value: last )]! !!RBSequenceNode methodsFor: 'testing'!defines: aName 	^temporaries anySatisfy: [:each | each name = aName]! !!RBSequenceNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBSequenceNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^self statements anySatisfy: #isFaulty.! !!RBSequenceNode methodsFor: 'testing'!isLast: aNode 	| last |	statements isEmpty ifTrue: [^false].	last := statements last.	^last == aNode or: 			[last isMessage and: 					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]! !!RBSequenceNode methodsFor: 'testing'!isSequence	^true! !!RBSequenceNode methodsFor: 'testing'!lastIsReturn	^statements notEmpty and: [statements last lastIsReturn]! !!RBSequenceNode methodsFor: 'testing'!references: aVariableName 	^statements anySatisfy: [:each | each references: aVariableName]! !!RBSequenceNode methodsFor: 'testing'!uses: aNode 	statements isEmpty ifTrue: [^false].	aNode == statements last ifFalse: [^false].	^self isUsed! !!RBSequenceNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/24/2014 20:20'!= anObject 	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self temporaries size = anObject temporaries size ifFalse: [^false].	self temporaries		with: anObject temporaries		do: [:first :second | first = second ifFalse: [^false]].	self statements size = anObject statements size ifFalse: [^false].	self statements		with: anObject statements		do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBSequenceNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/24/2014 20:23'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self statements size = anObject statements size ifFalse: [^false].	self statements		with: anObject statements		do: [:first :second | (first equalTo: second withMapping: aDictionary) ifFalse: [^false]].	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"	self temporaries		do: [:each | aDictionary removeKey: each name ifAbsent: []].	^true! !!RBSequenceNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:48'!hash	^ (self hashForCollection: self temporaries) bitXor: (self hashForCollection: self statements)! !!RBSequenceNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:35'!copyInContext: aDictionary 	^ self class new		temporaries: (self copyList: self temporaries inContext: aDictionary);		statements: (self copyList: self statements inContext: aDictionary);		yourself! !!RBSequenceNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:35'!match: aNode inContext: aDictionary 	self class = aNode class ifFalse: [^false].	^(self 		matchList: temporaries		against: aNode temporaries		inContext: aDictionary) and: 				[self 					matchList: statements					against: aNode statements					inContext: aDictionary]! !!RBSequenceNode methodsFor: 'initialization' stamp: 'lr 2/19/2010 14:44'!initialize	super initialize.	periods := statements := temporaries := #()! !!RBSequenceNode methodsFor: 'replacing' stamp: 'lr 11/1/2009 20:34'!removeDeadCode	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 		to: 1		by: -1		do: 			[:i | 			(statements at: i) isImmediateNode 				ifTrue: 					[self clearReplacements.					statements removeAt: i]].	super removeDeadCode! !!RBSequenceNode methodsFor: 'replacing'!removeNode: aNode	self replaceNode: aNode withNodes: #()! !!RBSequenceNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self statements: (statements 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	self temporaries: (temporaries 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBSequenceNode methodsFor: 'replacing'!replaceNode: aNode withNodes: aCollection 	| index newStatements |	self clearReplacements.	index := self indexOfNode: aNode.	newStatements := OrderedCollection new: statements size + aCollection size.	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].	newStatements addAll: aCollection.	index + 1 to: statements size		do: [:i | newStatements add: (statements at: i)].	aCollection do: [:each | each parent: self].	statements := newStatements! !!RBSequenceNode class methodsFor: 'instance creation'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	^(self new)		leftBar: leftInteger			temporaries: variableNodes			rightBar: rightInteger;		yourself! !!RBSequenceNode class methodsFor: 'instance creation'!statements: statementNodes 	^self temporaries: #() statements: statementNodes! !!RBSequenceNode class methodsFor: 'instance creation'!temporaries: variableNodes statements: statementNodes 	^(self new)		temporaries: variableNodes;		statements: statementNodes;		yourself! !!RBStringReplaceRule methodsFor: 'initialize-release'!methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	| newNode |	newNode := replaceTree copyInContext: self context.	aProgramNode replaceMethodSource: newNode.	newNode copyCommentsFrom: aProgramNode.	^newNode! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString 	^(self new)		searchForMethod: searchString replaceWith: replaceString;		yourself! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: aRBProgramNode replaceWith: replaceString 	^self new searchForTree: aRBProgramNode replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceString		when: aBlock! !!RBStringReplacement methodsFor: 'accessing'!startPosition	^startPosition! !!RBStringReplacement methodsFor: 'accessing'!stopPosition	^stopPosition! !!RBStringReplacement methodsFor: 'accessing'!string	^string! !!RBStringReplacement methodsFor: 'initialize-release'!startPosition: anInteger 	startPosition := anInteger! !!RBStringReplacement methodsFor: 'initialize-release'!stopPosition: anInteger 	stopPosition := anInteger! !!RBStringReplacement methodsFor: 'initialize-release'!string: aString 	string := aString! !!RBStringReplacement class methodsFor: 'instance creation'!replaceFrom: startInteger to: stopInteger with: aString 	^(self new)		startPosition: startInteger;		stopPosition: stopInteger;		string: aString;		yourself! !!RBToken methodsFor: 'testing'!isAssignment	^false! !!RBToken methodsFor: 'testing'!isBinary	^false! !!RBToken methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/10/2013 10:40'!isError	^false! !!RBToken methodsFor: 'testing'!isIdentifier	^false! !!RBToken methodsFor: 'testing'!isKeyword	^false! !!RBToken methodsFor: 'testing'!isLiteralArrayToken	^false! !!RBToken methodsFor: 'testing'!isLiteralToken	^false! !!RBToken methodsFor: 'testing'!isPatternBlock	^false! !!RBToken methodsFor: 'testing'!isPatternVariable	^false! !!RBToken methodsFor: 'testing'!isSpecial	^false! !!RBToken methodsFor: 'accessing'!comments	^comments! !!RBToken methodsFor: 'accessing'!comments: anObject	comments := anObject! !!RBToken methodsFor: 'accessing'!length	^self subclassResponsibility! !!RBToken methodsFor: 'accessing'!removePositions	sourcePointer := nil! !!RBToken methodsFor: 'accessing' stamp: 'lr 2/18/2010 17:25'!start	^ sourcePointer ifNil: [ 0 ]! !!RBToken methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:17'!stop	^ sourcePointer 		ifNil: [ -1 ]		ifNotNil: [ self start + self length - 1 ]! !!RBToken methodsFor: 'printing'!printOn: aStream 	aStream		nextPut: $ ;		nextPutAll: self class name! !!RBToken methodsFor: 'initialize-release'!start: anInteger 	sourcePointer := anInteger! !!RBAssignmentToken methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentToken methodsFor: 'private'!length	^2! !!RBShortAssignmentToken methodsFor: 'private' stamp: 'lr 11/1/2009 20:45'!length	^ 1! !!RBToken class methodsFor: 'instance creation'!start: anInterval 	^self new start: anInterval! !!RBValueNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:14'!addParenthesis: anInterval 	parentheses ifNil: [parentheses := OrderedCollection new: 1].	parentheses add: anInterval! !!RBValueNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:14'!parentheses	^parentheses ifNil: [#()] ifNotNil: [parentheses]! !!RBValueNode methodsFor: 'accessing' stamp: 'MarkRizun 10/31/2014 15:24'!start	^ parentheses ifNil: [ self startWithoutParentheses ] ifNotNil: [ parentheses last first ]! !!RBValueNode methodsFor: 'accessing'!startWithoutParentheses	^self subclassResponsibility! !!RBValueNode methodsFor: 'accessing' stamp: 'MarkRizun 10/31/2014 15:24'!stop	^ parentheses ifNil: [ self stopWithoutParentheses ] ifNotNil: [ parentheses last last ]! !!RBValueNode methodsFor: 'accessing'!stopWithoutParentheses	^self subclassResponsibility! !!RBValueNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self startWithoutParentheses 		and: [anInterval last >= self stopWithoutParentheses]! !!RBValueNode methodsFor: 'testing'!hasParentheses	^self parentheses notEmpty! !!RBValueNode methodsFor: 'testing'!isValue	^true! !!RBValueNode methodsFor: 'testing'!needsParenthesis	^self subclassResponsibility! !!RBValueNode methodsFor: 'converting' stamp: 'MarcusDenker 1/29/2013 14:25'!asSequenceNode	^RBSequenceNode statements: {self} ! !!RBArrayNode methodsFor: 'testing' stamp: 'lr 10/18/2009 16:11'!isArray	^ true! !!RBArrayNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:29'!isFaulty	^self statements anySatisfy: #isFaulty! !!RBArrayNode methodsFor: 'testing' stamp: 'ls 1/24/2000 00:28'!lastIsReturn	statements isEmpty ifTrue:[ ^false ].	^statements last lastIsReturn! !!RBArrayNode methodsFor: 'testing' stamp: 'lr 11/1/2009 20:24'!needsParenthesis	^ false! !!RBArrayNode methodsFor: 'testing' stamp: 'lr 11/1/2009 18:39'!references: aVariableName 	^ statements anySatisfy: [ :each | each references: aVariableName ]! !!RBArrayNode methodsFor: 'testing' stamp: 'lr 11/1/2009 18:40'!uses: aNode 	^ (statements anySatisfy: [ :each | each == aNode ]) or: [ self isUsed ]! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 19:52'!left	^ left! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 19:52'!left: anInteger	left := anInteger! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 20:44'!periods	^ periods! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:23'!periods: anArray	periods := anArray! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 19:52'!right	^ right! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'lr 11/1/2009 19:52'!right: anInteger	right := anInteger! !!RBArrayNode methodsFor: 'initialization' stamp: 'lr 8/14/2011 12:01'!initialize	super initialize.	statements := periods := #()! !!RBArrayNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/22/2014 17:47'!= anObject 	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	self statements size = anObject statements size ifFalse: [ ^ false ].	self statements with: anObject statements do: [ :first :second | first = second ifFalse: [ ^ false ] ].	^ true! !!RBArrayNode methodsFor: 'comparing' stamp: 'lr 10/18/2009 16:15'!equalTo: anObject withMapping: aDictionary 	self class = anObject class 		ifFalse: [ ^ false ].	self statements size = anObject statements size 		ifFalse: [ ^ false ].	self statements with: anObject statements do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [ ^ false ] ].	aDictionary values asSet size = aDictionary size 		ifFalse: [ ^ false ].	^ true! !!RBArrayNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:48'!hash	^ self hashForCollection: self statements! !!RBArrayNode methodsFor: 'replacing' stamp: 'lr 6/6/2008 16:15'!replaceNode: oldNode  withNode: newNode	self statements: (statements collect: [ :statement |		statement == oldNode 			ifTrue: [ newNode ]			ifFalse: [ statement ] ])! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:40'!addNode: aNode	statements := statements asOrderedCollection		add: aNode;		yourself.	aNode parent: self.	^ aNode! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:40'!addNode: aNode before: anotherNode 	| index |	aNode isReturn 		ifTrue: [ self error: 'Cannot add return node' ].	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [ ^ self addNode: aNode ].	statements := statements asOrderedCollection		add: aNode beforeIndex: index;		yourself.	aNode parent: self.	^ aNode! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:42'!addNodeFirst: aNode	statements := statements asOrderedCollection		addFirst: aNode;		yourself.	aNode parent: self.	^ aNode! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:43'!addNodes: aCollection	statements := statements asOrderedCollection		addAll: aCollection;		yourself.	aCollection do: [ :each | each parent: self ].	^ aCollection! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:44'!addNodes: aCollection before: anotherNode 	aCollection do: [ :each | self addNode: each before: anotherNode ].	^ aCollection! !!RBArrayNode methodsFor: 'adding nodes' stamp: 'lr 1/4/2012 21:44'!addNodesFirst: aCollection	statements := statements asOrderedCollection		addAllFirst: aCollection;		yourself.	aCollection do: [ :each | each parent: self ].	^ aCollection! !!RBArrayNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:35'!copyInContext: aDictionary 	^ self class statements: (self copyList: self statements inContext: aDictionary)! !!RBArrayNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:34'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [ ^ false ].	^ self matchList: statements against: aNode statements inContext: aDictionary! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 18:36'!children	^ self statements! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 4/26/2010 20:44'!precedence	^0! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 19:52'!startWithoutParentheses 	^ left! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 20:25'!statementComments	^self comments! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:32'!statements	^statements! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 6/6/2008 16:16'!statements: statements0 	statements := statements0.	statements do: [:statement | statement parent: self]! !!RBArrayNode methodsFor: 'accessing' stamp: 'lr 11/1/2009 19:53'!stopWithoutParentheses 	^ right! !!RBArrayNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:36'!postCopy	super postCopy.	self statements: (self statements collect: [ :each | each copy ])! !!RBArrayNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:36'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor visitArrayNode: self! !!RBArrayNode methodsFor: 'private' stamp: 'lr 5/15/2010 17:29'!indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^ (1 to: statements size) 		detect: [ :each | (statements at: each) == aNode ]		ifNone: [ statements indexOf: aNode ]! !!RBArrayNode class methodsFor: 'instance creation' stamp: 'ajh 3/4/2003 02:03'!statements: statements	^ self new statements: statements! !!RBAssignmentNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode].	variable == aNode ifTrue: [self variable: anotherNode]! !!RBAssignmentNode methodsFor: 'replacing' stamp: 'lr 12/4/2009 15:23'!replaceSourceWith: aNode 	"Check if we need to convert the assignment. Also check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."	(aNode isAssignment and: [ aNode assignmentOperator ~= self assignmentOperator ]) ifTrue: [		self addReplacement: (RBStringReplacement 			replaceFrom: self assignmentPosition			to: self assignmentPosition + self assignmentOperator size - 1			with: aNode assignmentOperator).		(aNode variable = variable and: [ aNode value = value ])			ifTrue: [ ^ self ] ].	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].	(self mappingFor: self value) = aNode arguments first 		ifFalse: [^super replaceSourceWith: aNode].	(self value hasParentheses not 		and: [aNode arguments first precedence >= aNode precedence]) 			ifTrue: 				[self					addReplacement: (RBStringReplacement 								replaceFrom: self value start								to: self value start - 1								with: '(');					addReplacement: (RBStringReplacement 								replaceFrom: self value stop + 1								to: self value stop								with: ')')].	self addReplacement: (RBStringReplacement 				replaceFrom: self variable start				to: self assignmentPosition + 1				with: aNode receiver name , ' ' , aNode selector)! !!RBAssignmentNode methodsFor: '*OpalDecompiler' stamp: 'cb 7/29/2014 18:22'!toDoIncrement: var	var = variable ifFalse: [^ nil].	^ value toDoIncrement: var! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:23'!assignment	^ assignment! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:24'!assignment: anInteger	assignment := anInteger! !!RBAssignmentNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:36'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitAssignmentNode: self! !!RBAssignmentNode methodsFor: 'testing'!assigns: aVariableName 	^variable name = aVariableName or: [value assigns: aVariableName]! !!RBAssignmentNode methodsFor: 'testing'!directlyUses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]! !!RBAssignmentNode methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/10/2013 13:31'!isFaulty	^self variable isFaulty or: [ self value isFaulty].! !!RBAssignmentNode methodsFor: 'testing' stamp: 'ClementBera 7/26/2013 17:15'!needsParenthesis	^parent		ifNil: [false]		ifNotNil: [self precedence > parent precedence]! !!RBAssignmentNode methodsFor: 'testing'!uses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isUsed]! !!RBAssignmentNode methodsFor: 'accessing' stamp: 'StephaneDucasse 3/29/2013 17:33'!assignmentOperator	^  ':=' ! !!RBAssignmentNode methodsFor: 'accessing' stamp: 'lr 11/2/2009 20:50'!assignmentPosition	^ assignment! !!RBAssignmentNode methodsFor: 'accessing'!children	^Array with: value with: variable! !!RBAssignmentNode methodsFor: 'accessing'!precedence	^5! !!RBAssignmentNode methodsFor: 'accessing'!startWithoutParentheses	^variable start! !!RBAssignmentNode methodsFor: 'accessing'!stopWithoutParentheses	^value stop! !!RBAssignmentNode methodsFor: 'accessing'!value	^value! !!RBAssignmentNode methodsFor: 'accessing'!value: aValueNode 	value := aValueNode.	value parent: self! !!RBAssignmentNode methodsFor: 'accessing'!variable	^variable! !!RBAssignmentNode methodsFor: 'accessing'!variable: varNode 	variable := varNode.	variable parent: self! !!RBAssignmentNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self variable = anObject variable and: [self value = anObject value]! !!RBAssignmentNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(self variable equalTo: anObject variable withMapping: aDictionary) 				and: [self value equalTo: anObject value withMapping: aDictionary]]! !!RBAssignmentNode methodsFor: 'comparing'!hash	^self variable hash bitXor: self value hash! !!RBAssignmentNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:35'!copyInContext: aDictionary 	^ self class new		variable: (self variable copyInContext: aDictionary);		value: (self value copyInContext: aDictionary);		yourself! !!RBAssignmentNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:34'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	^(variable match: aNode variable inContext: aDictionary)		and: [value match: aNode value inContext: aDictionary]! !!RBAssignmentNode methodsFor: 'querying' stamp: 'ClementBera 7/26/2013 17:15'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	assignment ifNil: [^super bestNodeFor: anInterval].	((anInterval first between: assignment and: assignment + 1) 		or: [assignment between: anInterval first and: anInterval last]) 			ifTrue: [^self].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBAssignmentNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:35'!postCopy	super postCopy.	self variable: self variable copy.	self value: self value copy! !!RBAssignmentNode methodsFor: 'initialize-release'!variable: aVariableNode value: aValueNode position: anInteger 	self variable: aVariableNode.	self value: aValueNode.	assignment := anInteger! !!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode 	^self 		variable: aVariableNode		value: aValueNode		position: nil! !!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode position: anInteger 	^(self new)		variable: aVariableNode			value: aValueNode			position: anInteger;		yourself! !!RBBlockNode methodsFor: 'testing'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBBlockNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBBlockNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 16:42'!hasArgumentNamed: aString		^ self arguments anySatisfy: [ :argument| argument name = aString ]! !!RBBlockNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 16:42'!hasTemporaryNamed: aString		^ self temporaries anySatisfy: [ :temp| temp name = aString ]! !!RBBlockNode methodsFor: 'testing'!isBlock	^true! !!RBBlockNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:29'!isFaulty	^(self arguments anySatisfy:  #isFaulty ) or: [ self body isFaulty]! !!RBBlockNode methodsFor: 'testing'!isImmediateNode	^true! !!RBBlockNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBBlockNode methodsFor: 'testing'!needsParenthesis	^false! !!RBBlockNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBBlockNode methodsFor: 'testing'!uses: aNode 	aNode = body ifFalse: [^false].	^parent isMessage 		ifTrue: 			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 				includes: parent selector) not 				or: [parent isUsed]]		ifFalse: [self isUsed]! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!bar	^ bar! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!bar: anInteger	bar := anInteger! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!colons	^ colons! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!colons: anArray 	colons := anArray! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!left	^ left! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!left: anInteger	left := anInteger! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!right	^ right! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:25'!right: anInteger	right := anInteger! !!RBBlockNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBBlockNode methodsFor: 'accessing'!arguments	^arguments! !!RBBlockNode methodsFor: 'accessing'!arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]! !!RBBlockNode methodsFor: 'accessing'!blockVariables	| vars |	vars := super blockVariables asOrderedCollection.	vars addAll: self argumentNames.	^vars! !!RBBlockNode methodsFor: 'accessing'!body	^body! !!RBBlockNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBBlockNode methodsFor: 'accessing'!children	^self arguments copyWith: self body! !!RBBlockNode methodsFor: 'accessing'!precedence	^0! !!RBBlockNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/15/2011 16:28'!scope	^ scope! !!RBBlockNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/15/2011 16:28'!scope: aScopedNode	scope := aScopedNode! !!RBBlockNode methodsFor: 'accessing' stamp: 'MarkRizun 10/31/2014 15:31'!startWithoutParentheses	^ left! !!RBBlockNode methodsFor: 'accessing'!statementComments	^self comments! !!RBBlockNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/3/2012 16:43'!statements	^ self body statements! !!RBBlockNode methodsFor: 'accessing' stamp: 'MarkRizun 10/31/2014 15:31'!stopWithoutParentheses	^ right! !!RBBlockNode methodsFor: 'accessing' stamp: 'CamilloBruni 2/3/2012 17:18'!temporaries	^ self body temporaries! !!RBBlockNode methodsFor: 'accessing' stamp: 'CamilloBruni 12/8/2011 15:17'!temporaryNames	^ self body temporaryNames! !!RBBlockNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 5/5/2015 15:10'!sourceNodeForPC: anInteger 	^ self methodNode sourceNodeForPC: anInteger! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'CamilleTeruel 2/14/2014 14:37'!enclosingMethodOrBlockNode	^ parent ifNotNil: [ parent methodOrBlockNode ]! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 8/5/2013 11:03'!isClean	"a block is clean if it has no escaping vars, has no non local return and its children are clean"	self isInlined ifTrue: [ ^ false ].	self scope hasEscapingVars ifTrue: [ ^ false ].	self lastIsReturn ifTrue: [ ^ false ].	^ super isClean	! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:11'!isInlined	parent isMessage ifFalse: [ ^ false ].	parent isInlineAndOr ifTrue: [^ true].	parent isInlineIf ifTrue: [^ true].	parent isInlineIfNil ifTrue: [^ true].	^ self isInlinedLoop! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:18'!isInlinedLoop	parent isMessage ifFalse: [ ^ false ].	parent isInlineToDo ifTrue: [^ true].	parent isInlineWhile ifTrue: [^ true].	parent isInlineTimesRepeat ifTrue: [^ true].	(parent parent isArray and: [parent parent parent isMessage and: [parent parent parent isInlineCase]]) ifTrue: [^ true].	parent isInlineCase ifTrue: [^ true].  "otherwise branch"	^ false! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 8/5/2013 11:04'!lastIsReturn	^ self body lastIsReturn! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 7/26/2013 15:28'!methodOrBlockNode	"^ self"! !!RBBlockNode methodsFor: '*opalcompiler-core' stamp: 'jorgeRessia 11/20/2009 16:40'!owningScope	^ self scope ifNil: ["inlined" ^ parent owningScope]! !!RBBlockNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/23/2014 19:23'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self body = anObject body ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	self arguments with: anObject arguments do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBBlockNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/23/2014 19:43'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	self arguments		with: anObject arguments		do: [:first :second |	(first equalTo: second withMapping: aDictionary) ifFalse: [^false]].	(self body equalTo: anObject body withMapping: aDictionary)		ifFalse: [^false].	self arguments do: [:each | aDictionary removeKey: each name].	^true! !!RBBlockNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:48'!hash	^ (self hashForCollection: self arguments) bitXor: self body hash! !!RBBlockNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBBlockNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:35'!copyInContext: aDictionary 	^ self class new		arguments: (self copyList: self arguments inContext: aDictionary);		body: (self body copyInContext: aDictionary);		yourself! !!RBBlockNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:34'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	^(self 		matchList: arguments		against: aNode arguments		inContext: aDictionary) 			and: [body match: aNode body inContext: aDictionary]! !!RBBlockNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:36'!postCopy	super postCopy.	self arguments: (self arguments collect: [ :each | each copy ]).	self body: self body copy! !!RBBlockNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:36'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitBlockNode: self! !!RBBlockNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/10/2014 17:23'!isJust: literal	body  statements size = 1 ifFalse: [ ^ false ].	body  statements anyOne isLiteralNode ifFalse: [ ^ false ].	^ body  statements anyOne value == literal! !!RBBlockNode class methodsFor: 'instance creation'!arguments: argNodes body: sequenceNode 	^(self new)		arguments: argNodes;		body: sequenceNode;		yourself! !!RBBlockNode class methodsFor: 'instance creation'!body: sequenceNode 	^self arguments: #() body: sequenceNode! !!RBCascadeNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each bestNodeFor: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBCascadeNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each whichNodeIsContainedBy: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBCascadeNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:36'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitCascadeNode: self! !!RBCascadeNode methodsFor: 'testing'!directlyUses: aNode 	^messages last = aNode and: [self isDirectlyUsed]! !!RBCascadeNode methodsFor: 'testing'!isCascade	^true! !!RBCascadeNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:29'!isFaulty	^self messages anySatisfy: #isFaulty! !!RBCascadeNode methodsFor: 'testing' stamp: 'ClementBera 7/26/2013 17:15'!needsParenthesis	^parent 		ifNil: [false]		ifNotNil: [self precedence > parent precedence]! !!RBCascadeNode methodsFor: 'testing'!uses: aNode 	^messages last = aNode and: [self isUsed]! !!RBCascadeNode methodsFor: 'initialize-release'!messages: messageNodes semicolons: integerCollection 	self messages: messageNodes.	semicolons := integerCollection! !!RBCascadeNode methodsFor: 'accessing'!children	^self messages! !!RBCascadeNode methodsFor: 'accessing'!messages	^messages! !!RBCascadeNode methodsFor: 'accessing'!messages: messageNodeCollection 	messages := messageNodeCollection.	messages do: [:each | each parent: self]! !!RBCascadeNode methodsFor: 'accessing'!precedence	^4! !!RBCascadeNode methodsFor: 'accessing'!receiver	^self messages first receiver! !!RBCascadeNode methodsFor: 'accessing'!startWithoutParentheses	^messages first start! !!RBCascadeNode methodsFor: 'accessing' stamp: 'PabloHerrero 11/7/2013 11:13'!statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	statementComments addAll: messages first receiver statementComments.	messages do: 			[:each | 			each arguments 				do: [:arg | statementComments addAll: arg statementComments]].	^statementComments asSortedCollection: [:a :b | a start < b start]! !!RBCascadeNode methodsFor: 'accessing'!stopWithoutParentheses	^messages last stop! !!RBCascadeNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/23/2014 20:39'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self messages size = anObject messages size ifFalse: [^false].	self messages with: anObject messages do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBCascadeNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/23/2014 20:41'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self messages size = anObject messages size ifFalse: [^false].	self messages		with: anObject messages		do: [:first :second | (first equalTo: second withMapping: aDictionary) ifFalse: [^false]].	^true! !!RBCascadeNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:49'!hash	^ self hashForCollection: self messages! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:26'!semicolons	^ semicolons! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'lr 2/12/2010 19:26'!semicolons: anArray	semicolons := anArray! !!RBCascadeNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:36'!copyInContext: aDictionary 	^ self class new		messages: (self copyList: self messages inContext: aDictionary);		yourself! !!RBCascadeNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:34'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	^self 		matchList: messages		against: aNode messages		inContext: aDictionary! !!RBCascadeNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:36'!postCopy	super postCopy.	self messages: (self messages collect: [ :each | each copy ])! !!RBCascadeNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self messages: (messages 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes 	^self new messages: messageNodes! !!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes semicolons: integerCollection 	^self new messages: messageNodes semicolons: integerCollection! !!RBLiteralNode methodsFor: 'testing'!isImmediateNode	^true! !!RBLiteralNode methodsFor: 'testing' stamp: 'jws 10/30/2016 22:58'!isLiteral	^true! !!RBLiteralNode methodsFor: 'testing'!isLiteralNode	^true! !!RBLiteralNode methodsFor: 'testing'!needsParenthesis	^false! !!RBLiteralNode methodsFor: 'comparing' stamp: 'lr 5/30/2010 11:34'!= anObject 	self == anObject ifTrue: [^true].	^self class = anObject class! !!RBLiteralNode methodsFor: 'comparing'!hash	^self value hash! !!RBLiteralNode methodsFor: 'accessing'!precedence	^0! !!RBLiteralNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 10:37'!start: anInteger	start := anInteger! !!RBLiteralNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/24/2013 15:47'!startWithoutParentheses	^start! !!RBLiteralNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 10:37'!stop: anInteger	stop := anInteger! !!RBLiteralNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/24/2013 15:47'!stopWithoutParentheses	^stop! !!RBLiteralNode methodsFor: 'accessing'!value	^self subclassResponsibility! !!RBLiteralNode methodsFor: 'private-replacing'!replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self formattedCode)! !!RBLiteralNode methodsFor: 'private-replacing'!replaceSourceWith: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)! !!RBLiteralArrayNode methodsFor: 'accessing'!children	^contents! !!RBLiteralArrayNode methodsFor: 'accessing'!contents	^contents! !!RBLiteralArrayNode methodsFor: 'accessing'!value	| array |	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 				new: contents size.	1 to: contents size		do: [:each | array at: each put: (contents at: each) value].	^array! !!RBLiteralArrayNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/25/2014 19:22'!= anObject 	super = anObject ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	self contents		with: anObject contents		do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBLiteralArrayNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/25/2014 19:24'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	self contents		with: anObject contents		do: [:first :second | (first equalTo: second withMapping: aDictionary) ifFalse: [^false]].	^true! !!RBLiteralArrayNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self contents: (contents 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBLiteralArrayNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:29'!isFaulty	^self contents anySatisfy: #isFaulty! !!RBLiteralArrayNode methodsFor: 'testing'!isForByteArray	^isByteArray! !!RBLiteralArrayNode methodsFor: 'testing'!isLiteralArray	^true! !!RBLiteralArrayNode methodsFor: 'initialize-release'!contents: aRBLiteralNodeCollection 	contents := aRBLiteralNodeCollection.	contents do: [:each | each parent: self]! !!RBLiteralArrayNode methodsFor: 'initialize-release'!startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	start := startInteger.	self contents: anArray.	stop := stopInteger.	isByteArray := aBoolean! !!RBLiteralArrayNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:35'!postCopy	super postCopy.	self contents: (self contents collect: [ :each | each copy ])! !!RBLiteralArrayNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:36'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitLiteralArrayNode: self! !!RBLiteralArrayNode methodsFor: 'private-replacing' stamp: 'BernardoContreras 8/25/2014 19:27'!replaceSourceWith: aNode 	(self class = aNode class and: 			[self isForByteArray = aNode isForByteArray 				and: [self contents size = aNode contents size]]) 		ifFalse: [^super replaceSourceWith: aNode].	self contents		with: aNode contents 		do: [:first :second | first = second ifFalse: [ first replaceSourceWith: second]]! !!RBLiteralArrayNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:36'!copyInContext: aDictionary 	^ self class 		startPosition: nil		contents: (self copyList: self contents inContext: aDictionary)		stopPosition: nil		isByteArray: isByteArray! !!RBLiteralArrayNode methodsFor: 'matching' stamp: 'lr 5/30/2010 11:34'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	self isForByteArray = aNode isForByteArray ifFalse: [^false].	^self 		matchList: contents		against: aNode contents		inContext: aDictionary! !!RBLiteralNode class methodsFor: 'instance creation'!value: aValue 	^((aValue class == Array or: [aValue class == ByteArray]) 		ifTrue: [RBLiteralArrayNode]		ifFalse: [RBLiteralValueNode]) value: aValue! !!RBLiteralArrayNode class methodsFor: 'instance creation'!startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	^(self new)		startPosition: startInteger			contents: anArray			stopPosition: stopInteger			isByteArray: aBoolean;		yourself! !!RBLiteralArrayNode class methodsFor: 'instance creation'!value: aValue 	^(self new)		startPosition: nil			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])			stopPosition: nil			isByteArray: aValue class ~~ Array;		yourself! !!RBLiteralValueNode methodsFor: 'matching' stamp: 'PabloHerrero 10/24/2013 13:30'!copyInContext: aDictionary	^ self class value: self value! !!RBLiteralValueNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^false.! !!RBLiteralValueNode methodsFor: 'accessing' stamp: 'PabloHerrero 2/16/2015 01:12'!sourceText	^ sourceText ifNil: [		String streamContents: [:aStream|						value isSymbol				ifTrue: [					aStream nextPut: $#.					((RBScanner isSelector: value) and: [value ~~ #'||']) 						ifTrue: [aStream nextPutAll: value]						ifFalse: [value asString printOn: aStream]]				ifFalse: [ 					value class == Character 						ifTrue: 							[aStream nextPut: $$;	nextPut: value]						ifFalse: [ value storeOn: aStream ]]] ]! !!RBLiteralValueNode methodsFor: 'accessing' stamp: 'PabloHerrero 2/16/2015 01:19'!value	^ value! !!RBLiteralValueNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:37'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitLiteralNode: self! !!RBLiteralValueNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 10/24/2013 14:09'!value: aValue start: aPosition stop: anotherPosition	value := aValue.	start := aPosition. 	stop := anotherPosition.! !!RBLiteralValueNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 2/16/2015 01:19'!value: aValue start: aPosition stop: anotherPosition source: aString 	self value: aValue start: aPosition stop: anotherPosition.	sourceText := aString.! !!RBLiteralValueNode methodsFor: 'comparing' stamp: 'lr 5/30/2010 11:36'!= anObject 	^ super = anObject 		and: [ self value = anObject value 		and: [ self value species = anObject value species ] ]! !!RBLiteralValueNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 01:23'!value: aValue	^ self value: aValue start: 0 stop: -1! !!RBLiteralValueNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 01:20'!value: aValue start: aPosition stop: anotherPosition  	^ self new		value: aValue start: aPosition stop: anotherPosition;		yourself.! !!RBLiteralValueNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 01:20'!value: aValue start: aPosition stop: anotherPosition  source: aString  	^ self new		value: aValue start: aPosition stop: anotherPosition source: aString;		yourself.! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 1/9/2015 15:36'!isInlineAndOr	self methodNode compilationContext optionInlineAndOr ifFalse: [ ^false ]. 	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(and: or:) includes: self selector) ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each isBlock ])  ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each arguments isEmpty ]) ifFalse: [^ false ].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 1/12/2015 12:17'!isInlineCase	self methodNode compilationContext optionInlineCase ifFalse: [ ^false ]. 	self isCascaded ifTrue: [^ false].	(#(caseOf: caseOf:otherwise:) includes: self selector) ifFalse: [^ false].	self arguments size = 2 ifTrue: [  "otherwise block"		self arguments last isBlock ifFalse: [^ false]].	self arguments first isArray ifFalse: [^ false].	self arguments first statements do: [:assoc |		(assoc isMessage and: [assoc selector == #->]) ifFalse: [^ false].		assoc receiver isBlock ifFalse: [^ false].		assoc receiver arguments isEmpty ifFalse: [^ false].		assoc arguments first isBlock ifFalse: [^ false].	].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'jws 10/29/2016 09:08'!isInlineIf	self methodNode compilationContext optionInlineIf ifFalse: [ ^false ]. 	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:) includes: self selector) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	self arguments do: [:block |		block arguments isEmpty ifFalse: [			SemanticError new				node: self;				compilationContext: self methodNode compilationContext;				messageText: 'ifTrue:ifFalse: takes zero-arg blocks';				signal.			^ false		]	].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 1/12/2015 12:17'!isInlineIfNil	| assertNone assertOneOrNone |		self methodNode compilationContext optionInlineIfNil ifFalse: [ ^false ]. 	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifNil: ifNotNil: ifNil:ifNotNil: ifNotNil:ifNil:) includes: self selector) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	assertNone := [:block | 		block arguments isEmpty ifFalse: [^ false]	].	assertOneOrNone := [:block | 		block arguments size > 1 ifTrue: [^ false]	].	self selector == #ifNil: 			ifTrue: [assertNone value: self arguments first].	self selector == #ifNil:ifNotNil: 		ifTrue: [assertNone value: self arguments first.  assertOneOrNone value: self arguments last].	self selector == #ifNotNil: 		ifTrue: [assertOneOrNone value: self arguments first].	self selector == #ifNotNil:ifNil: 		ifTrue: [assertOneOrNone value: self arguments first. assertNone value: self arguments last].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 1/12/2015 12:16'!isInlineTimesRepeat	| block |	self methodNode compilationContext optionInlineTimesRepeat ifFalse: [ ^false ]. 	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	#timesRepeat: = self selector ifFalse: [^ false].	block := self arguments last.	block isBlock ifFalse: [^ false].	block arguments size isZero ifFalse: [^ false].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'jws 10/29/2016 09:11'!isInlineToDo	| block step |	self methodNode compilationContext optionInlineToDo ifFalse: [ ^false ]. 	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(to:do: to:by:do:) includes: self selector) ifFalse: [^ false].	block := self arguments last.	block isBlock ifFalse: [^ false].	block arguments size = 1 ifFalse: [^ false].	self arguments first isVariable ifTrue: [ 		(ParseTreeSearcher new			matches: self arguments first name , ' := `@object' do: [:n :a | true];			executeTree: block initialAnswer: false) ifTrue: [^ false].	].	self arguments size = 3 "to:by:do:" ifTrue: [		step := self arguments second.		step isLiteralNode ifFalse: [^ false].		step value = 0 ifTrue: [^ false].	].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 1/12/2015 12:16'!isInlineWhile		self methodNode compilationContext optionInlineWhile ifFalse: [ ^false ]. 	self isCascaded ifTrue: [^ false].	(#(whileFalse: whileTrue: whileFalse whileTrue) includes: self selector) ifFalse: [^ false].	self receiver isBlock ifFalse: [^ false].	self receiver arguments isEmpty ifFalse: [self notify: 'while receiver block must have no arguments'. ^ false].	self arguments isEmpty ifFalse: [		self arguments first isBlock ifFalse: [^ false].		self arguments first arguments isEmpty ifFalse: [^ false].	].	^ true! !!RBMessageNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 1/6/2015 11:08'!isInlined 	self methodNode compilationContext optionInlineNone ifTrue: [ ^false ]. 	self isInlineIf ifTrue: [^true].	self isInlineIfNil  ifTrue: [^true]. 	self isInlineAndOr  ifTrue: [^true].	self isInlineWhile ifTrue: [^true].	self isInlineToDo  ifTrue: [^true].	self isInlineCase  ifTrue: [^true].	self isInlineTimesRepeat ifTrue: [ ^true].	^false.! !!RBMessageNode methodsFor: 'querying' stamp: 'PabloHerrero 10/21/2013 17:45'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	self keywordsIntervals do:			[:each | 			((each rangeIncludes: anInterval first) 				or: [anInterval rangeIncludes:  each first]) 					ifTrue: [^self]].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBMessageNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/25/2014 20:22'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self receiver = anObject receiver 		and: [self selector = anObject selector]) ifFalse: [^false].	self arguments		with: anObject arguments		do: [:first :second | first = second ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'comparing' stamp: 'BernardoContreras 8/25/2014 20:23'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	((self receiver equalTo: anObject receiver withMapping: aDictionary)		and: [self selector = anObject selector]) ifFalse: [^false].	self arguments		with: anObject arguments		do: [:first :second | (first equalTo: second withMapping: aDictionary) ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'comparing' stamp: 'lr 3/7/2010 13:50'!hash	^ (self receiver hash bitXor: self selector hash) bitXor: (self hashForCollection: self arguments)! !!RBMessageNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 7/10/2014 13:30'!ifNilReceiver	^ receiver! !!RBMessageNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 8/1/2014 09:40'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test  |	(selector == #whileTrue:	 and: [initStmt isAssignment	 and: [initStmt variable isMemberOf: RBTemporaryNode]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessage	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	"The block must not overwrite the limit"	(limit isVariable and: [body anySatisfy: [:e | e isAssignment and: [e variable = limit]]])		ifTrue: [^nil]. 	toDoBlock := RBBlockNode body: (RBSequenceNode statements: body allButLast).	toDoBlock arguments: (Array with: variable).	variable propertyAt: #hidden put: true.	increment value = 1 ifTrue: [		^ RBMessageNode 			receiver: initStmt value			selector: #to:do:			arguments: (Array with: limit with: toDoBlock)].	^ RBMessageNode 		receiver: initStmt value		selector: #to:by:do:		arguments: (Array with: limit with: increment with: toDoBlock)! !!RBMessageNode methodsFor: '*OpalDecompiler' stamp: 'cb 7/29/2014 18:24'!toDoIncrement: variable	(receiver = variable and: [selector = #+]) 		ifFalse: [^ nil].	(arguments first isLiteralNode and: [ arguments first value isInteger ])		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!RBMessageNode methodsFor: '*OpalDecompiler' stamp: 'ClementBera 8/1/2014 09:40'!toDoLimit: variable	(receiver = variable and: [selector == #<= or: [selector == #>= ]]) 		ifTrue: [ ^ arguments first ]		ifFalse: [ ^ nil ]! !!RBMessageNode methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:15'!arguments	^arguments ifNil: [#()] ifNotNil: [arguments]! !!RBMessageNode methodsFor: 'accessing'!arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]! !!RBMessageNode methodsFor: 'accessing'!children	^(OrderedCollection with: self receiver)		addAll: self arguments;		yourself! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/22/2013 14:56'!debugHighlightStart	^ self  keywordsPositions first! !!RBMessageNode methodsFor: 'accessing' stamp: 'jorgeRessia 11/20/2009 16:40'!debugHighlightStop	^ self stopWithoutParentheses! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 12:42'!keywords	^ selector keywords.! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 11:36'!keywordsIntervals	^ selector keywords		with: self keywordsPositions 		collect: [ :keyword :start | start to: (start == 0 ifTrue: [ -1 ] ifFalse: [ start + keyword size - 1]) ].! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/28/2013 17:02'!keywordsPositions	^keywordsPositions ifNil: [ (selector keywords collect: [:char| 0 ]) asIntegerArray ]! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/16/2013 22:53'!keywordsPositions: aPositionsList	keywordsPositions := aPositionsList ifNotNil: [:list| list asIntegerArray ].! !!RBMessageNode methodsFor: 'accessing'!numArgs	^self selector numArgs! !!RBMessageNode methodsFor: 'accessing'!precedence	^self isUnary 		ifTrue: [1]		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]! !!RBMessageNode methodsFor: 'accessing'!receiver	^receiver! !!RBMessageNode methodsFor: 'accessing'!receiver: aValueNode 	receiver := aValueNode.	receiver parent: self! !!RBMessageNode methodsFor: 'accessing'!renameSelector: newSelector andArguments: varNodeCollection 	self		arguments: varNodeCollection;		selector: newSelector! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/17/2013 15:40'!selector	^ selector.! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 3/7/2015 21:02'!selector: aSelector	keywordsPositions := nil.	selector := aSelector asSymbol.! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 12:42'!selectorParts	^ self keywords collect: #asSymbol.! !!RBMessageNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:21'!sentMessages	^ super sentMessages		add: self selector;		yourself! !!RBMessageNode methodsFor: 'accessing'!startWithoutParentheses	^receiver start! !!RBMessageNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/21/2013 17:51'!stopWithoutParentheses	^arguments isEmpty 		ifTrue: [self keywordsIntervals first last]		ifFalse: [arguments last stop]! !!RBMessageNode methodsFor: 'private-replacing'!isContainmentReplacement: aNode 	^(self mappingFor: self receiver) = aNode 		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]! !!RBMessageNode methodsFor: 'private-replacing'!replaceContainmentSourceWith: aNode 	| originalNode needsParenthesis |	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].	originalNode := (self mappingFor: self receiver) = aNode 				ifTrue: [self receiver]				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].	self		addReplacement: (RBStringReplacement 					replaceFrom: self start					to: originalNode start - 1					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));		addReplacement: (RBStringReplacement 					replaceFrom: originalNode stop + 1					to: self stop					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))! !!RBMessageNode methodsFor: 'private-replacing'!replaceSourceWith: aNode 	(self isContainmentReplacement: aNode) 		ifTrue: [^self replaceContainmentSourceWith: aNode].	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	^self replaceSourceWithMessageNode: aNode! !!RBMessageNode methodsFor: 'private-replacing' stamp: 'PabloHerrero 10/22/2013 14:02'!replaceSourceWithMessageNode: aNode 	| isBinaryToKeyword newSelectorParts  oldkeywordsIntervals|	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].	self arguments with: aNode arguments		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].	(self mappingFor: self receiver) = aNode receiver 		ifFalse:			[(self receiver isVariable and: [aNode receiver isVariable])				ifFalse:					[^super replaceSourceWith: aNode].			self addReplacement:				(RBStringReplacement					replaceFrom: self receiver start					to: self receiver stop					with: aNode receiver name)].	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 		ifTrue: 			[(self hasParentheses not and: [self parent precedence <= aNode precedence]) 				ifTrue: 					[self						addReplacement: (RBStringReplacement 									replaceFrom: self start									to: self start - 1									with: '(');						addReplacement: (RBStringReplacement 									replaceFrom: self stop + 1									to: self stop									with: ')')]].								newSelectorParts := aNode selectorParts.	oldkeywordsIntervals := self keywordsIntervals.		self selectorParts keysAndValuesDo: [:index :oldPart| 			(newSelectorParts at: index) ~= oldPart				ifTrue: 					[self addReplacement: (RBStringReplacement 								replaceFrom: (oldkeywordsIntervals at: index) first								to: (oldkeywordsIntervals at: index) last								with: ((isBinaryToKeyword 										and: [(self source at: (oldkeywordsIntervals at: index) first - 1) isSeparator not]) 											ifTrue: [' ' , newSelectorParts at: index]											ifFalse: [newSelectorParts at: index]))]].! !!RBMessageNode methodsFor: 'matching' stamp: 'PabloHerrero 10/15/2013 00:08'!copyInContext: aDictionary 	^self class		receiver: (self receiver copyInContext: aDictionary)		selector: self selector		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]).! !!RBMessageNode methodsFor: 'matching' stamp: 'BernardoContreras 8/25/2014 20:29'!match: aNode inContext: aDictionary 	aNode class = self class ifFalse: [^false].	self selector = aNode selector ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self arguments		with: aNode arguments		do: [:first :second | (first match: second inContext: aDictionary) ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	"If we're inside a cascade node and are changing the receiver, change all the receivers"	receiver == aNode 		ifTrue: 			[self receiver: anotherNode.			(parent notNil and: [parent isCascade]) 				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMessageNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:37'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitMessageNode: self! !!RBMessageNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 2/16/2015 00:44'!receiver: aValueNode selector: aSelector keywordsPositions: positionList arguments: valueNodes	aSelector numArgs == valueNodes size		ifFalse: 			[self error: 'Attempting to assign selector with wrong number of arguments.'].	self 		receiver: aValueNode;		arguments: valueNodes;		selector: aSelector;		keywordsPositions: positionList.! !!RBMessageNode methodsFor: 'testing'!isBinary	^(self isUnary or: [self isKeyword]) not! !!RBMessageNode methodsFor: 'testing'!isCascaded	^parent notNil and: [parent isCascade]! !!RBMessageNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^self receiver isFaulty or: [self arguments anySatisfy: #isFaulty]! !!RBMessageNode methodsFor: 'testing'!isFirstCascaded	^self isCascaded and: [parent messages first == self]! !!RBMessageNode methodsFor: 'testing' stamp: 'PabloHerrero 10/14/2013 23:24'!isKeyword	^(selector indexOf: $:) ~= 0.! !!RBMessageNode methodsFor: 'testing'!isMessage	^true! !!RBMessageNode methodsFor: 'testing' stamp: 'lr 10/20/2009 11:43'!isSelfSend	^ self receiver isVariable and: [ self receiver name = 'self' ]! !!RBMessageNode methodsFor: 'testing' stamp: 'lr 10/20/2009 11:43'!isSuperSend	^ self receiver isVariable and: [ self receiver name = 'super' ]! !!RBMessageNode methodsFor: 'testing'!isUnary	^arguments isEmpty! !!RBMessageNode methodsFor: 'testing' stamp: 'lr 12/4/2011 16:30'!lastIsReturn	^ (#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil:ifNotNil: #ifNotNil:ifNil:) includes: self selector)		and: [ arguments first isBlock and: [ arguments first body lastIsReturn 		and: [ arguments last isBlock and: [ arguments last body lastIsReturn ] ] ] ]! !!RBMessageNode methodsFor: 'testing' stamp: 'ClementBera 7/26/2013 17:16'!needsParenthesis	^parent 		ifNil: [false]		ifNotNil: 			[self precedence > parent precedence 				or: [self precedence = parent precedence and: [self isUnary not]]]! !!RBMessageNode methodsFor: 'copying' stamp: 'lr 11/1/2009 22:36'!postCopy	super postCopy.	self receiver: self receiver copy.	self arguments: (self arguments collect: [ :each | each copy ])! !!RBMessageNode class methodsFor: '*GT-InspectorExtensions-Core' stamp: 'StefanReichhart 4/9/2015 12:00'!gtExampleAddition	<gtExample>	^ RBMessageNode 				receiver: (RBVariableNode named: 'self')				selector: #+				arguments: (Array with: (RBLiteralNode value: 0))! !!RBMessageNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 00:44'!receiver: aValueNode selector: aSelector 	^self 		receiver: aValueNode		selector: aSelector		arguments: #()! !!RBMessageNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 00:44'!receiver: aValueNode selector: aSelector arguments: valueNodes 	^self		receiver: aValueNode		selector: aSelector		keywordsPositions: nil		arguments: valueNodes.! !!RBMessageNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 00:44'!receiver: aValueNode selector: aSelector keywordsPositions: positionList arguments: valueNodes	^(self new)		receiver: aValueNode			selector: aSelector			keywordsPositions: positionList 			arguments: valueNodes;		yourself.! !!RBPatternBlockNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:27'!sentMessages	^ OrderedCollection new! !!RBPatternBlockNode methodsFor: 'visitor' stamp: 'StephaneDucasse 3/29/2013 15:37'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitPatternBlockNode: self! !!RBPatternBlockNode methodsFor: 'matching'!addArgumentWithNameBasedOn: aString to: aRBBlockNode 	| name index vars |	name := aString.	vars := aRBBlockNode allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	aRBBlockNode 		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'PabloHerrero 10/24/2013 14:56'!constructLookupNodeFor: aString in: aRBBlockNode 	| argumentNode |	argumentNode := RBLiteralNode value: aString.		^RBMessageNode 		receiver: (RBVariableNode named: 'self')		selector: #lookupMatchFor:in:		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:30'!copyInContext: aDictionary 	^ self replacingBlock value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'MarcusDenker 8/28/2013 10:20'!createBlockFor: aRBBlockNode 	self replacePatternNodesIn: aRBBlockNode.	^Smalltalk compiler 		source: aRBBlockNode formattedCode;		receiver: self;		evaluate! !!RBPatternBlockNode methodsFor: 'matching'!createMatchingBlock	| newBlock |	self arguments size > 2 		ifTrue: 			[self 				error: 'Search blocks can only contain arguments for the node and matching dictionary'].	newBlock := RBBlockNode arguments: arguments body: body.	newBlock arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].	newBlock arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock! !!RBPatternBlockNode methodsFor: 'matching'!createReplacingBlock	| newBlock |	self arguments size > 1 		ifTrue: 			[self 				error: 'Replace blocks can only contain an argument for the matching dictionary'].	newBlock := RBBlockNode arguments: arguments body: body.	self arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock! !!RBPatternBlockNode methodsFor: 'matching'!lookupMatchFor: aString in: aDictionary 	^aDictionary at: aString		ifAbsent: 			[| variableNode |			variableNode := RBPatternVariableNode named: aString.			aDictionary at: variableNode ifAbsent: [nil]]! !!RBPatternBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'ClementBera 7/26/2013 17:16'!matchingBlock	^ valueBlock ifNil: [valueBlock := self createMatchingBlock]! !!RBPatternBlockNode methodsFor: 'matching'!replacePatternNodesIn: aRBBlockNode 	aRBBlockNode body nodesDo: 			[:each | 			(each isVariable and: [each isPatternNode]) 				ifTrue: 					[each 						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'ClementBera 7/26/2013 17:16'!replacingBlock	^ valueBlock ifNil: [valueBlock := self createReplacingBlock]! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'PabloHerrero 2/16/2015 00:51'!copyInContext: aDictionary	| keywordSelector |	self isList 		ifTrue: [ ^ aDictionary at: self ].	keywordSelector := self isSelectorList 		ifTrue: [ aDictionary at: self selectorParts first ]		ifFalse: [ '' join: (self selectorParts collect: [ :each | aDictionary at: each ])].	^ RBMessageNode		receiver: (self receiver copyInContext: aDictionary)		selector: keywordSelector		arguments: (self copyList: self arguments inContext: aDictionary)! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList 		ifTrue: 			[^(aDictionary at: self selectorParts first ifAbsentPut: [aNode selector]) 				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'lr 5/30/2010 10:35'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size = aNode arguments size		ifFalse: [ ^ false ].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [ ^ false ].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary) 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'PabloHerrero 10/22/2013 14:02'!matchSelectorAgainst: aNode inContext: aDictionary 	self selectorParts with: aNode selectorParts do: [ :first :second |		| keyword |		keyword := aDictionary			at: first			ifAbsentPut: [ 				first isPatternVariable 					ifTrue: [ second ]					ifFalse: [ first ] ].		keyword = second 			ifFalse: [ ^ false ] ].	^ true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isList	^isCascadeList and: [parent notNil and: [parent isCascade]]! !!RBPatternMessageNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isSelectorList	^isList! !!RBPatternMessageNode methodsFor: 'accessing' stamp: 'lr 5/30/2010 14:22'!sentMessages	^ super sentMessages		remove: self selector ifAbsent: [ ];		yourself! !!RBPatternMessageNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 10/22/2013 14:02'!receiver: aValueNode selector: aSymbol keywordsPositions: positionList arguments: valueNodes	| message |	self		receiver: aValueNode;		selector: aSymbol;		keywordsPositions: positionList;		arguments: valueNodes.			isCascadeList := isList := false.	message := self selectorParts first.		2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]! !!RBPatternMessageNode methodsFor: 'private'!matchingClass	^RBMessageNode! !!RBPatternMessageNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 17:15'!receiver: aValueNode selector: aSelector keywordsPositions: positionList arguments: valueNodes	^aSelector isPatternVariable		ifTrue: 			[super				receiver: aValueNode				selector: aSelector 				keywordsPositions: positionList asIntegerArray				arguments: valueNodes]		ifFalse: 			[RBMessageNode 				receiver: aValueNode				selector: aSelector 				keywordsPositions: positionList asIntegerArray				arguments: valueNodes]! !!RBPatternWrapperBlockNode methodsFor: 'visitor' stamp: 'StephaneDucasse 3/29/2013 15:38'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitPatternWrapperBlockNode: self! !!RBPatternWrapperBlockNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:30'!copyInContext: aDictionary 	"I don't know what this would mean, so ignore it."	^ wrappedNode copyInContext: aDictionary! !!RBPatternWrapperBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].	^super match: aNode inContext: aDictionary! !!RBPatternWrapperBlockNode methodsFor: 'accessing'!precedence	^1! !!RBPatternWrapperBlockNode methodsFor: 'accessing'!wrappedNode	^wrappedNode! !!RBPatternWrapperBlockNode methodsFor: 'accessing'!wrappedNode: aRBProgramNode 	wrappedNode := aRBProgramNode.	aRBProgramNode parent: self! !!RBValueToken methodsFor: 'printing' stamp: 'CamilloBruni 2/20/2012 23:11'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	value printOn: aStream.	aStream nextPutAll: ')'! !!RBValueToken methodsFor: 'private'!length	^value size! !!RBValueToken methodsFor: 'initialize-release'!value: aString start: anInteger 	value := aString.	sourcePointer := anInteger! !!RBValueToken methodsFor: 'accessing'!value	^value! !!RBValueToken methodsFor: 'accessing'!value: anObject	value := anObject! !!RBBinarySelectorToken methodsFor: 'testing'!isBinary	^true! !!RBErrorToken methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/10/2013 10:40'!isError	^true! !!RBErrorToken methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/10/2013 15:51'!value: theValue start: tokenStart cause: errorCause location: errorPosition	self value: theValue start: tokenStart .	location := errorPosition.	cause := errorCause .! !!RBErrorToken methodsFor: 'accesing' stamp: 'GiselaDecuzzi 6/10/2013 10:48'!cause	^ cause! !!RBErrorToken methodsFor: 'accessing' stamp: 'GiselaDecuzzi 6/10/2013 15:51'!location	^ location! !!RBIdentifierToken methodsFor: 'testing'!isIdentifier	^true! !!RBIdentifierToken methodsFor: 'testing' stamp: 'lr 11/7/2009 15:30'!isPatternVariable	^value first = RBScanner patternVariableCharacter! !!RBKeywordToken methodsFor: 'testing'!isKeyword	^true! !!RBKeywordToken methodsFor: 'testing' stamp: 'lr 11/7/2009 15:30'!isPatternVariable	^value first = RBScanner patternVariableCharacter! !!RBLiteralArrayToken methodsFor: 'testing'!isForByteArray	^value last = $[! !!RBLiteralArrayToken methodsFor: 'testing'!isLiteralArrayToken	^true! !!RBLiteralToken methodsFor: 'accessing'!realValue	^value! !!RBLiteralToken methodsFor: 'accessing'!stop: anObject 	stopPosition := anObject! !!RBLiteralToken methodsFor: 'initialize-release'!value: aString start: anInteger stop: stopInteger 	value := aString.	sourcePointer := anInteger.	stopPosition := stopInteger! !!RBLiteralToken methodsFor: 'testing'!isLiteralToken	^true! !!RBLiteralToken methodsFor: 'testing'!isMultiKeyword	^false! !!RBLiteralToken methodsFor: 'testing' stamp: 'PabloHerrero 10/25/2013 16:52'!isNumberLiteralToken	^false! !!RBLiteralToken methodsFor: 'printing'!storeOn: aStream 	value isSymbol 		ifTrue: 			[aStream nextPut: $#.			((RBScanner isSelector: value) and: [value ~~ #'||']) 				ifTrue: [aStream nextPutAll: value]				ifFalse: [value asString printOn: aStream].			^self].	value class == Character 		ifTrue: 			[aStream				nextPut: $$;				nextPut: value.			^self].	value storeOn: aStream! !!RBLiteralToken methodsFor: 'private'!length	^stopPosition - self start + 1! !!RBMultiKeywordLiteralToken methodsFor: 'testing'!isMultiKeyword	^true! !!RBNumberLiteralToken methodsFor: 'testing' stamp: 'PabloHerrero 10/25/2013 16:52'!isNumberLiteralToken	^true.! !!RBNumberLiteralToken methodsFor: 'printing'!storeOn: aStream 	aStream nextPutAll: source! !!RBNumberLiteralToken methodsFor: 'accessing'!source	^source! !!RBNumberLiteralToken methodsFor: 'initialize-release'!source: aString 	source := aString! !!RBPatternBlockToken methodsFor: 'testing'!isPatternBlock	^true! !!RBSpecialCharacterToken methodsFor: 'private'!length	^1! !!RBSpecialCharacterToken methodsFor: 'testing'!isSpecial	^true! !!RBValueToken class methodsFor: 'instance creation'!value: aString start: anInteger 	^self new value: aString start: anInteger! !!RBErrorToken class methodsFor: 'instance creation' stamp: 'GiselaDecuzzi 6/10/2013 15:54'!value: value start: tokenStart cause: errorCause location: thePosition	^ self new		value: value			start: tokenStart			cause: errorCause			location: thePosition;		yourself! !!RBLiteralToken class methodsFor: 'instance creation'!value: anObject 	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: nil		stop: nil! !!RBLiteralToken class methodsFor: 'instance creation'!value: aString start: anInteger stop: stopInteger 	^(self new)		value: aString			start: anInteger			stop: stopInteger;		yourself! !!RBNumberLiteralToken class methodsFor: 'instance creation'!value: aNumber start: anInteger stop: stopInteger source: sourceString 	^(self 		value: aNumber		start: anInteger		stop: stopInteger)		source: sourceString;		yourself! !!RBVariableNode methodsFor: 'testing' stamp: 'GiselaDecuzzi 6/5/2013 10:30'!isFaulty	^false! !!RBVariableNode methodsFor: 'testing'!isImmediateNode	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'TestRunner 11/2/2009 21:18'!isRead	^ self isWrite not and: [ self isUsed ]! !!RBVariableNode methodsFor: 'testing'!isVariable	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'TestRunner 11/2/2009 21:21'!isWrite	^ self parent notNil and: [ self parent isAssignment and: [ self parent variable == self ] ]! !!RBVariableNode methodsFor: 'testing'!needsParenthesis	^false! !!RBVariableNode methodsFor: 'testing'!references: aVariableName 	^self name = aVariableName! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/22/2013 16:50'!binding	^self propertyAt: #binding ifAbsent: [nil].! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/22/2013 16:51'!binding: aSemVar	aSemVar ifNil: [^self removeProperty: #binding ifAbsent: []].	self propertyAt: #binding put: aSemVar.! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/22/2013 16:50'!isArg	^self binding isArg! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 8/5/2013 11:03'!isClean	^ (self isInstance | self isSpecialVariable) not! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'jorgeRessia 11/20/2009 16:40'!isGlobal	^self binding isGlobal! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/22/2013 16:50'!isInstance	^self binding isInstance! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'ClementBera 8/5/2013 11:07'!isSpecialVariable	^ self binding isSpecialVariable! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 5/22/2013 16:50'!isTemp	^self binding isTemp! !!RBVariableNode methodsFor: '*opalcompiler-core' stamp: 'MarcusDenker 6/14/2013 15:44'!isUndeclared	^self binding isUndeclared! !!RBVariableNode methodsFor: 'comparing' stamp: 'CamilloBruni 12/15/2011 15:17'!= anObject 	self == anObject ifTrue: [^true].	((anObject isKindOf: self class) or: [self isKindOf: anObject class]) 		ifFalse: [^false].	^self name = anObject name! !!RBVariableNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]! !!RBVariableNode methodsFor: 'comparing'!hash	^self name hash! !!RBVariableNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:39'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitVariableNode: self! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/23/2013 14:12'!name	^ name! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 10/23/2013 14:12'!name: aName	name := aName asSymbol.! !!RBVariableNode methodsFor: 'accessing'!precedence	^0! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 2/10/2015 19:03'!start	^ start! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 2/10/2015 19:03'!start: aPosition	start := aPosition! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 10:38'!startWithoutParentheses	^ start! !!RBVariableNode methodsFor: 'accessing' stamp: 'PabloHerrero 1/5/2015 10:38'!stopWithoutParentheses	^ start + name size - 1.! !!RBVariableNode methodsFor: 'replacing'!replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self name)! !!RBVariableNode methodsFor: 'replacing'!replaceSourceWith: aNode	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)! !!RBVariableNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 1/5/2015 10:38'!named: aName start: aPosition	self name: aName.	self start: aPosition.! !!RBVariableNode methodsFor: 'matching' stamp: 'PabloHerrero 10/23/2013 14:41'!copyInContext: aDictionary 	^ self class named: name.! !!RBArgumentNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:32'!isArgument	^ true! !!RBArgumentNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:35'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitArgumentNode: self! !!RBPatternVariableNode methodsFor: 'private'!matchingClass	^RBVariableNode! !!RBPatternVariableNode methodsFor: 'accessing'!parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]! !!RBPatternVariableNode methodsFor: 'initialize-release' stamp: 'MarcusDenker 2/27/2015 11:01'!initializePatternVariables	| myname |	myname := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: myname size		do: 			[:i | 			| character |			character := myname at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]! !!RBPatternVariableNode methodsFor: 'initialize-release' stamp: 'PabloHerrero 10/23/2013 15:58'!named: aName start: aPosition	super named: aName start: aPosition.	self initializePatternVariables! !!RBPatternVariableNode methodsFor: 'matching' stamp: 'lr 11/24/2009 23:37'!copyInContext: aDictionary 	^ (aDictionary at: self) copy! !!RBPatternVariableNode methodsFor: 'matching' stamp: 'CamilloBruni 12/15/2011 15:32'!match: aNode inContext: aDictionary 	self isAnything 		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement 		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	(aNode isKindOf: self matchingClass) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'matching'!matchLiteral: aNode inContext: aDictionary 	^aNode isLiteralNode		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]! !!RBPatternVariableNode methodsFor: 'matching'!matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'testing-matching'!isAnything	^isAnything! !!RBPatternVariableNode methodsFor: 'testing-matching'!isList	^isList! !!RBPatternVariableNode methodsFor: 'testing-matching'!isLiteralNode	^isLiteral! !!RBPatternVariableNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternVariableNode methodsFor: 'testing-matching'!isStatement	^isStatement! !!RBPatternVariableNode methodsFor: 'testing-matching'!recurseInto	^recurseInto! !!RBSelfNode methodsFor: '*SmartSuggestions' stamp: 'GiselaDecuzzi 4/16/2013 17:14'!specialCommands 	^#().! !!RBSelfNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:38'!acceptVisitor: aProgramNodeVisitor 	^ aProgramNodeVisitor visitSelfNode: self! !!RBSelfNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:33'!isSelf	^ true! !!RBSuperNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:33'!isSuper	^ true! !!RBSuperNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:39'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitSuperNode: self! !!RBTemporaryNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:39'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitTemporaryNode: self! !!RBTemporaryNode methodsFor: 'testing' stamp: 'CamilloBruni 12/15/2011 14:32'!isTemp	^ true! !!RBThisContextNode methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:39'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor visitThisContextNode: self! !!RBVariableNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/23/2013 15:52'!identifierNamed: anIdentifierName at: aPosition		anIdentifierName = 'self'		ifTrue: [ ^ RBSelfNode named: anIdentifierName start: aPosition ].	anIdentifierName = 'thisContext'		ifTrue: [ ^ RBThisContextNode named: anIdentifierName start: aPosition ].	anIdentifierName = 'super'		ifTrue: [ ^ RBSuperNode named: anIdentifierName start: aPosition ].	^ self named: anIdentifierName start: aPosition.! !!RBVariableNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/23/2013 14:28'!named: aName	^self named: aName start: 0.! !!RBVariableNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 10/23/2013 14:11'!named: aName start: aPosition	^self new 		named: aName start: aPosition; 		yourself.! !!RBPatternVariableNode class methodsFor: 'instance creation' stamp: 'PabloHerrero 2/16/2015 17:16'!identifierNamed: anIdentifierName at: aPosition	^anIdentifierName isPatternVariable 		ifTrue: [super identifierNamed: anIdentifierName at: aPosition]		ifFalse: [RBVariableNode identifierNamed: anIdentifierName at: aPosition]! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:00'!initializeReceiver:anObject andSelector:aSymbol	receiver := anObject.	selector := aSymbol.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value	^receiver perform: selector.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument	^receiver perform: selector with: firstArgument.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument value: secondArgument	^receiver perform: selector with: firstArgument with: secondArgument.! !!ReceiverAndSelector class methodsFor: 'as yet unclassified' stamp: 'bh 11/4/2000 23:59'!forReceiver:anObject andSelector:aSymbol	^self new initializeReceiver:anObject andSelector:aSymbol.! !!Refactoring methodsFor: 'utilities'!associationForClassVariable: aName in: aClass ifAbsent: aBlock 	^aClass realClass classPool associationAt: aName asSymbol		ifAbsent: [aClass realClass classPool associationAt: aName asString ifAbsent: aBlock]! !!Refactoring methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	^RBCondition checkInstanceVariableName: aName in: aClass! !!Refactoring methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^RBCondition checkMethodName: aName in: aClass! !!Refactoring methodsFor: 'utilities'!poolVariableNamesFor: aClass 	| pools |	pools := Set new.	aClass withAllSuperclasses do: 			[:each | 			each allPoolDictionaryNames do: 					[:pool | 					pools addAll: ((Smalltalk at: pool asSymbol) keys 								collect: [:name | name asString])]].	^pools! !!Refactoring methodsFor: 'utilities'!safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol! !!Refactoring methodsFor: 'utilities' stamp: 'jws 10/23/2016 05:39'!whichVariableNode: aParseTree inInterval: anInterval name: aName	| matcher block |	matcher := ParseTreeSearcher new.	block := [ :aNode :answer | 	(aNode intersectsInterval: anInterval)		ifTrue: [ aNode ]		ifFalse: [ answer ] ].	matcher		matches: aName do: block;		matchesArgument: aName do: block.	^ matcher executeTree: aParseTree initialAnswer: nil! !!Refactoring methodsFor: 'testing'!canReferenceVariable: aString in: aClass 	(aClass definesVariable: aString) ifTrue: [^true].	(self model includesGlobal: aString asSymbol) ifTrue: [^true].	^(self poolVariableNamesFor: aClass) includes: aString! !!Refactoring methodsFor: 'accessing'!changes	^self model changes! !!Refactoring methodsFor: 'accessing'!copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copy].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict! !!Refactoring methodsFor: 'accessing'!options	^options isNil ifTrue: [self class refactoringOptions] ifFalse: [options]! !!Refactoring methodsFor: 'accessing'!options: aDictionary 	options := aDictionary! !!Refactoring methodsFor: 'accessing'!setOption: aSymbol toUse: aBlock 	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [dict := dict copy].	dict at: aSymbol put: aBlock.	self options: dict! !!Refactoring methodsFor: 'support'!checkClass: aRBClass selector: aSelector using: aMatcher 	| parseTree |	parseTree := aRBClass parseTreeFor: aSelector.	parseTree notNil ifTrue: [aMatcher executeTree: parseTree].	^aMatcher answer! !!Refactoring methodsFor: 'support'!convertAllReferencesTo: aSymbol using: searchReplacer 	self model allReferencesTo: aSymbol		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertAllReferencesToClass: aRBClass using: searchReplacer 	self model allReferencesToClass: aRBClass		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertClasses: classSet select: aBlock using: searchReplacer 	classSet do: 			[:aClass | 			(aBlock value: aClass) do: 					[:selector | 					self 						convertMethod: selector						for: aClass						using: searchReplacer]]! !!Refactoring methodsFor: 'support'!convertMethod: selector for: aClass using: searchReplacer 	"Convert the parse tree for selector using the searchReplacer. If a	change is made then compile it into the changeBuilder."	| parseTree |	parseTree := aClass parseTreeFor: selector.	parseTree isNil ifTrue: [^self].	(searchReplacer executeTree: parseTree) 		ifTrue: [aClass compileTree: searchReplacer tree]! !!Refactoring methodsFor: 'preconditions'!checkPreconditions	| conditions block |	conditions := self preconditions.	conditions check 		ifFalse: 			[block := conditions errorBlock.			block notNil 				ifTrue: [self refactoringError: conditions errorString with: block]				ifFalse: [self refactoringError: conditions errorString]]! !!Refactoring methodsFor: 'preconditions'!preconditions	self subclassResponsibility! !!Refactoring methodsFor: 'private'!classObjectFor: anObject 	anObject isBehavior ifTrue: [^self model classFor: anObject].	anObject isSymbol ifTrue: [^self model classNamed: anObject].	^anObject! !!Refactoring methodsFor: 'private'!onError: aBlock do: errorBlock 	^aBlock on: self class preconditionSignal		do: 			[:ex | 			errorBlock value.			ex return: nil]! !!Refactoring methodsFor: 'private'!primitiveExecute	self checkPreconditions.	self transform! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringError: aString 	RefactoringError signal: aString! !!Refactoring methodsFor: 'private'!refactoringError: aString with: aBlock 	RefactoringError raiseSignal: aString with: aBlock! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringWarning: aString 	RefactoringWarning signal: aString! !!Refactoring methodsFor: 'private'!uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printString , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol! !!Refactoring methodsFor: 'transforming'!defaultEnvironment	^BrowserEnvironment new! !!Refactoring methodsFor: 'transforming'!execute	self primitiveExecute.	RefactoringManager instance addRefactoring: self! !!Refactoring methodsFor: 'transforming'!model	^model isNil 		ifTrue: 			[model := (RBNamespace onEnvironment: self defaultEnvironment)						name: self printString;						yourself]		ifFalse: [model]! !!Refactoring methodsFor: 'transforming'!performComponentRefactoring: aRefactoring 	aRefactoring copyOptionsFrom: self options.	aRefactoring primitiveExecute! !!Refactoring methodsFor: 'transforming'!transform	self subclassResponsibility! !!Refactoring methodsFor: 'initialize-release'!initialize! !!Refactoring methodsFor: 'initialize-release'!model: aRBNamespace 	model := aRBNamespace! !!Refactoring methodsFor: 'requests'!openBrowserOn: anEnvironment 	^(self options at: #openBrowser) value: self value: anEnvironment! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/26/2004 10:16'!request: aString	^FillInTheBlank request: aString! !!Refactoring methodsFor: 'requests'!requestImplementorToInline: implementorsCollection 	^(self options at: #implementorToInline) value: self		value: implementorsCollection! !!Refactoring methodsFor: 'requests' stamp: 'dvf 9/8/2001 19:32'!requestMethodNameFor: aMethodName 	^(self options at: #methodName) value: self value: aMethodName! !!Refactoring methodsFor: 'requests'!requestSelfArgumentName	^(self options at: #selfArgumentName) value: self! !!Refactoring methodsFor: 'requests'!selectVariableToMoveMethodTo: aSelector class: aClass 	^(self options at: #selectVariableToMoveTo) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/15/2004 11:48'!selectVariableTypesFrom: initialTypeCollection selected: selectedTypeCollection 	"Temporary workaround to get something usable here,	which will avoid entering the emergency evaluator too..."		"^(self options at: #variableTypes) 		value: self		value: initialTypeCollection		value: selectedTypeCollection"	| init classes |	init := ''.	initialTypeCollection do: [:each | init := init, each asString, Character space asString].	classes := FillInTheBlank request: 'Here are the types found by the RefactoryTyper.	Since you are smarter than it, you can edit the list to add or remove 	relevant classes at your will' initialAnswer: init.	^ (classes findTokens: Character space asString) collect: 		[:each | self model classFor: (Smalltalk at: each withBlanksTrimmed asSymbol)].	! !!Refactoring methodsFor: 'requests'!shouldExtractAssignmentTo: aString 	^(self options at: #extractAssignment) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldInlineExpression: aString 	^(self options at: #inlineExpression) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldOverride: aSelector in: aClass 	^(self options at: #alreadyDefined) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests'!shouldUseExistingMethod: aSelector 	^(self options at: #useExistingMethod) value: self value: aSelector! !!AbstractVariablesRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!abstractClassVariable: aString	| refactoring rewriter nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	refactoring := CreateAccessorsForVariableRefactoring		model: self model		variable: aString		class: nonMetaClass		classVariable: true.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	fromClass isMeta		ifTrue: [ 			rewriter				replace: aString , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self ' , refactoring getterMethod ]		ifFalse: [ 			rewriter				replace: aString , ' := ``@object' with: ('self class <1s> ``@object' expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self class ' , refactoring getterMethod ].	(rewriter executeTree: tree)		ifTrue: [ tree := rewriter tree ]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractClassVariables	| variables |	classVarReaders isEmpty & classVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: classVarReaders;		addAll: classVarWriters.	variables do: [:each | self abstractClassVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!abstractInstanceVariable: aString	| refactoring rewriter |	refactoring := CreateAccessorsForVariableRefactoring		model: self model		variable: aString		class: fromClass		classVariable: false.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	rewriter		replace: aString , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);		replace: aString with: 'self ' , refactoring getterMethod.	(rewriter executeTree: tree)		ifTrue: [ tree := rewriter tree ]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractInstanceVariables	| variables |	instVarReaders isEmpty & instVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: instVarReaders;		addAll: instVarWriters.	variables do: [:each | self abstractInstanceVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!classVariableNames	| nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	^(nonMetaClass allClassVariableNames collect: [:each | each asString]) asSet! !!AbstractVariablesRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!computeVariablesToAbstract	| searcher |	instVarReaders := Set new.	instVarWriters := Set new.	classVarReaders := Set new.	classVarWriters := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: '`var := ``@anything' do: [ :aNode :answer | self processAssignmentNode: aNode ];		matches: '`var' do: [ :aNode :answer | self processReferenceNode: aNode ].	searcher executeTree: tree.	self removeDefinedClassVariables! !!AbstractVariablesRefactoring methodsFor: 'transforming'!instanceVariableNames	^fromClass allInstanceVariableNames asSet! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processAssignmentNode: aNode 	| varName |	varName := aNode variable name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarWriters add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarWriters add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processReferenceNode: aNode 	| varName |	varName := aNode name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarReaders add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarReaders add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!removeDefinedClassVariables	| selectionBlock nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	selectionBlock := 			[:varName | 			(toClasses detect: 					[:each | 					((each nonMetaclass) 						includesClass: (nonMetaClass whoDefinesClassVariable: varName)) not]				ifNone: [nil]) notNil].	classVarReaders := classVarReaders select: selectionBlock.	classVarWriters := classVarWriters select: selectionBlock! !!AbstractVariablesRefactoring methodsFor: 'transforming'!transform	self hasVariablesToAbstract 		ifTrue: 			[self 				refactoringWarning: 'This method has direct variable references which<n>will need to be converted to getter/setters.' 						expandMacros].	self abstractInstanceVariables.	self abstractClassVariables! !!AbstractVariablesRefactoring methodsFor: 'initialize-release'!abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	| poolRefactoring |	tree := aBRProgramNode.	fromClass := self classObjectFor: fromBehavior.	toClasses := behaviorCollection 				collect: [:each | self classObjectFor: each].	ignore := aVariableName.	poolRefactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: tree				fromClass: fromClass				toClasses: toClasses.	self performComponentRefactoring: poolRefactoring.	self computeVariablesToAbstract! !!AbstractVariablesRefactoring methodsFor: 'testing'!hasVariablesToAbstract	^(instVarReaders isEmpty 		& instVarWriters isEmpty 		& classVarReaders isEmpty 		& classVarWriters isEmpty) 		not! !!AbstractVariablesRefactoring methodsFor: 'accessing'!parseTree	^tree! !!AbstractVariablesRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ClassRefactoring methodsFor: 'initialize-release'!className: aName	className := aName! !!AddClassRefactoring methodsFor: 'initialize-release'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	self className: aName.	superclass := self classObjectFor: aClass.	subclasses := aCollection collect: [:each | self classObjectFor: each].	category := aSymbol! !!AddClassRefactoring methodsFor: 'preconditions'!preconditions	| cond |	cond := ((RBCondition isMetaclass: superclass) 				errorMacro: 'Superclass must not be a metaclass') not.	cond := subclasses inject: cond				into: 					[:sub :each | 					sub 						& ((RBCondition isMetaclass: each) 								errorMacro: 'Subclass must <1?not :>be a metaclass') not 							& (RBCondition isImmediateSubclass: each of: superclass)].	^cond & (RBCondition isValidClassName: className) 		& (RBCondition isGlobal: className in: self model) not 			& (RBCondition isSymbol: category) 			& ((RBCondition withBlock: [category isEmpty not]) 					errorMacro: 'Invalid category name')! !!AddClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addClass: #';		nextPutAll: className;		nextPutAll: ' superclass: '.	superclass storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPutAll: ' category: '.	category storeOn: aStream.	aStream nextPut: $)! !!AddClassRefactoring methodsFor: 'transforming' stamp: 'bh 4/10/2001 14:25'!transform	(self model)		defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' 					expandMacrosWith: superclass					with: className					with: category asString);		reparentClasses: subclasses to: (self model classNamed: className asSymbol)! !!ChildrenToSiblingsRefactoring methodsFor: 'private-accessing'!abstractSuperclass	^self model classNamed: className asSymbol! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!addSuperclass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: className				superclass: parent superclass				subclasses: (Array with: parent)				category: parent category)! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!changeIsKindOfReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: '``@object isKindOf: ' , parent name with: '``@object isKindOf: ' , className.	self convertAllReferencesToClass: parent using: replacer! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpMethods	self pushUpMethodsFrom: parent.	self pushUpMethodsFrom: parent metaclass! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpVariables	self pullUpInstanceVariables.	self pullUpClassInstanceVariables.	self pullUpClassVariables.	self pullUpPoolVariables! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!reparentSubclasses	self model reparentClasses: subclasses to: self abstractSuperclass! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!transform	self		addSuperclass;		pushUpVariables;		pushUpMethods;		changeIsKindOfReferences;		reparentSubclasses! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!computeSubclassSupersOf: aClass 	| selectors |	selectors := Set new.	aClass subclasses do: 			[:each | 			each selectors 				do: [:sel | selectors addAll: (each parseTreeFor: sel) superMessages]].	^selectors! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!createSubclassResponsibilityFor: aSelector in: aClass 	| source |	(aClass superclass definesMethod: aSelector) ifTrue: [^self].	source := self subclassResponsibilityFor: aSelector in: aClass.	source isNil ifTrue: [^self].	aClass superclass compile: source		classified: (aClass protocolsFor: aSelector)! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUp: aSelector in: aClass 	| source |	source := aClass sourceCodeFor: aSelector.	source isNil 		ifFalse: 			[aClass superclass compile: source				classified: (aClass protocolsFor: aSelector)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUpMethodsFrom: aClass 	| selectorsToPushUp |	selectorsToPushUp := self selectorsToPushUpFrom: aClass.	aClass selectors do: 			[:each | 			(selectorsToPushUp includes: each) 				ifTrue: [self pushUp: each in: aClass]				ifFalse: [self createSubclassResponsibilityFor: each in: aClass]].	selectorsToPushUp do: [:each | aClass removeMethod: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!selectorsToPushUpFrom: aClass 	| superSelectors |	superSelectors := self computeSubclassSupersOf: aClass.	^aClass selectors select: 			[:each | 			(superSelectors includes: each) or: [self shouldPushUp: each from: aClass]]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!shouldPushUp: aSelector from: aClass 	^((aClass isMeta 		ifTrue: [subclasses collect: [:each | each metaclass]]		ifFalse: [subclasses]) 			detect: [:each | (each directlyDefinesMethod: aSelector) not]			ifNone: [nil]) notNil! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!subclassResponsibilityFor: aSelector in: aClass 	| methodNode position source |	source := aClass sourceCodeFor: aSelector.	methodNode := RBParser parseMethod: source onError: [:err :pos | ^nil].	position := methodNode arguments isEmpty 				ifTrue: [methodNode selectorParts last stop]				ifFalse: [methodNode arguments last stop].	^'<1s><n><t>self subclassResponsibility' 		expandMacrosWith: (source copyFrom: 1 to: position)! !!ChildrenToSiblingsRefactoring methodsFor: 'initialize-release'!name: aClassName class: aClass subclasses: subclassCollection 	className := aClassName asSymbol.	parent := self model classFor: aClass.	subclasses := subclassCollection 				collect: [:each | self model classFor: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'preconditions'!preconditions	^subclasses 		inject: ((RBCondition isMetaclass: parent) 				errorMacro: 'Superclass must not be a metaclass') not 				& (RBCondition isValidClassName: className) 					& (RBCondition isGlobal: className in: self model) not		into: 			[:sub :each | 			sub 				& ((RBCondition isMetaclass: each) 						errorMacro: 'Subclass must <1?not :>be a metaclass') not 					& (RBCondition isImmediateSubclass: each of: parent)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass metaclass.	parent metaclass instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent classVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpClassVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpPoolVariables	"Don't remove the pool variables from the subclass since they might be referenced there."	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent poolDictionaryNames 		do: [:each | newSuperclass addPoolDictionary: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: #';		nextPutAll: className;		nextPutAll: ' class: '.	parent storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPut: $)! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!computePoolsToMove	| poolVariables searcher |	poolVariables := self poolVariableNamesFor: fromClass.	pools := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: '`var'		do: [ :aNode :answer | 			| varName pool |			varName := aNode name.			(aNode whoDefines: varName) isNil				ifTrue: [ 					(poolVariables includes: varName)						ifTrue: [ 							pool := self whichPoolDefines: varName.							pool notNil								ifTrue: [ pools add: pool ] ] ] ].	searcher executeTree: parseTree! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePool: aSymbol toClass: aClass 	| nonMetaClass |	nonMetaClass := aClass nonMetaclass.	(nonMetaClass definesPoolDictionary: aSymbol) 		ifFalse: [nonMetaClass addPoolDictionary: aSymbol]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePoolVariables	pools 		do: [:poolDict | toClasses do: [:each | self movePool: poolDict toClass: each]]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!poolVariableNamesIn: poolName 	^(Smalltalk at: poolName ifAbsent: [Dictionary new]) keys 		collect: [:name | name asString]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!transform	self computePoolsToMove.	self hasPoolsToMove 		ifTrue: 			[self 				refactoringWarning: 'This method contains references to pools<n>which may need to be moved.' 						expandMacros].	self movePoolVariables! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!whichPoolDefines: varName 	| currentClass |	currentClass := fromClass.	[currentClass isNil] whileFalse: 			[currentClass allPoolDictionaryNames 				do: [:each | ((self poolVariableNamesIn: each) includes: varName) ifTrue: [^each]].			currentClass := currentClass superclass].	^nil! !!ExpandReferencedPoolsRefactoring methodsFor: 'initialize-release'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	fromClass := self model classFor: aClass.	parseTree := aParseTree.	toClasses := classCollection collect: [:each | self model classFor: each]! !!ExpandReferencedPoolsRefactoring methodsFor: 'testing'!hasPoolsToMove	^pools isEmpty not! !!ExpandReferencedPoolsRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector 	aSelector numArgs = 0 ifTrue: [^aSelector].	^self buildSelectorString: aSelector		withPermuteMap: (1 to: aSelector numArgs)! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!AddMethodRefactoring methodsFor: 'initialize-release'!addMethod: aString toClass: aClass inProtocols: protocolList 	class := self classObjectFor: aClass.	source := aString.	protocols := protocolList! !!AddMethodRefactoring methodsFor: 'preconditions'!preconditions	| selector method |	method := RBParser parseMethod: source				onError: 					[:string :position | 					^RBCondition 						withBlock: [self refactoringError: 'The sources could not be parsed']].	selector := method selector.	selector isNil ifTrue: [self refactoringError: 'Invalid source.'].	^(RBCondition canUnderstand: selector in: class) not! !!AddMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addMethod: ''';		nextPutAll: source;		nextPutAll: ''' toClass: '.	class storeOn: aStream.	aStream nextPutAll: ' inProtocols: '.	protocols storeOn: aStream.	aStream nextPut: $)! !!AddMethodRefactoring methodsFor: 'transforming'!transform	class compile: source classified: protocols! !!ChangeMethodNameRefactoring methodsFor: 'testing'!hasPermutedArguments	oldSelector numArgs = newSelector numArgs ifFalse: [^true].	1 to: oldSelector numArgs		do: [:i | (permutation at: i) = i ifFalse: [^true]].	^false! !!ChangeMethodNameRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^false! !!ChangeMethodNameRefactoring methodsFor: 'private'!implementors	implementors isNil 		ifTrue: [implementors := self model allImplementorsOf: oldSelector].	^implementors! !!ChangeMethodNameRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| oldArgs |	oldArgs := parseTree arguments.	parseTree arguments: (permutation collect: [:each | oldArgs at: each]).	parseTree selector: newSelector! !!ChangeMethodNameRefactoring methodsFor: 'private' stamp: 'jws 10/23/2016 05:38'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector withPermuteMap: permutation.	rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.	^ rewriteRule! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!myConditions	^self subclassResponsibility! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!preconditions	"This refactoring only preserves behavior if all implementors are renamed."	| conditions |	conditions := self myConditions 				& (RBCondition definesSelector: oldSelector in: class) 					& (RBCondition isValidMethodName: newSelector for: class).	conditions := self implementors inject: conditions				into: 					[:condition :each | 					condition & (RBCondition hierarchyOf: each canUnderstand: newSelector) not].	^conditions 		& (RBCondition withBlock: 					[self implementors size > 1 						ifTrue: 							[self refactoringWarning: ('This will modify all <1p> implementors.' 										expandMacrosWith: self implementors size)].					true])! !!ChangeMethodNameRefactoring methodsFor: 'accessing'!newSelector	^newSelector! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!removeRenamedImplementors	self implementors do: [:each | each removeMethod: oldSelector]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameImplementors	self implementors do: 			[:each | 			| parseTree |			parseTree := each parseTreeFor: oldSelector.			parseTree isNil 				ifTrue: [self refactoringError: 'Could not parse source code.'].			self implementorsCanBePrimitives 				ifFalse: 					[parseTree isPrimitive 						ifTrue: 							[self refactoringError: ('<1p>''s implementation of #<2s> is a primitive' 										expandMacrosWith: each										with: oldSelector)]].			self modifyImplementorParseTree: parseTree in: each.			each compileTree: parseTree classified: (each protocolsFor: oldSelector)]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameMessageSends	self convertAllReferencesTo: oldSelector using: self parseTreeRewriter! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!transform	self renameImplementors.	self renameMessageSends.	oldSelector == newSelector ifTrue: [^self].	self removeRenamedImplementors! !!ChangeMethodNameRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:27'!renameMethod: aSelector in: aClass to: newSel permutation: aMap 	oldSelector := aSelector asSymbol.	newSelector := newSel asSymbol.	class := self classObjectFor: aClass.	permutation := aMap! !!AddParameterRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:28'!addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init 	self 		renameMethod: aSelector		in: aClass		to: newSel		permutation: (1 to: newSel numArgs).	initializer := init! !!AddParameterRefactoring methodsFor: 'preconditions'!checkSendersAccessTo: name 	| violatorClass |	(#('self' 'super') includes: name) ifTrue: [^self].	violatorClass := self senders 				detect: [:each | (self canReferenceVariable: name in: each) not]				ifNone: [nil].	violatorClass notNil 		ifTrue: 			[self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' 						expandMacrosWith: name						with: violatorClass)]! !!AddParameterRefactoring methodsFor: 'preconditions' stamp: 'jws 10/23/2016 05:39'!checkVariableReferencesIn: aParseTree	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '`var'		do: [ :aNode :answer | 			| name |			name := aNode name.			(aNode whoDefines: name) isNil				ifTrue: [ self checkSendersAccessTo: name ] ].	searcher executeTree: aParseTree! !!AddParameterRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: newSelector printString 								, ' doesn''t have the proper number of arguments.'].			self verifyInitializationExpression.			true]! !!AddParameterRefactoring methodsFor: 'preconditions'!verifyInitializationExpression	| tree |	tree := RBParser parseExpression: initializer				onError: 					[:msg :index | 					self refactoringError: 'Illegal initialization code because:.' , msg].	tree isValue 		ifFalse: 			[self 				refactoringError: 'The initialization code cannot be a return node or a list of statements'].	self checkVariableReferencesIn: tree! !!AddParameterRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| name newArg allTempVars |	allTempVars := parseTree allDefinedVariables.	name := self safeVariableNameFor: aClass temporaries: allTempVars.	newArg := RBVariableNode named: name.	parseTree arguments: parseTree arguments , (Array with: newArg).	super modifyImplementorParseTree: parseTree in: aClass! !!AddParameterRefactoring methodsFor: 'private'!newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			i == keywords size 				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: i printString].			stream nextPut: $ ].	^stream contents! !!AddParameterRefactoring methodsFor: 'private' stamp: 'jws 10/23/2016 05:38'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self newSelectorString.	rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.	^ rewriteRule! !!AddParameterRefactoring methodsFor: 'private'!safeVariableNameFor: aClass temporaries: allTempVars 	| baseString i newString |	newString := baseString := 'anObject'.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!AddParameterRefactoring methodsFor: 'private'!senders	senders isNil 		ifTrue: 			[senders := Set new.			self model allReferencesTo: oldSelector				do: [:each | senders add: each modelClass]].	^senders! !!AddParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addParameterToMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' newSelector: #';		nextPutAll: newSelector;		nextPutAll: ' initializer: ''';		nextPutAll: initializer;		nextPutAll: ''')'! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copy.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size > 1 		ifTrue: 			[self refactoringError: 'Cannot extract assignment without all references.'].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) isEmpty 		ifFalse: 			[self refactoringError: 'Cannot extract assignment if read before written.'].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkReturn	needsReturn := self placeholderNode isUsed.	extractedParseTree containsReturn ifFalse: [^self].	extractedParseTree lastIsReturn ifTrue: [^self].	(modifiedParseTree isLast: self placeholderNode) 		ifFalse: 			[self refactoringError: 'Couldn''t extract code since it contains a return.'].	self checkSelfReturns! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!checkSelfReturns	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '^self' do: [ :aNode :answer | answer ];		matches: '^`@anything' do: [ :aNode :answer | true ].	(searcher executeTree: extractedParseTree initialAnswer: false)		ifTrue: [ self placeholderNode asReturn ]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!checkSingleAssignment: varName	((RBReadBeforeWrittenTester isVariable: varName readBeforeWrittenIn: extractedParseTree)		or: [ extractedParseTree containsReturn ])		ifTrue: [ self refactoringError: 'Cannot extract assignments to temporaries without all references' ].	extractedParseTree addNode: (RBReturnNode value: (RBVariableNode named: varName)).	modifiedParseTree := ParseTreeRewriter		replace: self methodDelimiter		with: varName , ' := ' , self methodDelimiter		in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSpecialExtractions	| node |	node := self placeholderNode parent.	node isNil ifTrue: [^self].	(node isAssignment and: [node variable = self placeholderNode]) ifTrue: 			[self refactoringError: 'Cannot extract left hand side of an assignment'].	node isCascade ifTrue: 			[self refactoringError: 'Cannot extract first message of a cascaded message']! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkTemporaries	| temps accesses assigned |	temps := self remainingTemporaries.	accesses := temps select: [:each | extractedParseTree references: each].	assigned := accesses select: [:each | extractedParseTree assigns: each].	assigned isEmpty ifFalse: [self checkAssignments: assigned].	^parameters := (accesses asOrderedCollection)				removeAll: assigned;				yourself! !!ExtractMethodRefactoring methodsFor: 'transforming'!createTemporariesInExtractedMethodFor: assigned 	assigned do: [:each | extractedParseTree body addTemporaryNamed: each]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:58'!existingSelector	"Try to find an existing method instead of creating a new one"	^class allSelectors detect: [:each | self isMethodEquivalentTo: each]		ifNone: [nil]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!extractMethod	| parseTree isSequence extractCode subtree newCode |	extractCode := self getExtractedSource.	extractedParseTree := RBParser		parseExpression: extractCode		onError: [ :string :pos | self refactoringError: 'Invalid source to extract - ' , string ].	extractedParseTree isNil		ifTrue: [ self refactoringError: 'Invalid source to extract' ].	(extractedParseTree isSequence and: [ extractedParseTree statements isEmpty ])		ifTrue: [ self refactoringError: 'Select some code to extract' ].	isSequence := extractedParseTree isSequence or: [ extractedParseTree isReturn ].	extractedParseTree := RBMethodNode		selector: #value		arguments: #()		body:			(extractedParseTree isSequence				ifTrue: [ extractedParseTree ]				ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: extractedParseTree) ]).	extractedParseTree body temporaries isEmpty not		ifTrue: [ extractedParseTree body temporaries: #() ].	extractedParseTree source: extractCode.	parseTree := class parseTreeFor: selector.	parseTree isNil		ifTrue: [ self refactoringError: 'Could not parse ' , selector printString ].	subtree := isSequence		ifTrue: [ ParseTreeSearcher treeMatchingStatements: extractedParseTree body formattedCode in: parseTree ]		ifFalse: [ ParseTreeSearcher treeMatching: extractCode in: parseTree ].	subtree isNil		ifTrue: [ self refactoringError: 'Could not extract code from method' ].	newCode := self methodDelimiter.	isSequence		ifTrue: [ 			| stmts |			stmts := extractedParseTree body statements.			stmts isEmpty				ifFalse: [ 					stmts last isAssignment						ifTrue: [ 							| name |							name := stmts last variable name.							(self shouldExtractAssignmentTo: name)								ifFalse: [ 									newCode := '<1s> := <2s>' expandMacrosWith: name with: newCode.									stmts at: stmts size put: stmts last value ] ] ] ].	modifiedParseTree := isSequence		ifTrue: [ 			ParseTreeRewriter				replaceStatements: subtree formattedCode				with: newCode				in: parseTree				onInterval: extractionInterval ]		ifFalse: [ 			ParseTreeRewriter				replace: subtree formattedCode				with: newCode				in: parseTree				onInterval: extractionInterval ]! !!ExtractMethodRefactoring methodsFor: 'transforming'!getExtractedSource	| source |	source := class sourceCodeFor: selector.	((extractionInterval first between: 1 and: source size) 		and: [extractionInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: extractionInterval first to: extractionInterval last! !!ExtractMethodRefactoring methodsFor: 'transforming'!getNewMethodName	| newSelector methodName newMethodName |	methodName := RBMethodName new.	methodName arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil 		ifTrue: [self refactoringError: 'Did not extract code'].	newSelector := newMethodName selector.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	(class hierarchyDefinesMethod: newSelector asSymbol) 		ifTrue: 			[(self shouldOverride: newSelector in: class) ifFalse: [newSelector := nil]].	newSelector isNil] 			whileTrue: [].	parameters := newMethodName arguments asOrderedCollection.	^newSelector asSymbol! !!ExtractMethodRefactoring methodsFor: 'transforming'!isMethodEquivalentTo: aSelector 	selector == aSelector ifTrue: [^false].	aSelector numArgs ~~ parameters size ifTrue: [^false].	(self isParseTreeEquivalentTo: aSelector) ifFalse: [^false].	self reorderParametersToMatch: aSelector.	^true! !!ExtractMethodRefactoring methodsFor: 'transforming'!isParseTreeEquivalentTo: aSelector 	| tree definingClass |	definingClass := class whoDefinesMethod: aSelector.	tree := definingClass parseTreeFor: aSelector.	tree isNil ifTrue: [^false].	tree isPrimitive ifTrue: [^false].	(tree body equalTo: extractedParseTree body		exceptForVariables: (tree arguments collect: [:each | each name])) 			ifFalse: [^false].	(definingClass = class or: 			[(tree superMessages detect: 					[:each | 					(class superclass whichClassIncludesSelector: aSelector) 						~= (definingClass superclass whichClassIncludesSelector: each)]				ifNone: [nil]) isNil]) 		ifFalse: [^false].	^self shouldUseExistingMethod: aSelector! !!ExtractMethodRefactoring methodsFor: 'transforming'!methodDelimiter	^'#''place.holder.for.method'''! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!nameNewMethod: aSymbol	| args newSend |	args := parameters collect: [ :parm | RBVariableNode named: parm ].	extractedParseTree arguments: args asArray.	extractedParseTree selector: aSymbol.	aSymbol numArgs = 0		ifTrue: [ 			modifiedParseTree := ParseTreeRewriter				replace: self methodDelimiter				with: 'self ' , aSymbol asString				in: modifiedParseTree.			^ self ].	newSend := WriteStream on: ''.	aSymbol keywords		with: parameters		do: [ :key :arg | 			newSend				nextPutAll: key asString;				nextPut: $ ;				nextPutAll: arg asString;				nextPut: $  ].	modifiedParseTree := ParseTreeRewriter		replace: self methodDelimiter		with: 'self ' , newSend contents		in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!placeholderNode	| node |	node := ParseTreeSearcher treeMatching: self methodDelimiter in: modifiedParseTree.	node isNil		ifTrue: [ self refactoringError: 'Cannot extract code' ].	^ node! !!ExtractMethodRefactoring methodsFor: 'transforming'!remainingTemporaries	| temps |	temps := modifiedParseTree allDefinedVariables asSet.	extractedParseTree allDefinedVariables 		do: [:each | temps remove: each ifAbsent: []].	^temps! !!ExtractMethodRefactoring methodsFor: 'transforming'!reorderParametersToMatch: aSelector 	| tree dictionary |	tree := class parseTreeFor: aSelector.	dictionary := Dictionary new.	tree body equalTo: extractedParseTree body withMapping: dictionary.	parameters := tree arguments collect: 					[:each | 					dictionary at: each name						ifAbsent: 							[self 								refactoringError: 'An internal error occured, please report this error.']]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:56'!transform	| existingSelector |	existingSelector := self existingSelector.	self nameNewMethod: (existingSelector isNil 				ifTrue: [self getNewMethodName]				ifFalse: [existingSelector]).	existingSelector isNil 		ifTrue: 			[class compileTree: extractedParseTree				classified: (class protocolsFor: selector)].	class compileTree: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self extractMethod.					self checkSpecialExtractions.					self checkReturn.					needsReturn ifTrue: [extractedParseTree addReturn].					self checkTemporaries.					true])! !!ExtractMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodToComponentRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!extractMethod	| refactoring |	refactoring := ExtractMethodRefactoring 				model: self model				extract: extractionInterval				from: selector				in: class.	refactoring setOption: #methodName		toUse: 			[:ref :methodName | 			extractedMethodSelector := ref 						uniqueMethodNameFor: methodName arguments size.			methodName				selector: extractedMethodSelector;				yourself].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!inlineForwarder	| refactoring |	refactoring := InlineAllSendersRefactoring 				model: self model				sendersOf: extractedMethodSelector				in: class.	refactoring setOption: #inlineExpression toUse: [:ref :string | true].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!moveMethod	| variable refactoring |	variable := self selectVariableToMoveMethodTo: extractedMethodSelector				class: class.	variable isNil ifTrue: [self refactoringError: 'Did not extract method'].	refactoring := MoveMethodRefactoring 				model: self model				selector: extractedMethodSelector				class: class				variable: variable.	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!transform	self		extractMethod;		moveMethod;		inlineForwarder! !!ExtractMethodToComponentRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ExtractMethodToComponentRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!checkVariableName	(class whoDefinesInstanceVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines an instance variable named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(class whoDefinesClassVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines a class variabled named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(self parseTree allDefinedVariables includes: newVariableName) 		ifTrue: 			[self refactoringError: ('<1s> is already a temporary variable name' 						expandMacrosWith: newVariableName)]! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newVariableName for: class) 			& (RBCondition withBlock: 						[self verifySelectedInterval.						self checkVariableName.						true])! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	| selectedParseTree selectedSources |	selectedSources := self selectedSource.	selectedParseTree := RBParser parseExpression: selectedSources				onError: [:message :position | self refactoringError: 'Invalid selection'].	selectedParseTree isSequence 		ifTrue: [self refactoringError: 'Cannot assign temp to multiple statements']! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!compileNewMethod	class compileTree: self parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!constructAssignmentFrom: aNode 	| valueNode |	valueNode := RBVariableNode named: newVariableName.	^RBAssignmentNode variable: valueNode value: aNode! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!insertTemporary	| node statementNode |	node := self parseTree whichNodeIsContainedBy: sourceInterval.	(node notNil and: [node isValue]) 		ifFalse: [self refactoringError: 'Cannot assign to non-value nodes'].	statementNode := node statementNode.	node replaceWith: (RBVariableNode named: newVariableName).	(statementNode parent)		addNode: (self constructAssignmentFrom: node)			before: (node == statementNode 					ifTrue: [RBVariableNode named: newVariableName]					ifFalse: [statementNode]);		addTemporaryNamed: newVariableName! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!transform	self		insertTemporary;		compileNewMethod! !!ExtractToTemporaryRefactoring methodsFor: 'initialize-release'!extract: anInterval to: aString from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval.	newVariableName := aString! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!parseTree	parseTree isNil 		ifTrue: 			[parseTree := class parseTreeFor: selector.			parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']].	^parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!selectedSource	| source |	source := class sourceCodeFor: selector.	source isNil ifTrue: [self refactoringError: 'Couldn''t find sources'].	((sourceInterval first between: 1 and: source size) 		and: [sourceInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: sourceInterval first to: sourceInterval last! !!ExtractToTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newVariableName;		nextPutAll: ''' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineAllSendersRefactoring methodsFor: 'transforming'!checkInlinedMethods	numberReplaced = 0 		ifTrue: [self refactoringError: 'Could not inline any senders']! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineMessagesInClass: aClass andSelector: aSelector 	| messagesToInline previousCountOfMessages |	previousCountOfMessages := 4294967295.	"Some really large number > # of initial self sends."		[messagesToInline := self 				numberOfSelfSendsIn: (aClass parseTreeFor: aSelector).	messagesToInline > 0 and: [previousCountOfMessages > messagesToInline]] 			whileTrue: 				[| node |				previousCountOfMessages := messagesToInline.				node := self selfSendIn: (aClass parseTreeFor: aSelector).				self onError: 						[self performComponentRefactoring: (InlineMethodRefactoring 									model: self model									inline: node sourceInterval									inMethod: aSelector									forClass: aClass).						numberReplaced := numberReplaced + 1]					do: []].	numberNotReplaced := numberNotReplaced + messagesToInline! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineSelfSends	class withAllSubclasses do: 			[:each | 			| selectors |			selectors := each selectors.			selectors remove: selector ifAbsent: [].			selectors do: [:sel | self inlineMessagesInClass: each andSelector: sel]]! !!InlineAllSendersRefactoring methodsFor: 'transforming'!messagePattern	^'self ' , (self buildSelectorString: selector)! !!InlineAllSendersRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!numberOfSelfSendsIn: aParseTree	| search |	search := ParseTreeSearcher new.	search matches: self messagePattern do: [ :aNode :answer | answer + 1 ].	^ search executeTree: aParseTree initialAnswer: 0! !!InlineAllSendersRefactoring methodsFor: 'transforming'!removeMethod	self onError: 			[self performComponentRefactoring: (RemoveMethodRefactoring 						model: self model						removeMethods: (Array with: selector)						from: class)]		do: []! !!InlineAllSendersRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!selfSendIn: aTree	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: self messagePattern do: [ :aNode :answer | ^ aNode ].	^ searcher executeTree: aTree initialAnswer: nil! !!InlineAllSendersRefactoring methodsFor: 'transforming'!transform	self		inlineSelfSends;		removeMethod;		checkInlinedMethods! !!InlineAllSendersRefactoring methodsFor: 'accessing'!messagesNotReplaced	^numberNotReplaced! !!InlineAllSendersRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition canUnderstand: selector in: class! !!InlineAllSendersRefactoring methodsFor: 'initialize-release'!sendersOf: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	numberReplaced := numberNotReplaced := 0! !!InlineAllSendersRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' sendersOf: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineMethodRefactoring methodsFor: 'transforming'!addSelfReturn	inlineParseTree addSelfReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!addTemporary: sourceNode assignedTo: replacementNode 	| newName |	newName := self renameConflictingTemporary: sourceNode name.	(inlineParseTree body)		addTemporaryNamed: newName;		addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: newName)					value: replacementNode)! !!InlineMethodRefactoring methodsFor: 'transforming'!checkSuperMessages	self inlineClass = class ifTrue: [^self].	self inlineClass superclass isNil ifTrue: [^self].	inlineParseTree superMessages do: 			[:each | 			(self inlineClass superclass whoDefinesMethod: each) 				= (class superclass whoDefinesMethod: each) 					ifFalse: 						[self 							refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' 									expandMacrosWith: each)]]! !!InlineMethodRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceParseTree! !!InlineMethodRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	(sourceMessage receiver isVariable 		and: [#('self' 'super') includes: sourceMessage receiver name]) 			ifFalse: [self refactoringError: 'Cannot inline non-self messages']! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineClass	^inlineClass isNil 		ifTrue: 			[inlineClass := (sourceMessage receiver name = 'super' 						ifTrue: [class superclass]						ifFalse: [class]) whoDefinesMethod: self inlineSelector]		ifFalse: [inlineClass]! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSelector	sourceMessage isNil ifTrue: [self findSelectedMessage].	^sourceMessage selector! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSourceReplacing: aParseTree 	| statements nodeUnderSequence |	statements := inlineParseTree body statements.	(statements size > 1 and: [aParseTree isEvaluatedFirst not]) 		ifTrue: 			[self 				refactoringWarning: 'To inline this method, we need to move some of its statements before the original message send.<n>This could change the order of execution, which can change the behavior.<n>Do you want to proceed?' 						expandMacros].	nodeUnderSequence := aParseTree.	[nodeUnderSequence parent isSequence] 		whileFalse: [nodeUnderSequence := nodeUnderSequence parent].	(nodeUnderSequence parent)		addNodes: (statements copyFrom: 1 to: (statements size - 1 max: 0))			before: nodeUnderSequence;		addTemporariesNamed: inlineParseTree body temporaryNames.	aParseTree parent replaceNode: aParseTree		withNode: (statements isEmpty 				ifTrue: [RBVariableNode named: 'self']				ifFalse: [statements last])! !!InlineMethodRefactoring methodsFor: 'transforming'!insertInlinedMethod	| node |	node := sourceMessage.	self moveComments.	node parent isCascade 		ifTrue: 			[self rewriteCascadedMessage.			node := node parent].	node parent isReturn 		ifTrue: [node := node parent]		ifFalse: [self removeReturns].	self replaceArguments.	self inlineSourceReplacing: node.	sourceParseTree removeDeadCode.	self removeEmptyIfTrues.	self removeImmediateBlocks! !!InlineMethodRefactoring methodsFor: 'transforming'!moveComments	inlineParseTree nodesDo: 			[:each | 			each 				comments: (each comments collect: 							[:anInterval | 							| start stop source |							source := sourceParseTree source.							start := source size + 1.							source := source 										, (inlineParseTree source copyFrom: anInterval first to: anInterval last).							stop := source size.							sourceParseTree source: source.							start to: stop])]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!normalizeIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';		replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.	[ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!normalizeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.	[ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming'!parseInlineMethod	self inlineClass isNil 		ifTrue: 			[self 				refactoringError: ('<1p> or its superclasses don''t contain method <2s>' 						expandMacrosWith: class						with: self inlineSelector)].	inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.	inlineParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	inlineParseTree lastIsReturn ifFalse: [inlineParseTree addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!removeEmptyIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]'.	(rewriter executeTree: sourceParseTree)		ifTrue: [ sourceParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!removeImmediateBlocks	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: '[``.object] value' with: '``.object' when: [ :aNode | aNode parent isCascade not ].	rewriter		replace: '| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2'		with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.	(rewriter executeTree: sourceParseTree)		ifTrue: [ sourceParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!removeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: '^``@object' with: '``@object'.	(rewriter executeTree: inlineParseTree)		ifTrue: [ inlineParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporaries	inlineParseTree allDefinedVariables 		do: [:each | self renameConflictingTemporary: each]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printString].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!renameTemporary: oldName to: newName	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: oldName with: newName;		replaceArgument: oldName with: newName.	(rewriter executeTree: inlineParseTree)		ifTrue: [ inlineParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!replaceArgument: sourceNode with: replacementNode	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: sourceNode withTree: replacementNode.	(rewriter executeTree: inlineParseTree body)		ifTrue: [ inlineParseTree body: rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'transforming'!replaceArguments	sourceMessage arguments reverse with: inlineParseTree arguments reverse		do: 			[:replacement :source | 			(replacement isImmediate 				or: [self shouldInlineExpression: replacement formattedCode]) 					ifTrue: [self replaceArgument: source with: replacement]					ifFalse: [self addTemporary: source assignedTo: replacement]]! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteCascadedMessage	| index messages |	messages := sourceMessage parent messages.	index := (1 to: messages size) 				detect: [:i | sourceMessage == (messages at: i)]				ifNone: [0].	inlineParseTree body addNodesFirst: (messages copyFrom: 1 to: index - 1).	self removeReturns.	inlineParseTree body 		addNodes: (messages copyFrom: index + 1 to: messages size).	inlineParseTree addReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteInlinedTree	sourceMessage parent isReturn 		ifTrue: 			[(sourceParseTree isLast: sourceMessage parent) 				ifFalse: [self addSelfReturn]]		ifFalse: 			[self				writeGuardClauses;				normalizeIfTrues;				normalizeReturns;				addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'transforming'!transform	self		renameConflictingTemporaries;		insertInlinedMethod;		compileMethod! !!InlineMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!writeGuardClauses	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.	[ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]! !!InlineMethodRefactoring methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!hasMultipleReturns	"Do we have multiple returns? If the last statement isn't a return, then we have an implicit return of self."	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '^``@object'		do: [ :aNode :hasAReturn | 			hasAReturn				ifTrue: [ ^ true ].			true ].	searcher executeTree: inlineParseTree initialAnswer: inlineParseTree lastIsReturn not.	^ false! !!InlineMethodRefactoring methodsFor: 'testing'!isOverridden	^(class allSubclasses detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineMethodRefactoring methodsFor: 'testing'!isPrimitive	^inlineParseTree isPrimitive! !!InlineMethodRefactoring methodsFor: 'initialize-release'!inline: anInterval inMethod: aSelector forClass: aClass 	sourceSelector := aSelector.	class := self classObjectFor: aClass.	sourceInterval := anInterval! !!InlineMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: sourceSelector in: class) 		& (RBCondition withBlock: 					[self findSelectedMessage.					self isOverridden 						ifTrue: 							[self 								refactoringWarning: ('<1p>>><2s> is overriden. Do you want to inline it anyway?' 										expandMacrosWith: self inlineClass										with: self inlineSelector)].					self parseInlineMethod.					self isPrimitive 						ifTrue: [self refactoringError: 'Cannot inline primitives'].					self checkSuperMessages.					self rewriteInlinedTree.					(sourceMessage parent isReturn or: [self hasMultipleReturns not]) 						ifFalse: 							[self 								refactoringError: 'Cannot inline method since it contains multiple returns that cannot be rewritten'].					true])! !!InlineMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' inMethod: #';		nextPutAll: sourceSelector;		nextPutAll: ' forClass: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!abstractVariableReferences	| refactoring |	refactoring := AbstractVariablesRefactoring 				model: self model				abstractVariablesIn: inlineParseTree				from: inlineClass				toAll: (Array with: class).	self performComponentRefactoring: refactoring.	inlineParseTree := refactoring parseTree! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addArgumentToSelector: aSymbol 	^aSymbol isInfix 		ifTrue: [#value:value:]		ifFalse: [(aSymbol , 'value:') asSymbol]! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!addSelfReferenceToInlineParseTree	| variableName rewriter newArguments |	variableName := self newNameForSelf.	rewriter := ParseTreeRewriter rename: 'self' to: variableName.	(rewriter executeTree: inlineParseTree)		ifTrue: [ inlineParseTree := rewriter tree ].	newArguments := inlineParseTree arguments asOrderedCollection.	newArguments addFirst: (RBVariableNode named: variableName).	inlineParseTree		arguments: newArguments;		selector: (self addArgumentToSelector: inlineParseTree selector).	sourceMessage receiver replaceWith: (RBVariableNode named: variableName)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addSelfReferenceToSourceMessage	| newArguments |	newArguments := sourceMessage arguments asOrderedCollection.	newArguments addFirst: sourceMessage receiver copy.	sourceMessage		arguments: newArguments;		selector: (self addArgumentToSelector: sourceMessage selector)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!checkSuperMessages	inlineParseTree superMessages isEmpty 		ifFalse: 			[self 				refactoringError: 'Cannot inline method since it sends a super message']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!inlineClass	| imps |	inlineClass notNil ifTrue: [^inlineClass].	imps := (self model allImplementorsOf: self inlineSelector) 				asOrderedCollection.	imps size = 1 ifTrue: [^inlineClass := imps first].	imps isEmpty 		ifTrue: 			[self 				refactoringError: 'Nobody defines a method named ' , self inlineSelector].	inlineClass := self requestImplementorToInline: imps.	inlineClass isNil 		ifTrue: [self refactoringError: 'No implementor selected'].	^inlineClass! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := (nonMetaClass name first isVowel 						ifTrue: ['an']						ifFalse: ['a']) , nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printString.				index := index + 1].	^variableName! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!renameSelfReferences	self addSelfReferenceToSourceMessage.	self addSelfReferenceToInlineParseTree.! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!transform	self abstractVariableReferences.	self renameSelfReferences.	super transform! !!InlineMethodFromComponentRefactoring methodsFor: 'testing'!isOverridden	^(self inlineClass allSubclasses 		detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineTemporaryRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceTree! !!InlineTemporaryRefactoring methodsFor: 'transforming'!replaceAssignment	assignmentNode parent isSequence 		ifTrue: [assignmentNode parent removeNode: assignmentNode]		ifFalse: [assignmentNode replaceWith: assignmentNode value]! !!InlineTemporaryRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!replaceReferences	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: assignmentNode variable withTree: assignmentNode value.	definingNode removeTemporaryNamed: assignmentNode variable name.	rewriter executeTree: definingNode! !!InlineTemporaryRefactoring methodsFor: 'transforming'!transform	self		replaceAssignment;		replaceReferences;		compileMethod! !!InlineTemporaryRefactoring methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!hasOnlyOneAssignment	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: assignmentNode variable name , ' := ``@object' do: [ :aNode :answer | answer + 1 ].	^ (searcher executeTree: definingNode initialAnswer: 0) == 1! !!InlineTemporaryRefactoring methodsFor: 'initialize-release'!inline: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self verifySelectedInterval.					true])! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	sourceTree := class parseTreeFor: selector.	sourceTree isNil ifTrue: [self refactoringError: 'Could not parse source'].	assignmentNode := sourceTree whichNodeIsContainedBy: sourceInterval.	assignmentNode isAssignment 		ifFalse: 			[self refactoringError: 'The selected node is not an assignment statement'].	definingNode := assignmentNode whoDefines: assignmentNode variable name.	self hasOnlyOneAssignment 		ifFalse: 			[self refactoringError: 'There are multiple assignments to the variable'].	(RBReadBeforeWrittenTester isVariable: assignmentNode variable name		writtenBeforeReadIn: definingNode) 			ifFalse: 				[self 					refactoringError: 'The variable is possible read before it is assigned']! !!InlineTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariables	self performComponentRefactoring: self abstractVariablesRefactoring.	parseTree := self abstractVariablesRefactoring parseTree! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariablesRefactoring	^AbstractVariablesRefactoring 		model: self model		abstractVariablesIn: parseTree		from: class		toAll: moveToClasses		ignoring: variable! !!MoveMethodRefactoring methodsFor: 'transforming'!addSelfReturn	self hasOnlySelfReturns ifTrue: [^self].	parseTree addSelfReturn! !!MoveMethodRefactoring methodsFor: 'transforming'!compileDelagatorMethod	| statementNode delegatorNode tree |	delegatorNode := RBMessageNode 				receiver: (RBVariableNode named: variable)				selectorParts: parseTree selectorParts				arguments: (parseTree argumentNames collect: 							[:each | 							RBVariableNode 								named: (each = selfVariableName ifTrue: ['self'] ifFalse: [each])]).	self hasOnlySelfReturns 		ifFalse: [delegatorNode := RBReturnNode value: delegatorNode].	statementNode := RBSequenceNode temporaries: #()				statements: (Array with: delegatorNode).	(tree := class parseTreeFor: selector) body: statementNode.	class compileTree: tree! !!MoveMethodRefactoring methodsFor: 'transforming'!compileNewMethods	moveToClasses 		do: [:each | each compileTree: parseTree classified: (class protocolsFor: selector)]! !!MoveMethodRefactoring methodsFor: 'transforming'!getArgumentNameForSelf	self needsToReplaceSelfReferences ifFalse: [^self].		[selfVariableName := self requestSelfArgumentName.	(self checkInstanceVariableName: selfVariableName in: class) 		ifTrue: 			[self verifyTemporaryVariableDoesNotOverride 				ifFalse: 					[self 						refactoringWarning: 'The variable is already defined in one of the classes you''re moving the method to.<n>Try another?' 								expandMacros.					selfVariableName := nil]]		ifFalse: 			[self 				refactoringWarning: 'The variable name is not a valid Smalltalk temporary variable name<n>Try again?' 						expandMacros.			selfVariableName := nil].	selfVariableName isNil] 			whileTrue: []! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!hasOnlySelfReturns	^ hasOnlySelfReturns isNil		ifTrue: [ 			| searcher |			searcher := ParseTreeSearcher new.			searcher				matches: '^self' do: [ :aNode :answer | answer ];				matches: '^`@object' do: [ :aNode :answer | false ].			hasOnlySelfReturns := searcher executeTree: parseTree initialAnswer: true ]		ifFalse: [ hasOnlySelfReturns ]! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'rr 3/16/2004 15:15'!removeArgument	"Removes the excess argument if any.	This argument is the variable which is	referenced by self in the classes the	method is moved to. "	| removeIndex |	removeIndex := parseTree argumentNames indexOf: variable.	removeIndex = 0 ifFalse: 		[parseTree arguments: ((parseTree arguments asOrderedCollection)  									removeAt: removeIndex; yourself) asArray.		parseTree selectorParts: ((parseTree selectorParts asOrderedCollection) 									removeAt: removeIndex; yourself) asArray].! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!replaceSelfReferences	| replacer |	self needsToReplaceSelfReferences		ifTrue: [ 			replacer := ParseTreeRewriter new.			replacer replace: 'self' with: selfVariableName.			self hasOnlySelfReturns				ifTrue: [ replacer replace: '^self' with: '^self' ].			replacer executeTree: parseTree.			parseTree := replacer tree ]! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!replaceVariableReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: variable with: 'self'.	replacer executeTree: parseTree.	parseTree := replacer tree! !!MoveMethodRefactoring methodsFor: 'transforming'!transform	self		abstractVariables;		addSelfReturn;		replaceSelfReferences;		replaceVariableReferences;		compileNewMethods;		compileDelagatorMethod! !!MoveMethodRefactoring methodsFor: 'transforming'!verifyTemporaryVariableDoesNotOverride	(parseTree allDefinedVariables includes: selfVariableName) 		ifTrue: [^false].	moveToClasses 		do: [:each | (each definesVariable: selfVariableName) ifTrue: [^false]].	^true! !!MoveMethodRefactoring methodsFor: 'private'!buildParseTree	parseTree := (class parseTreeFor: selector) copy.	parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']! !!MoveMethodRefactoring methodsFor: 'preconditions' stamp: 'jws 10/23/2016 05:39'!checkAssignmentsToVariable	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: variable , ' := `@object' do: [ :aNode :answer | true ].	(searcher executeTree: parseTree initialAnswer: false)		ifTrue: [ self refactoringError: ('Cannot move the method into <1s> since it is assigned' expandMacrosWith: variable) ]! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkForPrimitiveMethod	parseTree isPrimitive 		ifTrue: [self refactoringError: 'Cannot move primitive methods']! !!MoveMethodRefactoring methodsFor: 'preconditions' stamp: 'jws 10/23/2016 05:39'!checkForSuperReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@message: `@args' do: [ :aNode :answer | true ].	(searcher executeTree: parseTree initialAnswer: false)		ifTrue: [ self refactoringError: 'Cannot move the method since it has a super message send.' ]! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkTemporaryVariableNames	| varNames |	varNames := parseTree allDefinedVariables.	selfVariableName notNil ifTrue: [varNames add: selfVariableName].	varNames do: 			[:name | 			moveToClasses do: 					[:each | 					(self canReferenceVariable: name in: each) 						ifTrue: 							[self refactoringError: ('<1p> already defines a variable called <2s>' 										expandMacrosWith: each										with: name)]]]! !!MoveMethodRefactoring methodsFor: 'preconditions' stamp: 'rr 3/16/2004 15:14'!getNewMethodName	"rr 3/16/2004 15:12 : changed the code	to really remove the variable which	the extracted selector is moved to,	as in the new location it is now the	self pseudo-argument.		The previous version was only removing	it from the arguments, which was causing	a bug."	| newSelector parameters alreadyDefined methodName newMethodName |	self removeArgument.	parameters := parseTree argumentNames asOrderedCollection.	"parameters remove: variable ifAbsent: []."	self needsToReplaceSelfReferences 		ifTrue: [parameters add: selfVariableName].	methodName := RBMethodName selector: (self uniqueMethodNameFor: parameters size) arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil ifTrue: [self refactoringError: 'Did not move method'].	newMethodName isValid 		ifTrue: [newSelector := newMethodName selector]		ifFalse: [self refactoringWarning: 'Invalid method name'].	parameters := newMethodName arguments.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	alreadyDefined := moveToClasses 				detect: [:each | each hierarchyDefinesMethod: newSelector]				ifNone: [nil].	alreadyDefined notNil 		ifTrue: 			[self 				refactoringWarning: ('<1s> is already defined by <2p> or a super/subclass<n>Try another?' 						expandMacrosWith: newSelector						with: alreadyDefined).			newSelector := nil].	newSelector isNil] 			whileTrue: [].	parseTree		arguments: (parameters collect: [:each | RBVariableNode named: each]) 					asArray;		selector: newSelector! !!MoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self buildParseTree.					self checkForPrimitiveMethod.					self checkForSuperReferences.					self checkAssignmentsToVariable.					self getClassesToMoveTo.					self getArgumentNameForSelf.					self checkTemporaryVariableNames.					self getNewMethodName.					true])! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassForGlobalOrClassVariable	| definingClass type |	definingClass := class whoDefinesClassVariable: variable.	definingClass isNil 		ifTrue: 			[type := self model classNamed: variable.			type isNil ifTrue: [type := self model classNamed: #Object]]		ifFalse: [type := definingClass typeOfClassVariable: variable].	moveToClasses := self selectVariableTypesFrom: (Array with: type)				selected: (Array with: type).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForInstanceVariable	| definingClass typer types |	definingClass := class whoDefinesInstanceVariable: variable.	typer := RefactoryTyper newFor: self model.	typer runOn: definingClass.	types := typer typesFor: variable.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types				selected: (typer guessTypesFor: variable).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForTemporaryVariable	| types |	types := RefactoryTyper 				typesFor: variable				in: parseTree				model: self model.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types selected: types.	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesToMoveTo	self isMovingToArgument 		ifTrue: [self getClassesForTemporaryVariable]		ifFalse: 			[self isMovingToInstVar 				ifTrue: [self getClassesForInstanceVariable]				ifFalse: [self getClassForGlobalOrClassVariable]].	moveToClasses isEmpty 		ifTrue: [self refactoringError: 'No classes selected, method not moved.']! !!MoveMethodRefactoring methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!hasSelfReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self' do: [ :aNode :answer | true ].	self hasOnlySelfReturns		ifTrue: [ searcher matches: '^self' do: [ :aNode :answer | answer ] ].	^ searcher executeTree: parseTree initialAnswer: false! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToArgument	^(parseTree arguments collect: [:each | each name]) includes: variable! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToInstVar	^self isMovingToArgument not 		and: [(class whoDefinesInstanceVariable: variable) notNil]! !!MoveMethodRefactoring methodsFor: 'testing'!needsToReplaceSelfReferences	^self hasSelfReferences 		or: [self abstractVariablesRefactoring hasVariablesToAbstract]! !!MoveMethodRefactoring methodsFor: 'initialize-release'!selector: aSymbol class: aClass variable: aVariableName 	selector := aSymbol.	class := self classObjectFor: aClass.	variable := aVariableName! !!MoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' variable: ''';		nextPutAll: variable;		nextPutAll: ''')'! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkNodes: sequenceNodes 	(sequenceNodes 		detect: [:each | RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: each]		ifNone: [nil]) notNil 		ifTrue: [^false].	sequenceNodes do: 			[:each | 			(self usesDirectly: each body) 				ifTrue: [blockNodes add: each]				ifFalse: 					[(self checkNodes: (self subblocksIn: each body)) 						ifFalse: [blockNodes add: each]]].	^true! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkParseTree	| node |	blockNodes := OrderedCollection new.	node := self whichVariableNode: parseTree				inInterval: interval				name: name.	node isNil		ifTrue: [self refactoringError: 'Unable to locate node in parse tree'].	definingNode := node whoDefines: name.	definingNode isNil		ifTrue: [self refactoringError: 'Cannot locate variable definition'].	definingNode isSequence		ifFalse: [self refactoringError: 'Variable is an argument'].	(self usesDirectly: definingNode)		ifTrue: [self refactoringError: 'Variable already bound tightly as possible'].	(self checkNodes: (self subblocksIn: definingNode))		ifFalse: [self refactoringError: 'Variable is possibly read before written']! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!subblocksIn: aParseTree	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '[:`@blockTemps | | `@temps | `@.Statements]'		do: [ :aNode :answer | 			(aNode references: name)				ifTrue: [ answer add: aNode ].			answer ].	^ searcher executeTree: aParseTree initialAnswer: OrderedCollection new! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!transform	definingNode removeTemporaryNamed: name.	blockNodes do: [:each | each body addTemporaryNamed: name].	class compileTree: parseTree! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:39'!usesDirectly: aParseTree	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '[:`@args | | `@temps | `@.Statements]' do: [ :aNode :answer | answer ];		matches: name do: [ :aNode :answer | true ].	^ searcher executeTree: aParseTree initialAnswer: false! !!MoveVariableDefinitionRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval 	interval := anInterval.	class := self classObjectFor: aClass.	selector := aSelector! !!MoveVariableDefinitionRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[| methodSource |					interval first <= interval last 						ifFalse: [self refactoringError: 'Invalid variable name'].					methodSource := class sourceCodeFor: selector.					methodSource size >= interval last 						ifFalse: [self refactoringError: 'Invalid range for variable'].					name := methodSource copyFrom: interval first to: interval last.					(self checkInstanceVariableName: name in: class) 						ifFalse: 							[self 								refactoringError: name , ' does not seem to be a valid variable name.'].					parseTree := class parseTreeFor: selector.					self checkParseTree.					true])! !!MoveVariableDefinitionRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' bindTight: '.	interval storeOn: aStream.	aStream nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!PushDownMethodRefactoring methodsFor: 'preconditions'!preconditions	| condition |	condition := selectors inject: RBCondition empty				into: 					[:cond :each | 					cond & (RBCondition definesSelector: each in: class) 						& (RBCondition subclassesOf: class referToSelector: each) not].	^condition & (RBCondition isAbstractClass: class)! !!PushDownMethodRefactoring methodsFor: 'transforming'!pushDown: aSelector 	| code protocols refactoring |	code := class sourceCodeFor: aSelector.	protocols := class protocolsFor: aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code classified: protocols]]! !!PushDownMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | self pushDown: each].	selectors do: [:each | class removeMethod: each]! !!PushDownMethodRefactoring methodsFor: 'initialize-release'!pushDown: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!PushDownMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushDown: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkBackReferencesTo: aSelector 	| definingClass pushUpParseTree |	definingClass := class superclass whoDefinesMethod: aSelector.	definingClass isNil ifTrue: [^self].	pushUpParseTree := class parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					parseTree := each parseTreeFor: sel.					(parseTree notNil and: 							[(parseTree superMessages includes: aSelector) 								and: [definingClass == (each whoDefinesMethod: aSelector)]]) 						ifTrue: 							[removeDuplicates := true.							(aSelector == sel 								and: [parseTree equalTo: pushUpParseTree exceptForVariables: #()]) 									ifFalse: 										[self 											refactoringError: ('Cannot push up <1s> since it would override the method defined in <2p>' 													expandMacrosWith: aSelector													with: definingClass)]]]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVars	selectors do: [:each | self checkClassVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVarsFor: aSelector 	class nonMetaclass classVariableNames do: 			[:each | 			((class whichSelectorsReferToClassVariable: each) includes: aSelector) 				ifTrue: 					[self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' 								expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVars	selectors do: [:each | self checkInstVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVarsFor: aSelector 	class instanceVariableNames do: 			[:each | 			((class whichSelectorsReferToInstanceVariable: each) includes: aSelector) ifTrue: 					[self						refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSiblingSuperSendsFrom: aRBClass 	aRBClass selectors do: 			[:each | 			| tree |			tree := aRBClass parseTreeFor: each.			tree notNil 				ifTrue: 					[tree superMessages do: 							[:aSelector | 							(selectors includes: aSelector) 								ifTrue: 									[| definer |									definer := aRBClass superclass whoDefinesMethod: aSelector.									(definer notNil and: [class includesClass: definer]) 										ifTrue: 											[self 												refactoringError: ('Cannot push up <1s> since <2p>>><3s> sends a super message to it.' 														expandMacrosWith: aSelector														with: aRBClass														with: each)]]]]].	aRBClass allSubclasses do: [:each | self checkSiblingSuperSendsFrom: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperMessages	self checkSuperSendsFromPushedUpMethods.	self checkSuperSendsFromSiblings! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromPushedUpMethods	selectors do: 			[:each | 			| parseTree |			parseTree := class parseTreeFor: each.			(parseTree superMessages 				detect: [:sup | class superclass directlyDefinesMethod: sup]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringError: ('Cannot push up <1s> since it sends a super message that is defined in the superclass.' 								expandMacrosWith: each)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromSiblings	| siblings |	siblings := class superclass subclasses reject: [:each | each = class].	siblings do: [:aRBClass | self checkSiblingSuperSendsFrom: aRBClass]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperclass	| overrideSelectors |	overrideSelectors := selectors 				select: [:each | class superclass definesMethod: each].	overrideSelectors := overrideSelectors reject: 					[:each | 					| myTree superTree |					myTree := class parseTreeFor: each.					superTree := class superclass parseTreeFor: each.					superTree equalTo: myTree exceptForVariables: #()].	overrideSelectors isEmpty ifTrue: [^self].	class superclass isAbstract 		ifFalse: 			[self refactoringError: ('Non-abstract class <2p> already defines <1p>' 						expandMacrosWith: overrideSelectors asArray first						with: class superclass)].	overrideSelectors do: [:each | self checkBackReferencesTo: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: (RBCondition hasSuperclass: class)		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkInstVars.						self checkClassVars.						self checkSuperclass.						self checkSuperMessages.						true])! !!PushUpMethodRefactoring methodsFor: 'private'!copyDownMethod: aSelector 	| oldProtocol oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ('Source code for <1s> superclass method not available' 						expandMacrosWith: aSelector)].	oldProtocol := superclassDefiner protocolsFor: aSelector.	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		detect: [:each | superclassDefiner directlyDefinesMethod: each]		ifNone: [nil]) notNil 		ifTrue: 			[self 				refactoringError: ('Cannot push up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' 						expandMacrosWith: aSelector						with: superclassDefiner)].	self 		refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' 				, aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: [:each | each compile: oldSource classified: oldProtocol]! !!PushUpMethodRefactoring methodsFor: 'transforming'!copyDownMethods	selectors do: [:each | self copyDownMethod: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUp: aSelector 	| source refactoring |	source := class sourceCodeFor: aSelector.	source isNil 		ifTrue: [self refactoringError: 'Source for method not available'].	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	class superclass compile: source		classified: (class protocolsFor: aSelector)! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUpMethods	selectors do: [:each | self pushUp: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicateMethods	selectors do: [:each | self removeDuplicatesOf: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicatesOf: aSelector 	| tree |	tree := class superclass parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			((each directlyDefinesMethod: aSelector) and: 					[(tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #()) 						and: [(each superclass whoDefinesMethod: aSelector) == class superclass]]) 				ifTrue: 					[removeDuplicates 						ifFalse: 							[removeDuplicates := true.							self 								refactoringWarning: 'Do you want to remove duplicate subclass methods?'].					each removeMethod: aSelector]]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removePushedUpMethods	selectors do: [:each | class removeMethod: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!transform	self		copyDownMethods;		pushUpMethods;		removePushedUpMethods;		removeDuplicateMethods! !!PushUpMethodRefactoring methodsFor: 'initialize-release'!pushUp: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection.	removeDuplicates := false! !!PushUpMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushUp: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!Refactoring class methodsFor: '-- all --' stamp: 'nk 2/23/2005 14:34'!initializeRefactoringOptions	"self initializeRefactoringOptions"	RefactoringOptions := IdentityDictionary new.	RefactoringOptions		at: #implementorToInline		put: [:ref :imps | ChooserMorph				choose: 'Which implementation should be inlined?'				multipleSelect: false				fromList: imps				values: imps				cancel: []];				at: #methodName		put: [:ref :methodName | MethodNameEditor modalEditorForMethodName: methodName];				at: #selfArgumentName		put: [:ref | ref request: 'Enter name for argument to refer to "self" in extracted method'];				at: #selectVariableToMoveTo		put: [:ref :class :selector | 			| parseTree nameList ignoreList | 			parseTree := class parseTreeFor: selector.			parseTree isNil				ifTrue: [parseTree := RBMethodNode								selector: #value								body: (RBSequenceNode statements: #())].			nameList := OrderedCollection new.			nameList add: '---- Arguments ----';				 addAll: parseTree argumentNames asSortedCollection;				 add: '---- Instance Variables ----'.			ignoreList := OrderedCollection with: 1 with: nameList size.			nameList addAll: class allInstanceVariableNames asSortedCollection.			nameList at: (PopUpMenu labelArray: nameList lines: #()) startUp];				at: #variableTypes		put: [:ref :types :selected | ChooserMorph				choose: 'Choose types'				multipleSelect: true				fromList: types				values: types				cancel: []				initialSelections: selected];				at: #extractAssignment		put: [:ref :varName | ref				confirm: ('Do you want to extract the assignment of <1s><n>at the end of selection?' expandMacrosWith: varName)];				at: #inlineExpression		put: [:ref :string | ref				confirm: ('Do you want to inline "<1s>"? If not, it will be assigned as a temporary.' expandMacrosWith: string)];				at: #alreadyDefined		put: [:ref :cls :selector | ref				confirm: ('<1s> is already defined in the <2p> hierarchy.<n>Extracting it to an existing selector may change behavior.<n>Do you wish to use <1s> anyway?' expandMacrosWith: selector with: cls)];				at: #useExistingMethod		put: [:ref :selector | ref confirm: 'Use existing method ' , selector , ' instead of creating new method?'];				at: #openBrowser		put: [:ref :env | env openEditor]! !!Refactoring class methodsFor: 'accessing signal'!preconditionSignal	^RefactoringError , RefactoringWarning! !!Refactoring class methodsFor: 'accessing'!refactoringOptions	RefactoringOptions isNil ifTrue: [self initializeRefactoringOptions].	^RefactoringOptions! !!Refactoring class methodsFor: 'accessing'!setDefaultOption: aSymbol to: aBlock 	self refactoringOptions at: aSymbol put: aBlock! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection 	^self 		model: aRBSmalltalk		abstractVariablesIn: aBRProgramNode		from: fromBehavior		toAll: behaviorCollection		ignoring: nil! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	^(self new)		model: aRBSmalltalk;		abstractVariablesIn: aBRProgramNode			from: fromBehavior			toAll: behaviorCollection			ignoring: aVariableName;		yourself! !!AddMethodRefactoring class methodsFor: 'instance creation'!addMethod: aString toClass: aClass inProtocols: protocolList 	^self new addMethod: aString		toClass: aClass		inProtocols: protocolList! !!AddMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addMethod: aString toClass: aClass inProtocols: protocolList 	^(self new)		model: aRBSmalltalk;		addMethod: aString			toClass: aClass			inProtocols: protocolList;		yourself! !!AddParameterRefactoring class methodsFor: 'instance creation'!addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^self new addParameterToMethod: aSelector		in: aClass		newSelector: newSelector		initializer: init! !!AddParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^(self new)		model: aRBSmalltalk;		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init;		yourself! !!ClassRefactoring class methodsFor: 'instance creation'!className: aName	^self new className: aName! !!ClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk className: aName 	^(self new)		model: aRBSmalltalk;		className: aName;		yourself! !!AddClassRefactoring class methodsFor: 'instance creation'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol	^self new		addClass: aName		superclass: aClass		subclasses: aCollection		category: aSymbol! !!AddClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	^(self new)		model: aRBSmalltalk;		addClass: aName			superclass: aClass			subclasses: aCollection			category: aSymbol;		yourself! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		model: aRBSmalltalk;		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!model: aRBNamespace forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		model: aRBNamespace;		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!extract: anInterval to: aString from: aSelector in: aClass 	^self new 		extract: anInterval		to: aString		from: aSelector		in: aClass! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval to: aString from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			to: aString			from: aSelector			in: aClass;		yourself! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk sendersOf: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		sendersOf: aSelector in: aClass;		yourself! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!sendersOf: aSelector in: aClass 	^self new sendersOf: aSelector in: aClass! !!InlineMethodRefactoring class methodsFor: 'instance creation'!inline: anInterval inMethod: aSelector forClass: aClass 	^self new 		inline: anInterval		inMethod: aSelector		forClass: aClass! !!InlineMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval inMethod: aSelector forClass: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			inMethod: aSelector			forClass: aClass;		yourself! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!inline: anInterval from: aSelector in: aClass 	^self new 		inline: anInterval		from: aSelector		in: aClass! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			from: aSelector			in: aClass;		yourself! !!MoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk selector: aSymbol class: aClass variable: aVariableName 	^(self new)		model: aRBSmalltalk;		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveMethodRefactoring class methodsFor: 'instance creation'!selector: aSymbol class: aClass variable: aVariableName 	^(self new)		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!bindTight: anInterval in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk bindTight: anInterval in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval;		yourself! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushDown: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushDown: selectorCollection from: aClass;		yourself! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!pushDown: selectorCollection from: aClass 	^self new pushDown: selectorCollection from: aClass! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushUp: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushUp: selectorCollection from: aClass;		yourself! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!pushUp: selectorCollection from: aClass 	^self new pushUp: selectorCollection from: aClass! !!RefactoringBrowserTest methodsFor: 'private'!convertInterval: anInterval for: aString 	"Convert the interval to ignore differences in end of line conventions."	^anInterval! !!RefactoringBrowserTest methodsFor: 'private'!executeRefactoring: aRefactoring 	aRefactoring primitiveExecute.	RBParser parseExpression: aRefactoring storeString! !!RefactoringBrowserTest methodsFor: 'private'!objectClassVariable	^Object classPool keys detect: [:each | true]! !!RefactoringBrowserTest methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!proceedThroughWarning: aBlock 	aBlock on: RefactoringWarning do: [:ex | ex resume]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!categoriesFor: anEnvironment 	| allCategories |	allCategories := Set withAll: BrowserEnvironment new categories.	allCategories removeAll: anEnvironment categories.	anEnvironment not categories 		do: [:each | allCategories remove: each ifAbsent: []].	allCategories 		do: [:each | self assert: (BrowserEnvironment new classNamesFor: each) isEmpty]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!copyFor: aBrowserEnvironment 	| newEnvironment |	newEnvironment := aBrowserEnvironment copy.	self assert: newEnvironment numberSelectors 				= aBrowserEnvironment numberSelectors.	self 		assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0! !!BrowserEnvironmentTest methodsFor: 'universal tests'!keysFor: aBrowserEnvironment 	| allKeys |	allKeys := Set withAll: aBrowserEnvironment keys.	allKeys addAll: aBrowserEnvironment not keys.	allKeys removeAll: Smalltalk keys.	self assert: allKeys isEmpty! !!BrowserEnvironmentTest methodsFor: 'universal tests'!numberSelectorsFor: aBrowserEnvironment 	self 		assert: aBrowserEnvironment numberSelectors 				+ aBrowserEnvironment not numberSelectors 					= BrowserEnvironment new numberSelectors.	self 		assert: (aBrowserEnvironment & aBrowserEnvironment not) numberSelectors = 0.	self assert: (universalEnvironment & aBrowserEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors.	self assert: (aBrowserEnvironment & universalEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'universal tests'!storeStringFor: aBrowserEnvironment	| newEnvironment |	newEnvironment := Compiler evaluate: aBrowserEnvironment storeString.	self assert: newEnvironment numberSelectors = aBrowserEnvironment numberSelectors.	self assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0	! !!BrowserEnvironmentTest methodsFor: 'universal tests'!uniqueClassesIn: aBrowserEnvironment 	| allClasses |	allClasses := Set new.	aBrowserEnvironment 		classesDo: [:each | self deny: (allClasses includes: each)]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!universalTestFor: aBrowserEnvironment 	self uniqueClassesIn: aBrowserEnvironment.	self numberSelectorsFor: aBrowserEnvironment.	self storeStringFor: aBrowserEnvironment.	self classNamesFor: aBrowserEnvironment.	self copyFor: aBrowserEnvironment.	self categoriesFor: aBrowserEnvironment.	self classesFor: aBrowserEnvironment.	self keysFor: aBrowserEnvironment.	self 		assert: aBrowserEnvironment problemCount = 0 = aBrowserEnvironment isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classNamesFor: anEnvironment 	| classNames |	classNames := (anEnvironment classNames asSet)				addAll: anEnvironment not classNames;				yourself.	self assert: classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection.	self assert: (anEnvironment & anEnvironment not) classNames isEmpty.	self 		assert: (anEnvironment | anEnvironment not) classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classesFor: aBrowserEnvironment 	| allClasses |	allClasses := aBrowserEnvironment classes asSet.	allClasses addAll: aBrowserEnvironment not classes.	BrowserEnvironment new classesDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests' stamp: 'dvf 8/27/2003 15:02'!testAllClassesDo	| allClasses aBrowserEnvironment |	aBrowserEnvironment := BrowserEnvironment new.	allClasses := Set new.	aBrowserEnvironment classesDo: [:each | allClasses add: each].	SystemNavigation new allBehaviorsDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testBrowserEnvironment	self universalTestFor: BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testCategoryEnvironment	| aCategoryEnvironment |	aCategoryEnvironment := CategoryEnvironment 				onEnvironment: BrowserEnvironment new				categories: #(#'Kernel-Objects').	self universalTestFor: aCategoryEnvironment.	self assert: (aCategoryEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testClassEnvironment	| aClassEnvironment |	aClassEnvironment := ClassEnvironment 				onEnvironment: BrowserEnvironment new				classes: (Array with: Object with: Object class).	self universalTestFor: aClassEnvironment.	self assert: (aClassEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedClassEnvironment	| environment |	environment := ClassEnvironment new.	environment		addClass: Object;		addClass: OrderedCollection;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self assert: (environment includesClass: Collection).	self deny: (environment includesClass: Object class).	environment removeClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self deny: (environment includesClass: Collection).	self assert: environment numberClasses = 2.	environment addClass: Object class.	self assert: environment numberClasses = 2.	self assert: (environment includesClass: Object class).	environment removeClass: self class.	self assert: environment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedSelectorEnvironment	| environment newEnvironment |	environment := SelectorEnvironment new.	environment		addClass: Object selector: #printString;		addClass: OrderedCollection selector: #add:;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment selectorsForClass: Object) size = 1.	self assert: (environment includesClass: OrderedCollection).	self assert: (environment selectorsForClass: OrderedCollection) size = 1.	self assert: (environment includesClass: Collection).	self assert: (environment selectorsForClass: Collection) size 				= Collection selectors size.	self deny: (environment includesClass: Object class).	newEnvironment := environment copy.	newEnvironment		removeClass: OrderedCollection;		addClass: Object selector: #printOn:;		removeClass: Object selector: #printString.	self assert: (newEnvironment includesClass: Object).	self deny: (newEnvironment includesSelector: #printString in: Object).	self deny: (newEnvironment includesClass: OrderedCollection).	self assert: (newEnvironment includesClass: Collection).	self assert: newEnvironment numberClasses = 2.	self 		assert: newEnvironment numberSelectors + 1 = environment numberSelectors.	newEnvironment addClass: Object class.	self assert: newEnvironment numberClasses = 2.	self assert: (newEnvironment includesClass: Object class).	newEnvironment removeClass: self class.	self assert: newEnvironment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testEnvironmentWrapper	| printString wrapper |	printString := BrowserEnvironment new referencesTo: #printString.	wrapper := BrowserEnvironmentWrapper onEnvironment: printString.	self assert: wrapper numberSelectors = printString numberSelectors.	self assert: wrapper numberClasses = printString numberClasses.	self assert: wrapper environment == printString! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testImplementorsMatching	| print |	print := BrowserEnvironment new implementorsMatching: '*print*'.	self universalTestFor: print.	self assert: (print implementorsOf: #printString) numberSelectors 				= (BrowserEnvironment new implementorsOf: #printString) numberSelectors.	print 		classesAndSelectorsDo: [:class :sel | self assert: ('*print*' match: sel)]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testMatches	| envEnvironment environmentEnvironment |	envEnvironment := BrowserEnvironment new matches: '*env*'.	environmentEnvironment := BrowserEnvironment new 				referencesTo: #environment.	self assert: (envEnvironment referencesTo: #environment) numberSelectors 				= environmentEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testProtocolEnvironment	| aProtocolEnvironment size |	aProtocolEnvironment := ProtocolEnvironment 				onEnvironment: BrowserEnvironment new				class: Object				protocols: #(#printing #testing).	self universalTestFor: aProtocolEnvironment.	self 		assert: (aProtocolEnvironment implementorsOf: #printString) numberSelectors 				= 1.	size := 0.	aProtocolEnvironment classesDo: [:each | size := size + 1].	self assert: size = 1.	aProtocolEnvironment selectorsForClass: Object		do: 			[:each | 			self assert: (#(#printing #testing) 						includes: (BrowserEnvironment new whichProtocolIncludes: each in: Object))]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testRemoveSelectorByAndAndNot	| aBrowserEnvironment objectPrintString |	aBrowserEnvironment := BrowserEnvironment new.	objectPrintString := SelectorEnvironment 				onEnvironment: aBrowserEnvironment.	objectPrintString addClass: Object selector: #printString.	self assert: aBrowserEnvironment numberSelectors - 1 				= (aBrowserEnvironment & objectPrintString not) numberSelectors.	self universalTestFor: aBrowserEnvironment & objectPrintString not! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectMethods	| environment |	environment := BrowserEnvironment new selectMethods: [:each | false].	self assert: environment numberSelectors = 0.	self assert: environment numberClasses = 0.	environment := BrowserEnvironment new selectMethods: [:each | true].	self assert: environment numberSelectors 				= BrowserEnvironment new numberSelectors.	environment := BrowserEnvironment new 				selectMethods: [:each | each refersToLiteral: #environment].	self assert: environment numberSelectors 				= (BrowserEnvironment new referencesTo: #environment) numberSelectors! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectorEnvironment	| printString |	printString := BrowserEnvironment new referencesTo: #printString.	self universalTestFor: printString.	self assert: printString numberSelectors 				= (printString referencesTo: #printString) numberSelectors.	self assert: printString numberClasses 				= (printString referencesTo: #printString) numberClasses! !!BrowserEnvironmentTest methodsFor: 'set up'!setUp	super setUp.	universalEnvironment := BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'AndEnvironment tests' stamp: 'bh 4/10/2001 16:29'!testAndEnvironment	| originalEnvironment objectPrintStringEnvironment andEnvironment |	originalEnvironment := universalEnvironment referencesTo: #printOn:.	objectPrintStringEnvironment := universalEnvironment forClass: Object				selectors: #(#fullPrintString).	andEnvironment := objectPrintStringEnvironment & originalEnvironment.	self universalTestFor: andEnvironment.	self assert: andEnvironment numberSelectors = 1.	self assert: andEnvironment classNames asArray = #(#Object).	self assert: (andEnvironment protocolsFor: Object) size = 1.	andEnvironment := originalEnvironment 				& (universalEnvironment referencesTo: #printString).	self assert: andEnvironment numberSelectors 				= (originalEnvironment referencesTo: #printString) numberSelectors.	self assert: andEnvironment classNames asSortedCollection 				= (originalEnvironment referencesTo: #printString) classNames 						asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'NotEnvironment tests' stamp: 'dvf 9/19/2001 20:41'!testNotEnvironment	| notPrintStringEnvironment printStringEnvironment |	printStringEnvironment := universalEnvironment referencesTo: #printString.	notPrintStringEnvironment := printStringEnvironment not.	self universalTestFor: notPrintStringEnvironment.	self 		assert: (notPrintStringEnvironment referencesTo: #printString) isEmpty.	self assert: (notPrintStringEnvironment not includesClass: BrowserEnvironmentTest).	self assert: (notPrintStringEnvironment not 				includesSelector: #testNotEnvironment				in: BrowserEnvironmentTest)! !!BrowserEnvironmentTest methodsFor: 'OrEnvironment tests' stamp: 'bh 9/17/2001 02:02'!testOrEnvironment	| env1 env2 orEnvironment |	self needsWork. "the following line is temporary, to help a SUnit test pass.  Literal strings withing literal arrays don't show up as references for some reason."	env2 := #printOn:.	env2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).	env1 := universalEnvironment forClass: Object selectors: #(#printOn:).	self assert: (env1 | env2) numberSelectors = 2.	self assert: (env2 | env1) numberSelectors = 2.	self universalTestFor: env1 | env2.	self assert: (env1 | env1) numberSelectors = 1.	orEnvironment := env1 | env1 not.	self universalTestFor: orEnvironment.	self assert: orEnvironment numberSelectors 				= universalEnvironment numberSelectors.	self assert: orEnvironment classNames asSortedCollection 				= universalEnvironment classNames asSortedCollection.	self assert: (orEnvironment protocolsFor: Object) 				= ((universalEnvironment protocolsFor: Object) reject: [:each| (Object allMethodsInCategory: each) isEmpty ])! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 4/29/2000 17:34'!methodsNotToTest	^ self class methodsNotToTest.! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 9/16/2001 22:21'!testParsingAndFormattingEverything	self needsWork. "commented to speed regression testing.  be sure to uncomment."	"Smalltalk allBehaviorsDo: 		[:class | Transcript cr; show:class name.		class selectors do: 			[:sel | (self methodsNotToTest includes: class >> sel) ifFalse: 				[| source tree1 tree2| 				tree2 := RBParser parseMethod: (tree1 := RBParser parseMethod: (class sourceCodeAt: sel)) formattedCode.				self assert:tree1 = tree2]]]"! !!ParserTest methodsFor: 'accessing'!buildArgumentSearch	self 		createArgumentSearchWith: 'aSmalllintContext'		selectors: #(#checkMethod: #checkClass:)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildMessageSearch	self 		createSearchWith: '``@receiver -> ``@arg'		selectors: #(superSends superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodArgumentSearch	"Two argument methods"	self 		createMethodSearchWith: '`arg1: `arg1 `arg2: `arg2 | `@temps | `@.Stmts'		selectors: #(#subclassOf:overrides: #createMatcherFor:method: #createParseTreeRule:name:)		inClass: BasicLintRuleTest class! !!ParserTest methodsFor: 'accessing'!buildMethodSearch	"Simple forwarders"	self 		createMethodSearchWith: '`@methodName: `@args ^`@object `@methodName: `@args'		selectors: #(#problemCount isEmpty)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodTitleSearch	self 		createMethodSearchWith: 'initialize | `@temps | `@.Stmts'		selectors: #(#initialize)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!buildSimpleLiteralSearch	| search |	search := ParseTreeSearcher new.	search		matchesAnyTreeOf:			(Array				with:					(RBParser						parseExpression: '#(''bugs'' ''possible bugs'' ''unnecessary code'' ''intention revealing'' ''miscellaneous'')'))		do: [ :aNode :answer | 			answer				remove: self currentSelector ifAbsent: [ self error: 'failed' ];				yourself ].	search answer: #(#protocols) asBag.	(classSearches at: BasicLintRuleTest class ifAbsentPut: [ Set new ]) add: search! !!ParserTest methodsFor: 'accessing'!buildSimpleVariableSearch	self 		createSearchWith: 'result'		selectors: #(#checkClass: #checkMethod: #isEmpty #problemCount #resetResult #resetResult #resetResult #result #result: #resultClass: #viewResults)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildStatementSearch	"Two or more statements"	self 		createSearchWith: '| `@temps | ``@.Stmts1. ``.Stmt1. ``@.Stmts2. ``.Stmt2. ``@.Stmts3'		selectors: #(#checkMethod: #rewriteUsing: #viewResults #superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!compare: anObject to: anotherObject 	self assert: anObject hash = anotherObject hash.	self assert: anObject = anotherObject! !!ParserTest methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!createArgumentSearchWith: aCodeString selectors: selectorCollection inClass: aClass	| search |	search := ParseTreeSearcher new.	search		matchesAnyArgumentOf: (Array with: aCodeString)		do: [ :aNode :answer | 			answer				remove: self currentSelector ifAbsent: [ self error: 'failed' ];				yourself ].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [ Set new ]) add: search! !!ParserTest methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!createMethodSearchWith: aCodeString selectors: selectorCollection inClass: aClass	| search |	search := ParseTreeSearcher new.	search		matchesAnyMethodOf: (Array with: aCodeString)		do: [ :aNode :answer | 			answer				remove: self currentSelector ifAbsent: [ self error: 'failed' ];				yourself ].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [ Set new ]) add: search! !!ParserTest methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!createSearchWith: aCodeString selectors: selectorCollection inClass: aClass	| search |	search := ParseTreeSearcher new.	search		matches: aCodeString		do: [ :aNode :answer | 			answer				remove: self currentSelector ifAbsent: [ self error: 'failed' ];				yourself ].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [ Set new ]) add: search! !!ParserTest methodsFor: 'accessing'!currentSelector	^currentSelector! !!ParserTest methodsFor: 'accessing'!setUp	super setUp.	classSearches := Dictionary new.	self		buildMethodSearch;		buildSimpleVariableSearch;		buildSimpleLiteralSearch;		buildMessageSearch;		buildStatementSearch;		buildArgumentSearch;		buildMethodTitleSearch;		buildMethodArgumentSearch! !!ParserTest methodsFor: 'private'!parseError: each 	RBParser parseExpression: each first		onError: [:string :pos | ^self assert: pos = each last].	self error: 'Parser didn''t fail'! !!ParserTest methodsFor: 'private'!treeWithEverything	^RBParser 		parseMethod: 'method: arg1 | temps | temps := #(10). temps foo; foo. ^(temps collect: [:e | ])'! !!ParserTest methodsFor: 'private' stamp: 'md 8/2/2005 22:29'!verifySelector: aSelector inClass: aClass 	| myTree otherTree source |	source := aClass sourceCodeAt: aSelector.	source isNil ifTrue: [^self].	myTree := aClass parseTreeFor: aSelector.	otherTree := Parser new 				parse: (ReadStream on: source)				class: aClass				noPattern: false				context: nil				notifying: "SilentCompilerErrorHandler new" nil				ifFail: [^self].	self assert: (myTree notNil or: [otherTree isNil]).	"self should: 			[""	((Compiler new 		compile: myTree formattedCode		in: aClass		notifying: nil		ifFail: [self assert: false]) generate 		isEqualTo: (Compiler new 				compile: otherTree formattedCode				in: aClass				notifying: nil				ifFail: [self assert: false]) generate) 			ifFalse: [self halt]"	"]"! !!ParserTest methodsFor: 'tests'!testAllSearches	classSearches keysAndValuesDo: 			[:class :searches | 			class selectors do: 					[:sel | 					currentSelector := sel.					searches 						do: [:each | each executeTree: (class parseTreeFor: sel) initialAnswer: each answer]]].	classSearches 		do: [:searches | searches do: [:each | self assert: each answer isEmpty]]! !!ParserTest methodsFor: 'tests'!testBestNodeFor	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			each sourceInterval isEmpty 				ifFalse: 					[self assert: ((tree bestNodeFor: each sourceInterval) = each 								or: [each parent isCascade and: [each parent messages last = each]])]]! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testBlockRewrites	| rewriter tree |	tree := RBParser		parseMethod:			'method: asdf	<primitive: 1>	<primitive: 2>	^asdf + self foo + asdf'.	rewriter := ParseTreeRewriter new.	rewriter replace: 'asdf' with: 'fdsa' when: [ :aNode | aNode parent parent isReturn ].	rewriter replace: 'self foo' withValueFrom: [ :aNode | RBVariableNode named: aNode selector asString ].	rewriter replaceArgument: 'asdf' withValueFrom: [ :aNode | RBVariableNode named: 'xxx' ] when: [ :aNode | false ].	rewriter executeTree: tree.	self		compare: tree		to:			(RBParser				parseMethod:					'method: asdf	<primitive: 1>	<primitive: 2>	^asdf +  foo + fdsa')! !!ParserTest methodsFor: 'tests'!testCascadeReplacement	| cascade |	cascade := RBParser parseExpression: 'self foo; bar; baz'.	(cascade messages at: 2) 		replaceWith: (RBParser parseExpression: 'self bar: 2').	self compare: cascade		to: (RBParser parseExpression: 'self foo; bar: 2; baz')! !!ParserTest methodsFor: 'tests'!testComparingTrees	| class |	class := BasicLintRuleTest class.	class selectors 		do: [:each | self compare: (class parseTreeFor: each) to: (class parseTreeFor: each)]! !!ParserTest methodsFor: 'tests'!testCopy	| tree |	tree := self treeWithEverything.	self compare: tree to: tree copy! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 12:11'!testCreationProtocol	| messageNode |	self compare: (RBMessageNode 				receiver: (RBVariableNode named: 'self')				selector: #+				arguments: (Array with: (RBLiteralNode value: 0)))		to: (RBParser parseExpression: 'self + 0').	messageNode := RBMessageNode receiver: (RBVariableNode named: 'self')				selector: #foo.	self compare: (RBMethodNode selector: #bar				body: (RBSequenceNode statements: (OrderedCollection 								with: (RBCascadeNode messages: (OrderedCollection with: messageNode with: messageNode)))))		to: (RBParser parseMethod: 'bar self foo; foo')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testEquivalentExceptRenaming	#(('a 3-4' 'a 4-3' false ) ('a #[3 4]' 'a #(3 4)' false ) ('a variable1 ~~ "comment" variable2' 'a variable1 ~~ variable2' true ) ('a variable1' 'a variable2' false ) ('a [:a :b | a + b]' 'a [:b :a | a + b]' false ) ('a | a b | a + b' 'a | b a | a + b' true ) ('a | a | a msg1; msg2' 'a | b | b msg2; msg2' false ) ('a c' 'a d' true ) ('a | a b | a := b. ^b msg1' 'a | a b | b := a. ^a msg1' true ) ('a | a b | a := b. ^b msg1: a' 'a | a b | b := a. ^b msg1: a' false ) ('a: b b + 4' 'a: e e + 4' true ) ('a: b b + 4' 'b: b b + 4' false ) ('a: b b: c b + c' 'a: c b: b c + b' true ) ('a: a b: b a + b' 'a: b b: a a + b' false ) ) do: [:each | self assert: ((RBParser parseMethod: each first)				equalTo: (RBParser parseMethod: (each at: 2))				exceptForVariables: #('c' ))				== each last ]! !!ParserTest methodsFor: 'tests'!testFormatter	| class |	class := BasicLintRuleTest class.	class selectors do: 			[:each | 			self compare: (class parseTreeFor: each)				to: (RBParser parseMethod: (class parseTreeFor: each) printString)]! !!ParserTest methodsFor: 'tests'!testIntervals	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			(each parent isNil or: [each parent isCascade not]) 				ifTrue: 					[| newNode source |					source := tree source copyFrom: each start to: each stop.					newNode := each isMethod 								ifTrue: [RBParser parseMethod: source]								ifFalse: [RBParser parseExpression: source].					self compare: each to: newNode]]! !!ParserTest methodsFor: 'tests'!testIsA	| nodes types |	nodes := Bag new.	types := Set new.	#(#(#isAssignment 1) #(#isBlock 1) #(#isCascade 1) #(#isLiteral 1) #(#isMessage 3) #(#isMethod 1) #(#isReturn 1) #(#isSequence 2) #(#isValue 14) #(#isVariable 7) #(#isUsed 9) #(#isDirectlyUsed 8) #(#hasParentheses 1) #(#isBinary 0) #(#isPrimitive 0) #(#isImmediate 9)) 		do: 			[:each | 			each last timesRepeat: [nodes add: each first].			types add: each first].	self treeWithEverything nodesDo: 			[:each | 			types do: 					[:sel | 					((each respondsTo: sel) and: [each perform: sel]) 						ifTrue: [nodes remove: sel]]].	self assert: nodes isEmpty! !!ParserTest methodsFor: 'tests'!testLiteralIntevals	| tree |	tree := RBParser parseExpression: '#(#a b #( c ))'.	self assert: tree token value first start = 3.	self assert: tree token value first stop = 4.	self assert: tree token value last value first start = 11! !!ParserTest methodsFor: 'tests'!testMethodPatterns	#(#('+ a ^self + a' #+) #('foo ^self foo' #foo) #('foo: a bar: b ^a + b' #foo:bar:)) 		do: [:each | self assert: (RBParser parseMethodPattern: each first) == each last]! !!ParserTest methodsFor: 'tests' stamp: 'md 2/26/2006 14:48'!testModifying	| tree |	tree := RBParser 				parseMethod: 'foo: a bar: b | c | self first. self second. a + b + c'.	self deny: tree lastIsReturn.	self deny: (tree body statements at: 2) isUsed.	self assert: tree body statements last arguments first isUsed.	self assert: (tree isLast: tree body statements last).	self deny: (tree isLast: tree body statements first).	self assert: (tree defines: 'a').	self deny: (tree defines: 'c').	self assert: (tree body defines: 'c').	self deny: (tree body defines: 'a').	tree		addReturn;		selector: #bar:foo:.	(tree body)		addTemporaryNamed: 'd';		removeTemporaryNamed: 'c'.	self compare: tree		to: (RBParser 				parseMethod: 'bar: a foo: b | d | self first. self second. ^a + b + c').	self 		assert: ((tree argumentNames asSet)				removeAll: #('a' 'b');				yourself) isEmpty.	self 		assert: ((tree allDefinedVariables asSet)				removeAll: #('a' 'b' 'd');				yourself) isEmpty.	tree := RBParser parseExpression: 'self foo: 0'.	tree selector: #+.	self compare: tree to: (RBParser parseExpression: 'self + 0').	self should: [tree selector: #foo] raise: TestResult error.! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testMultimatch	| rewriter count |	count := 0.	rewriter := ParseTreeRewriter new.	rewriter replace: '``@object at: ``@foo' with: '``@object foo: ``@foo' when: [ :aNode | (count := count + 1) == 2 ].	self		compare:			(rewriter				executeTree: (RBParser parseExpression: 'self at: (bar at: 3)');				tree)		to: (RBParser parseExpression: 'self at: (bar foo: 3)')! !!ParserTest methodsFor: 'tests'!testNodesDo	| size |	size := 0.	self treeWithEverything nodesDo: [:e | size := size + 1].	self assert: size = 18! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 14:44'!testNumberParsing	2 to: 32		do: 			[:radix | | radixString |			radixString := radix printString, 'r'.			0 to: 72				do: 					[:i | 					self 						assert: (RBParser 								parseExpression: (radixString, (i radix: radix)))									value = i]]! !!ParserTest methodsFor: 'tests'!testParserErrors	#(#('self foo. + 3' 11) #('#(' 2) #('self 0' 6) #('self asdf;;asfd' 11)) 		do: [:each | self parseError: each]! !!ParserTest methodsFor: 'tests'!testParsingLiteralMessages	self assert: (RBParser parseExpression: 'self nil') isMessage.	self assert: (RBParser parseExpression: 'self true') isMessage.	self assert: (RBParser parseExpression: 'self false') isMessage.	self assert: (RBParser parseExpression: 'self -1') isMessage! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testPatternCascade	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: 'self `;messages; foo: 4; `;messages1' with: 'self `;messages1; bar: 4; `;messages'.	self		compare:			(rewriter				executeTree: (RBParser parseExpression: 'self foo; printString; foo: 4; bar. self foo: 4');				tree)		to: (RBParser parseExpression: 'self bar; bar: 4; foo; printString. self foo:4')! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 12:32'!testPositions	| blockNode |	blockNode := RBParser parseExpression: '[:a :b | ]'.	self assert: blockNode left = 1.	self assert: blockNode right = 10.	self assert: blockNode bar = 8.	self assert: blockNode sourceInterval = (1 to: 10).	self assert: blockNode size = 1.	"test dummy collection protocol"	blockNode printString.	"coverage"	self deny: (blockNode isLast: (RBVariableNode named: 'b')).	self compare: blockNode		to: (RBBlockNode 				arguments: (OrderedCollection with: (RBVariableNode named: 'a')						with: (RBVariableNode named: 'b'))				body: (RBSequenceNode statements: OrderedCollection new)).				! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 13:49'!testPrimitives	self assert: (Object parseTreeFor: #basicAt:) isPrimitive.	#(('foo ^true' false ) ('foo <some: tag> ^true' false ) (' foo <some: tag> <primitive: 123> ^true' true ) ) do: [:each | self assert: (RBParser parseMethod: each first) isPrimitive = each last]! !!ParserTest methodsFor: 'tests'!testQuerying	| tree aNode arg1Node bNode |	tree := RBParser 				parseMethod: ('test: a`	| b |`	b := (self foo: a; bar) baz.`	b := super test: b.`	^[:arg1 | self foa1 + (super foo: arg1 foo: a foo: b)]' 						copyReplaceAll: '`'						with: (String with: (Character value: 13))).	self 		assert: tree selfMessages asSortedCollection asArray = #(#bar #foa1 #foo:).	self assert: tree superMessages asSortedCollection asArray 				= #(#foo:foo:foo: #test:).	aNode := tree whichNodeIsContainedBy: (112 to: 112).	self assert: aNode name = 'a'.	bNode := tree whichNodeIsContainedBy: (119 to: 119).	self assert: bNode name = 'b'.	arg1Node := tree whichNodeIsContainedBy: (102 to: 105).	self assert: arg1Node name = 'arg1'.	self assert: (arg1Node statementNode isMessage 				and: [arg1Node statementNode selector = #+]).	self assert: (arg1Node whoDefines: 'arg1') isBlock.	self assert: (aNode whoDefines: 'a') isMethod.	self assert: (aNode whoDefines: 'b') isSequence.	self assert: (tree whichNodeIsContainedBy: (91 to: 119)) selector 				= #foo:foo:foo:.	self assert: (tree whichNodeIsContainedBy: (69 to: 121)) isBlock.	self assert: (tree whichNodeIsContainedBy: (69 to: 118)) isNil.	self assert: aNode blockVariables asSortedCollection asArray = #('arg1').	self assert: aNode temporaryVariables asSortedCollection asArray = #('b').	self assert: tree allDefinedVariables asSortedCollection asArray 				= #('a' 'arg1' 'b').	self assert: tree allArgumentVariables asSortedCollection asArray 				= #('a' 'arg1').	self 		assert: tree allTemporaryVariables asSortedCollection asArray = #('b')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testReadBeforeWritten	#(('a ifTrue: [^self]' true ) ('self foo. a := b' false ) ('condition ifTrue: [a := b] ifFalse: [self foo: a]' true ) ('condition ifTrue: [a := b] ifFalse: [self foo]. a isNil' true ) ('condition ifTrue: [a := b]. a := c' false ) ('[a := b] whileFalse: [a isNil]' false ) ('self foo: b' false ) ) do: 		[:each | 		self assert: ((RBReadBeforeWrittenTester readBeforeWritten: #('a' ) in: (RBParser parseExpression: each first))				includes: 'a')				== each last.		self assert: (RBReadBeforeWrittenTester isVariable: 'a' readBeforeWrittenIn: (RBParser parseExpression: each first))				= each last].	#('| temp read written written1 |			read ifTrue: [^self].			written1 := self foo ifFalse: [written := true] ifTrue: [written := false].			[temp := true] whileTrue: [temp notNil & written].			^temp' '| read written |			self foo ifTrue: [written := true] ifFalse: [written := false].			self foo ifTrue: [read := true].			^read' '| read written |			self foo do: [:i | i].			[| i | i := 1. i == 1] whileFalse: [read notNil]' '| written |			[written := 2] whileFalse.			self do: [:each | | read | each & read]' '| read |			self do: [:each | read := each].			self do: [:each | each & read]' ) do: 		[:each | 		| read | 		read := RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser parseExpression: each).		self assert: (read size = 1 and: [read includes: 'read'])]! !!ParserTest methodsFor: 'tests'!testReadBeforeWritten1	self 		assert: (RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser 						parseMethod: 'addAll: aCollection 	"Answer aCollection, having added all elements	 of aCollection to the receiver.	 Fail if aCollection is not a kind of	 Collection."	| newSize elementsSize growSize |	(newSize := aCollection size * 2) > elements size ifTrue: [self rehash: newSize].	elementsSize := elements size.	growSize := elementsSize // 2.	aCollection do: 			[:newObject | 			| hashIndex element |			newObject == nil ifFalse: 					[hashIndex := self hashIndexFor: newObject.										[(element := elements at: hashIndex) == nil						ifTrue: 							[elements at: hashIndex put: newObject.							(elementCount := elementCount + 1) > growSize ifTrue: 									[self expand.									elementsSize := elements size.									growSize := elementsSize // 2].							true]						ifFalse: [element == newObject]]							whileFalse: 								[(hashIndex := hashIndex + 1) > elementsSize ifTrue: [hashIndex := 1]]]].	^aCollection')) 				isEmpty! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:39'!testReplacingNodes	| tree search block |	tree := RBParser		parseMethod:			'+ a | a b | self ifTrue: [a] ifFalse: [b := c]. a := b. [:b :c :a | a foo: a; foo1: a; foo2: a foo: b]. ^a'.	search := ParseTreeSearcher new.	block := [ :aNode :answer | aNode replaceWith: (RBVariableNode named: 'q') ].	search		matches: 'a' do: block;		matchesArgument: 'a' do: block.	search executeTree: tree.	self		assert:			tree				=					(RBParser						parseMethod:							'+ q | q b | self ifTrue: [q] ifFalse: [b := c]. q := b. [:b :c :q | q foo: q; foo1: q; foo2: q foo: b]. ^q').	self assert: tree removeDeadCode = (RBParser parseMethod: '+ q | q b | self ifTrue: [] ifFalse: [b := c]. q := b. ^q')! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testRewriteMethods	#(#('arg1: a arg2: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg1: a arg2: b' 'arg2: a arg1: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg2: b arg2: a' '`arg1: `var1 `arg2: `var2 | `@temps | ``@.stmts. self `arg1: `var1 `arg2: `var2. `@.stmts1' '`arg2: `var1 `arg1: `var2 | `@temps | ``@.stmts. self `arg2: `var2 `arg2: `var1. `@.stmts1') #('arg1: a arg2: b | temp1 temp2 | self stmt1. self arg1: a arg2: b' 'arg1: a arg2: b | temp1 temp2 | [self stmt1] repeat' '`@args: `@vars | `@temps | `@.stmts. self `@args: `@vars' '`@args: `@vars | `@temps | [`@.stmts] repeat') #('+ a | temps | ^self primitiveValue' '- a | temps | ^self primitiveValue' '+ `temp | `@tmps | `@.stmts' '- `temp | `@tmps | `@.stmts') #('a self stmt1. self stmt2' 'a self stmt1. self stmt2' 'b | `@temps | `@.stmts' 'c | `@temps | `@.stmts'))		do: [ :each | 			| rewrite |			rewrite := ParseTreeRewriter new.			rewrite replaceMethod: (each at: 3) with: each last.			self				compare:					(RBParser						parseMethod:							(rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2)).			rewrite := ParseTreeRewriter new.			rewrite replaceTree: (RBParser parseRewriteMethod: (each at: 3)) withTree: (RBParser parseRewriteMethod: each last).			self				compare:					(RBParser						parseMethod:							(rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2)) ]! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testRewrites	#(#('[:c | |a| a foo1; foo2]' '[:c | |a| b foo1; foo2]' 'a' 'b') #('self foo: 1. bar foo1 foo: 2. (self foo: a) foo: (b foo: c)' 'self bar: 1. bar foo1 bar: 2. (self bar: a) bar: (b bar: c)' '``@rcvr foo: ``@arg1' '``@rcvr bar: ``@arg1') #('3 + 4' '4 + 4' '3' '4') #('a := self a' 'b := self a' 'a' 'b') #('^self at: 1 put: 2' '^self put: 1 put: 2' '^`@rcvr `at: `@arg1 put: `@arg2' '^`@rcvr put: `@arg1 put: `@arg2') #('1 + 2 + 3' '0 + 0 + 0' '`#literal' '0') #('1 + 2 + 3. 3 foo: 4' '3 + (2 + 1). 4 foo: 3' '``@rcvr `msg: ``@arg' '``@arg `msg: ``@rcvr') #('self foo: a bar: b. 1 foo: a bar: b' '2 foo: a bar: b. 1 foo: a bar: b' 'self `@msg: `@args' '2 `@msg: `@args') #('a := b. a := c + d' 'b := a. a := c + d' '`var1 := `var2' '`var2 := `var1') #('^self foo value: 1' 'self return: (self foo value: 1)' '^`@anything' 'self return: `@anything') #('self first; second. self first; second. self a. self b' '2 timesRepeat: [self first; second]. self a. self b' '`.Stmt1. `.Stmt1. `@.stmts' '2 timesRepeat: [`.Stmt1]. `@.stmts') #('[:a | self a: 1 c: 2; b]' '[:a | self d: 2 e: 1; f. self halt]' '`@rcvr `msg1: `@arg1 `msg2: `@arg2; `msg' '`@rcvr d: `@arg2 e: `@arg1; f. self halt'))		do: [ :each | 			| rewrite |			rewrite := ParseTreeRewriter new.			rewrite replace: (each at: 3) with: each last.			self				compare:					(RBParser						parseExpression:							(rewrite								executeTree: (RBParser parseExpression: each first);								tree) formattedCode)				to: (RBParser parseExpression: (each at: 2)) ]! !!ParserTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:39'!testSearching	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv at: ``@arg `sel: ``@arg1' do: [ :aNode :answer | answer + 1 ].	self		assert:			(searcher				executeTree: (RBParser parseExpression: 'self at: 1 put: 2; at: 2 ifAbsent: []; ifAbsent: 2 at: 1; at: 4; foo')				initialAnswer: 0) = 2.	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv `at: ``@arg1 `at: ``@arg2' do: [ :aNode :answer | answer + 1 ].	self		assert:			(searcher				executeTree: (RBParser parseExpression: 'self at: 1 at: 3; at: 1 put: 32; at: 2; foo; at: 1 at: 1 at: 2')				initialAnswer: 0) = 1.	searcher := ParseTreeSearcher new.	searcher matchesMethod: 'at: `object `put: `o1 ``@rcv `put: 1' do: [ :aNode :answer | true ].	self assert: (searcher executeTree: (RBParser parseMethod: 'at: a put: b self foo put: 1') initialAnswer: false)! !!ParserTest methodsFor: 'long running' stamp: 'dvf 8/27/2003 15:01'!verifyParser	SystemNavigation new allBehaviorsDo: 			[:each | 			each compilerClass = Compiler 				ifTrue: [each selectors do: [:sel | self verifySelector: sel inClass: each]]]! !!RBClassTest methodsFor: 'set up' stamp: 'bh 11/8/2000 14:12'!setUp	| st |	super setUp.	st := RBNamespace new.	objectClass := st classNamed: #Object.	messageNodeClass := st classNamed: #RBMessageNode.	st defineClass: 'Object subclass: #SomeClassName	instanceVariableNames: ''instanceVariable1 instanceVariable2''	classVariableNames: ''ClassVariable1''	poolDictionaries: ''TextConstants''	category: #''Refactory-Testing'''.	newClass := st classNamed: #SomeClassName! !!RBClassTest methodsFor: 'method tests'!testDefinesClassVariable	self deny: (objectClass definesClassVariable: #ClassVariable1).	self assert: (objectClass definesClassVariable: self objectClassVariable).	self assert: (newClass definesClassVariable: #ClassVariable1).	self deny: (messageNodeClass definesClassVariable: #ClassVariable1).	self 		assert: (messageNodeClass definesClassVariable: self objectClassVariable)! !!RBClassTest methodsFor: 'method tests'!testDefinesInstanceVariable	self deny: (objectClass definesInstanceVariable: 'instanceVariable1').	self assert: (newClass definesInstanceVariable: 'instanceVariable1').	self deny: (messageNodeClass definesInstanceVariable: 'instanceVariable1').	self assert: (messageNodeClass definesInstanceVariable: 'parent').	self assert: (messageNodeClass definesInstanceVariable: 'selector')! !!RBClassTest methodsFor: 'method tests'!testDefinesMethod	self assert: (objectClass definesMethod: #printString).	self assert: (newClass definesMethod: #printString).	self assert: (messageNodeClass definesMethod: #printString)! !!RBClassTest methodsFor: 'method tests' stamp: 'bh 4/3/2000 22:22'!testDefinesPoolDictionary	self deny: (objectClass definesPoolDictionary: #OpcodePool).	self assert: (newClass definesPoolDictionary: #TextConstants).	self deny: (messageNodeClass definesPoolDictionary: #OpcodePool).	self assert: ((RBNamespace new classNamed: #Text) 				definesPoolDictionary: #TextConstants)! !!RBClassTest methodsFor: 'method tests'!testHierarchy	| meta |	meta := objectClass metaclass.	self assert: (objectClass withAllSubclasses includes: meta).	self assert: (meta withAllSuperclasses includes: objectClass)! !!RBNamespaceTest methodsFor: 'class tests'!testAllClassesDo	| model classes |	classes := 0.	model := RBNamespace new.	model allClassesDo: 			[:each | 			each name = #Object ifTrue: [each allSubclasses].			classes := classes + 1].	BrowserEnvironment new classesDo: [:each | classes := classes - 1].	self assert: classes = 0! !!RBNamespaceTest methodsFor: 'class tests'!testDefineClassAfterDeletedChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	st defineClass: self class definition.	self assert: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testDefineClassChange	| st |	st := RBNamespace new.	st 		defineClass: 'RefactoringBrowserTest subclass: #SmalltalkTestXXX				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #SmalltalkTestXXX).	self assert: (st classNamed: #SmalltalkTestXXX) notNil! !!RBNamespaceTest methodsFor: 'class tests'!testImplementors	| st |	st := RBNamespace new.	self assert: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object)).	(st classNamed: #Object) removeMethod: #printString.	self deny: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object))! !!RBNamespaceTest methodsFor: 'class tests'!testIncludesClass	self assert: (RBNamespace new includesClassNamed: #Object).	self deny: (RBNamespace new includesClassNamed: #Object1).	self 		deny: ((RBNamespace 				onEnvironment: (ClassEnvironment onEnvironment: BrowserEnvironment new						classes: (Array with: Object))) 					includesClassNamed: #OrderedCollection)! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 9/17/2001 02:03'!testModelImplementorsSenders	| model class modelImps refs found |	model := RBNamespace new.	model 		defineClass: 'Object subclass: #Asdf			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Testing'''.	class := model classNamed: #Asdf.	class compile: 'storeOn: aStream ^super storeOn: aStream'		classified: #(#printing).	modelImps := model allImplementorsOf: #storeOn:.	self assert: (modelImps includes: class).	self assert: modelImps size - 1 				= (BrowserEnvironment new implementorsOf: #storeOn:) numberSelectors.	refs := BrowserEnvironment new referencesTo: #storeOn:.	found := false.	model allReferencesTo: #storeOn:		do: 			[:each | 			each modelClass = class 				ifTrue: [found := true]				ifFalse: 					[self 						assert: (refs includesSelector: each selector in: each modelClass realClass)]].	self assert: found! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testRedefineClassChange	| st |	st := RBNamespace new.	st defineClass: 'nil subclass: #Object				instanceVariableNames: ''a''				classVariableNames: ''A''				poolDictionaries: ''TextConstants''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #Object).	self assert: (st classNamed: #Object) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/10/2001 16:21'!testReferencesPrintOn	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #fullPrintString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOn 								and: [each modelClass = (st classNamed: self class name)]]].	self assert: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testReferencesPrintOnAfterRemove	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	(st classNamed: #Object) removeMethod: #printString.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #printString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOnAfterRemove 								and: [each modelClass = (st classNamed: self class name)]]].	self deny: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testRemoveClassChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) isNil! !!RBNamespaceTest methodsFor: 'class tests'!testReparentSuperclassChange	| st superclass subclasses |	st := RBNamespace new.	superclass := st classFor: TestCase superclass.	subclasses := TestCase subclasses collect: [:each | st classFor: each].	st reparentClasses: subclasses to: superclass.	subclasses do: [:each | self assert: each superclass = superclass]! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/3/2000 15:47'!testRoots	| model |	model := RBNamespace new.	self 		assert: (model rootClasses asSortedCollection: [:a :b | a name < b name]) 				asArray 					= ((Class rootsOfTheWorld collect: [:each | model classFor: each]) 							asSortedCollection: [:a :b | a name < b name]) asArray! !!RefactoringBrowserTest class methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 15:36'!runAllTests	"	RefactoringBrowserTest runAllTests	"	| package runner |	package := PackageInfo named: 'Refactory'.	runner := TestRunner new.	runner openAsMorph.	runner selectTestsSuchThat: [ :t | package includesClass: (Smalltalk classNamed: t) ].! !!ExtraParsingAndFormattingTests class methodsFor: 'testing' stamp: 'nk 2/23/2005 15:56'!methodsNotToTest	^ {"WonderlandCamera >> #destroy:. 	Parser >> #externalFunctionDeclaration. 	BalloonEngineSimulation >> #circleSinTable. 	BalloonEngineSimulation >> #circleCosTable.	PlayWithMe1 >> #listPane2NewSelection:. 	PlayWithMe1 >> #listPane1NewSelection:." 	Interval >> #valuesInclude:. 	Float class >> #initialize }! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter 	self needsWork."what should we do?"	^parameter.	! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter: anObject 	self needsWork."what should we do?"	parameter := anObject.	! !!RefactoringError class methodsFor: 'signalling' stamp: 'md 8/2/2005 23:35'!raiseSignal: aString with: anObject 	"Raise an an exception."	^(self new)		searchFrom: thisContext sender;		messageText: aString;		parameter: anObject;		signal.! !!RefactoringManager methodsFor: 'public access'!addRefactoring: aRefactoring 	RefactoryChangeManager instance performChange: aRefactoring changes.	refactorings add: aRefactoring class name! !!RefactoringManager methodsFor: 'initialize-release'!initialize	refactorings := Bag new! !!RefactoringManager methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: '#		Refactoring';		cr;		nextPutAll: '---		-----------------------------------------------';		cr.	refactorings asSet asSortedCollection do: 			[:name | 			aStream nextPutAll: (refactorings occurrencesOf: name) printString;				nextPutAll: '		';				nextPutAll: name;				cr]! !!RefactoringManager class methodsFor: 'instance creation'!instance	Instance isNil		ifTrue:			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoringManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoringManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoringManager class methodsFor: 'parcel load/unload/save'!preUnloadActionFor: aParcel	^RefactoringManager nuke! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!abstractClassVariable	^ ServiceAction		text: 'Abstract class variable'		button: 'abstract'		description: 'Replaces all direct accesses to the class variable by	message sends to the class'		action: [:r | (AbstractClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!abstractInstanceVariable	^ ServiceAction		text: 'Abstract instance variable'		button: 'Abstract iv'		description: 'Creates accessors and selectors for the selected instance variable,	and replaces all references and assignments to the iv in the code	with call to the accessors'		action: [:r | (AbstractInstanceVariableRefactoring variable: r getInstanceVariableName class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!accessorsForClassVariable	^ ServiceAction		text: 'Create accessors for class variable'		button: 'accessors'		description: 'Creates getters and setters for the selected class variable'		action: [:r | (CreateAccessorsForClassVariableRefactoring				variable: r getClassVariable				class: r getClass				classVariable: true) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!accessorsForInstanceVariable	^ ServiceAction		text: 'Create accessors for instance variable'		button: 'iv accessors'		description: 'Creates getters and setters for the selected instance variable'		action: [:r | (CreateAccessorsForInstanceVariableRefactoring				variable: r getInstanceVariable				class: r getClass				classVariable: false) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:13'!addClass	^ ServiceAction		text: 'New class'		description: 'Create a new subclass of a class. You can also name	some of the class''s subclasses to become subclasses	of the newly created class'		action: [:r | (AddClassRefactoring				addClass: r getNewClassName				superclass: r getClass				subclasses: r getSubclasses				category: r getCategoryName) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:29'!addClassVariable	^ ServiceAction		text: 'Add class variable'		button: 'add'		description: 'Adds a class variable to the class'		action: [:r | (AddClassVariableRefactoring variable: r getNewVariableName class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!addInstanceVariable	^ ServiceAction		text: 'Add instance variable'		button: 'add iv'		description: 'Adds an instance variable to the selected class'		action: [:r | (AddInstanceVariableRefactoring variable: (r caption: 'enter new instance variable name';					 getSymbol) class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!addMethod	^ ServiceAction		text: 'Add method'		description: 'Enter the method name and body, 		the class to implement it in, and		the method category to classify		the new method'		action: [:r | (AddMethodRefactoring				addMethod: r getMethodBody				toClass: r getClass				inProtocols: r getMethodCategoryName) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!addParameter	^ ServiceAction		text: 'Add parameter'		description: 'Adds a parameter to the method.	Requests the new message name,	and an initialization expression for	the new parameter to insert in all	senders of the message'		action: [:r | (AddParameterRefactoring				addParameterToMethod: r getSelector				in: r getClass				newSelector: r getNewSelectorName				initializer: r getInitializingExpressionForTheNewParameter) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!childrenToSiblings	^ ServiceAction		text: 'Convert subclasses to sibling classes'		button: 'sibling'		description: 'Creates a new class which will the selected	class'' superclass. You will then be prompted 	to choose some of the subclasses of this class.	Those classes will become subclasses of the	new class (they''re pushed up). 		Warning : this refactoring involves quite 	a lot of recompilation, so be patient'		action: [:r | (ChildrenToSiblingsRefactoring				name: r getNewSuperClassName				class: r getClass				subclassesNames: r getSubclassesToMoveCollection) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!classRefactorings	^ ServiceCategory 		 text:'Class Refactorings'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!classVariableRefactorings	^ ServiceCategory 		 text:'Class Variable'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:05'!codeSelectionRefactorings	^ ServiceCategory 		 text:'Selection'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractMethod	^ ServiceAction 		text: 'Extract Method'		button: 'Extract'		description: 'Select a piece of text in a method.	You will be prompted to enter a new method	name. The new method will be created, and 	a call will be inserted. If the selected code	exists in another method, you will be asked	whether to use the other method'		action: 			[:r | 			(ExtractMethodRefactoring 				extract: r getSelection				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractMethodToComponent	^ ServiceAction 		text: 'Extract method to component'		button: 'Extract'		description: 'Select a piece of code and an instance or temporary variable.You will then have to choose in this iv''s possible types which one you want to select.The code will be compiled in those classes, and the code will be replaced by a method call on the selected iv.'		action: 			[:r | 			(ExtractMethodToComponentRefactoring 				extract: r getSelection				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractToTemporary	^ ServiceAction 		text: 'Extract to temporary variable'		button: 'Extract temp'		description: 'Converts the selected expression in the code to an	assignment in a temporary variable.'		action: 			[:r | 			(ExtractToTemporaryRefactoring 				extract: r getNode interval				to: (r						caption: 'enter a new variable name';						getString)				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:00'!finderTool	^ ServiceAction		text: 'Find Code'		button: 'find'		description: 'Find some code matching a given pattern'		action: [:r | (FinderTool new searchEnvironment: r getRBEnv environment) openAsMorph]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!inlineAllSenders	^ ServiceAction		text: 'Inline all self sends'		button: 'inline'		description: 'Inlines all the call to the selected message sent by self.	If the message is not called anywhere else, it is removed '		action: [:r | (InlineAllSendersRefactoring sendersOf: r getSelector in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:12'!inlineMethod	^ ServiceAction 		text: 'Inline method'		button: 'inline'		description: 'select a self message send in the method.	The body of this message will be inserted in	the method'		action: 			[:r | 			(InlineMethodRefactoring 				inline: r getMessageNode interval				inMethod: r getSelector				forClass: r getClass) execute]		condition: self blockSelfMessageSendSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!inlineMethodFromComponent	^ ServiceAction 		text: 'Inline method from component'		button: 'inline comp'		description: 'Select a message send to an iv or temp.	You will be prompted to choose one implementation 	of the message, this implementation will be inlined	in place of the call'		action: 			[:r | 			(InlineMethodFromComponentRefactoring 				inline: r getMessageNode interval				inMethod: r getSelector				forClass: r getClass) execute]		condition: self blockNonSelfMessageSendSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!inlineParameter	^ ServiceAction		text: 'Inline parameter'		button: 'inline param'		description: 'Converts the parameter to a temporary variable.	Works if all the calls to the message gives the	same literal value to the parameter.	The parameter is then removed from the message'		action: [:r | (InlineParameterRefactoring				inlineParameter: r getParameterName				in: r getClass				selector: r getSelector) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!inlineTemporary	^ ServiceAction		text: 'Inline temporary'		button: 'inline'		description: 'Select an assignment to a temp.	All references to the temp will be replaced	by the right part of the assignment.'		action: [:r | (InlineTemporaryRefactoring				inline: r getAssignmentNode interval				from: r getSelector				in: r getClass) execute]		condition: [:r | r getAssignmentNode notNil]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!instanceVariableRefactorings	^ ServiceCategory 		 text:'Instance Variable'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:11'!lintTool	^ ServiceAction		text: 'Code Critic'		button: 'critic'		description: 'Analyse the code for some common defects'		action: [:r | LintDialog onEnvironment: r getRBEnv environment]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:05'!methodRefactorings	^ ServiceCategory 		 text:'Method'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!moveMethod	^ ServiceAction		text: 'Move method to variable'		button: 'move'		description: 'Moves the definition of the method to an instance variable	of the class. The message definition is then forwarded to the iv'		action: [:r | (MoveMethodRefactoring				selector: r getSelector				class: r getClass				variable: r getAnyVariable) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:12'!moveVariableDefinition	^ ServiceAction 		text: 'Move variable definition to innermost scope'		button: 'bindTight'		description: 'moves a variable declaration as close to its use as possible.	I.e. if a variable is only used in a block, it''s declaration will	be moved to the beginning of the block.'		action: 			[:r | 			(MoveVariableDefinitionRefactoring 				bindTight: r getSelection				in: r getClass				selector: r getSelector) execute]		condition: self blockVariableSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:13'!protectInstanceVariable	^ ServiceAction		text: 'Protect instance variable'		button: 'protect iv'		description: 'Replaces all accessor by direct accesses to the ivar.	If the accessor are not sent, they are removed as well'		action: [:r | (ProtectInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!pullUpClassVariable	^ ServiceAction		text: 'Pull up class variable'		button: 'pull up'		description: 'Select a class and a class variable.		 The definition will be moved in the superclass'		action: [:r | (PullUpClassVariableRefactoring variable: r getClassVariable class: r getClass superclass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!pullUpInstanceVariable	^ ServiceAction		text: 'Pull up instance variable'		button: 'pull up iv'		description: 'Select a class and an instance variable 	defined in one of it''s subclasses. 	The definition will be moved in the class'		action: [:r | (PullUpInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass superclass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!pushDownClassVariable	^ ServiceAction		text: 'Push down class variable'		button: 'Push  down'		description: 'Push the definition of the selected class variable	in ONE of the subclasses (duplicating it may break	the code)'		action: [:r | (PushDownClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!pushDownInstanceVariable	^ ServiceAction		text: 'Push down instance variable'		button: 'push down iv'		description: 'Pushes the selected instance variable in	the subclasse of the class. It will only be defined	where it is really used'		action: [:r | (PushDownInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!pushDownMethod	^ ServiceAction		text: 'push down methods'		button: 'push down'		description: 'Move a method in all of the subclasses of a class.	It''s definition can be duplicated if there are several	subclasses.'		action: [:r | (PushDownMethodRefactoring pushDown: r getSelectorCollection from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!pushUpMethod	^ ServiceAction		text: 'Push up methods'		button: 'push up'		description: 'Moves the selector to this class'' superclass'		action: [:r | (PushUpMethodRefactoring				pushUp: (Array with: r getMessage)				from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/10/2006 14:47'!refactoringMenu	^ ServiceCategory		text: 'Refactorings'		button: 'R'		description: 'Accesses all refactoring tools'! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!removeClass	^ ServiceAction		text: 'Remove classes'		description: 'Safely removes the selected class'		action: [:r | (RemoveClassRefactoring				classNames: (Array with: r getClass name)) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!removeClassVariable	^ ServiceAction		text: 'Remove class variable'		button: 'remove'		description: 'Removes the selected class variable'		action: [:r | (RemoveClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!removeInstanceVariable	^ ServiceAction		text: 'Remove instance variable'		button: 'Remove iv'		description: 'Safely removes an instance variable'		action: [:r | (RemoveInstanceVariableRefactoring remove: r getInstanceVariableName from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!removeMethods	^ ServiceAction		text: 'Remove methods'		description: 'Safely removes the selected methods'		action: [:r | (RemoveMethodRefactoring removeMethods: r getSelectorCollection from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!removeParameter	^ ServiceAction		text: 'Remove parameter'		button: 'Rm param'		description: 'If a parameter is no more used in a method, you can remove	it, and all senders will be updated'		action: [:r | (RemoveParameterRefactoring				removeParameter: r getParameterName				in: r getClass				selector: r getSelector) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!renameClass	^ ServiceAction		text: 'Rename class'		description: 'Renames a class, changing all references to it'		action: [:r | (RenameClassRefactoring rename: r getClass to: (r caption: 'enter new name';					 getSymbol)) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!renameClassVariable	^ ServiceAction		text: 'Rename class variable'		button: 'Rename'		description: 'Renames a class variable, and update	all references to it.'		action: [:r | (RenameClassVariableRefactoring				rename: r getClassVariableName				to: r getNewVariableName				in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!renameInstanceVariable	^ ServiceAction		text: 'Rename instance variable'		button: 'rename iv'		description: 'Renames an instance variable,	and update all references to it'		action: [:r | (RenameInstanceVariableRefactoring				rename: r getInstanceVariable				to: r getNewVariableName				in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:08'!renameMethod	^ ServiceAction		text: 'Rename method'		button: 'Rename'		description: 'Renames a method, and fixes all senders.	You can if you want change the orders in	which the arguments are passed to the	new method'		action: [:r | (RenameMethodRefactoring				renameMethod: r getSelector				in: r getClass				to: r getNewSelectorName				permutation: r getArgumentPermutation) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!renameTemporary	^ ServiceAction		text: 'rename local variable'		button: 'Rename'		description: 'Renames a temporary variable !!'		action: [:r | (RenameTemporaryRefactoring				renameTemporaryFrom: r getArgOrTempNode interval				to: r getNewVariableName				in: r getClass				selector: r getSelector) execute]		condition: [:r | r getArgOrTempNode notNil]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:10'!rewriteTool	^ ServiceAction		text: 'Rewrite Code'		button: 'rewrite'		description: 'Rewrite some code matching a given pattern to another form'		action: [:r | (RewriteTool new searchEnvironment: r getRBEnv environment) openAsMorph]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!splitClass	^ ServiceAction		text: 'Split class in two components'		button: 'split'		description: 'Create a new class at the same level than the old class,	with the list of instance variable selected from the old class.	These ivs are then removed from the old class.	A new iv will be added, on which the request to the	removed iv will be forwarded. Thus the new class	will become a component of the old class.'		action: [:r | (SplitClassRefactoring				class: r getClass				instanceVariables: r getInstanceVariablesToMoveInTheNewClassCollection				newClassName: r getNewClassName				referenceVariableName: r getNewVariableWhereRequestsWillBeForwarded) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!temporaryToInstanceVariable	^ ServiceAction		text: 'Convert temporary to instance variable'		button: 'convert'		description: 'Converts a temporary variable in a method	to an instance variable of the class'		action: [:r | (TemporaryToInstanceVariableRefactoring				class: r getClass				selector: r getSelector				variable: r getTempNode name) execute]		condition: [:r | r getTempNode notNil]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:11'!blockExtractableCodeSelected	^ 	[:r | 	| n |	n := r getNode.	n parent notNil and: [n parent isMethod not or: [n isVariable not]]		and: [n parent isSequence not or: [n isVariable not]]]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:11'!blockNonSelfMessageSendSelected	^ [:r | r getMessageNode notNil & (self isSelfMessageSend: r getMessageNode) not]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:12'!blockSelfMessageSendSelected	^ [:r | self isSelfMessageSend: r getMessageNode]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:12'!blockVariableSelected	^ [:r | r getSelectionNode isVariable]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 1/9/2006 17:41'!isSelfMessageSend: messageNode 	^messageNode notNil and: [messageNode receiver isVariable]		and: [messageNode receiver name = 'self']! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserButtonBarrefactoringMenu	^ #(#'Items in browserButtonBar:' #refactoringMenu 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuclassRefactorings	^ #(#'Items in browserClassMenu:' #classRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuclassVariableRefactorings	^ #(#'Items in browserClassMenu:' #classVariableRefactorings 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuinstanceVariableRefactorings	^ #(#'Items in browserClassMenu:' #instanceVariableRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserCodePaneMenucodeSelectionRefactorings	^ #(#'Items in browserCodePaneMenu:' #codeSelectionRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserMethodMenumethodRefactorings	^ #(#'Items in browserMethodMenu:' #methodRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsaddClass	^ #(#'Items in classRefactorings:' #addClass 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringschildrenToSiblings	^ #(#'Items in classRefactorings:' #childrenToSiblings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsremoveClass	^ #(#'Items in classRefactorings:' #removeClass 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsrenameClass	^ #(#'Items in classRefactorings:' #renameClass 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringssplitClass	^ #(#'Items in classRefactorings:' #splitClass 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsabstractClassVariable	^ #(#'Items in classVariableRefactorings:' #abstractClassVariable 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsaccessorsForClassVariable	^ #(#'Items in classVariableRefactorings:' #accessorsForClassVariable 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsaddClassVariable	^ #(#'Items in classVariableRefactorings:' #addClassVariable 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringspullUpClassVariable	^ #(#'Items in classVariableRefactorings:' #pullUpClassVariable 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringspushDownClassVariable	^ #(#'Items in classVariableRefactorings:' #pushDownClassVariable 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsremoveClassVariable	^ #(#'Items in classVariableRefactorings:' #removeClassVariable 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsrenameClassVariable	^ #(#'Items in classVariableRefactorings:' #renameClassVariable 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractMethod	^ #(#'Items in codeSelectionRefactorings:' #extractMethod 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractMethodToComponent	^ #(#'Items in codeSelectionRefactorings:' #extractMethodToComponent 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractToTemporary	^ #(#'Items in codeSelectionRefactorings:' #extractToTemporary 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineMethod	^ #(#'Items in codeSelectionRefactorings:' #inlineMethod 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineMethodFromComponent	^ #(#'Items in codeSelectionRefactorings:' #inlineMethodFromComponent 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineTemporary	^ #(#'Items in codeSelectionRefactorings:' #inlineTemporary 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsmoveVariableDefinition	^ #(#'Items in codeSelectionRefactorings:' #moveVariableDefinition 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsrenameTemporary	^ #(#'Items in codeSelectionRefactorings:' #renameTemporary 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringstemporaryToInstanceVariable	^ #(#'Items in codeSelectionRefactorings:' #temporaryToInstanceVariable 9 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsabstractInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #abstractInstanceVariable 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsaccessorsForInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #accessorsForInstanceVariable 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsaddInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #addInstanceVariable 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsprotectInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #protectInstanceVariable 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringspullUpInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #pullUpInstanceVariable 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringspushDownInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #pushDownInstanceVariable 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsremoveInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #removeInstanceVariable 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsrenameInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #renameInstanceVariable 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsaddMethod	^ #(#'Items in methodRefactorings:' #addMethod 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsaddParameter	^ #(#'Items in methodRefactorings:' #addParameter 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsinlineAllSenders	^ #(#'Items in methodRefactorings:' #inlineAllSenders 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsinlineParameter	^ #(#'Items in methodRefactorings:' #inlineParameter 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsmoveMethod	^ #(#'Items in methodRefactorings:' #moveMethod 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringspushDownMethod	^ #(#'Items in methodRefactorings:' #pushDownMethod 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringspushUpMethod	^ #(#'Items in methodRefactorings:' #pushUpMethod 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsremoveMethods	^ #(#'Items in methodRefactorings:' #removeMethods 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsremoveParameter	^ #(#'Items in methodRefactorings:' #removeParameter 9 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsrenameMethod	^ #(#'Items in methodRefactorings:' #renameMethod 10 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuclassRefactorings	^ #(#'Items in refactoringMenu:' #classRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuclassVariableRefactorings	^ #(#'Items in refactoringMenu:' #classVariableRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenucodeSelectionRefactorings	^ #(#'Items in refactoringMenu:' #codeSelectionRefactorings 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenufinderTool	^ #(#'Items in refactoringMenu:' #finderTool 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuinstanceVariableRefactorings	^ #(#'Items in refactoringMenu:' #instanceVariableRefactorings 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenulintTool	^ #(#'Items in refactoringMenu:' #lintTool 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenumethodRefactorings	^ #(#'Items in refactoringMenu:' #methodRefactorings 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenurewriteTool	^ #(#'Items in refactoringMenu:' #rewriteTool 7 )! !!RefactoringServiceProvider class methodsFor: 'initialize-release' stamp: 'rr 2/20/2007 18:09'!initialize	super initialize.	ServiceRegistry current buildProvider: self new! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 15:15'!abstractVariableTestData^'| model |(model := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#Bar #Foo) inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#Bar #Foo) inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #Foo	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Foo subclass: #Bar	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | model defineClass: each].#(#(#Bar #(#(''instVarName1	^1242321'' #tests) #(''foo	instVarName1 := instVarName1 + instVarName2 + ClassVarName1'' #tests))) #(#Foo #(#(''foo	^instVarName2 := 3'' #tests) #(''bar	"Add one to instVarName1"	instVarName1 := instVarName1 + 1'' #tests) #(''classVarName1	^ClassVarName1'' #tests) #(''instVarName1: anObject	^anObject'' #tests) #(''asdf	^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)'' #tests) #(''instVarName2	^instVarName2'' #tests) #(''instVarName2: anObject	instVarName2 := anObject'' #tests) #(''classVarName1: anObject	^ClassVarName1 := anObject'' #tests))) #(''Bar class'' #(#(''classVarName2: anObject	ClassVarName2 := anObject'' #tests) #(''classVarName2	^ClassVarName2'' #tests))) #(''Foo class'' #(#(''foo	^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1'' #tests)))) 	do: 		[:each | 		| class |		class := model classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].model'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:12'!childrenToSiblingTestData^'| m |(m:= RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 										inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''ConcreteSuperclass subclass: #NoMoveSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Object subclass: #ConcreteSuperclass	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''Testing'''''' ''ConcreteSuperclass subclass: #ConcreteSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | m defineClass: each].(m metaclassNamed: #ConcreteSuperclass) 	addInstanceVariable: ''classInstVarName1''.#(#(#ConcreteSubclass #(#(''initialize	super initialize.	instVarName1 := nil'' #everyone) #(''different	^0'' #everyone))) #(#ConcreteSuperclass #(#(''same	^self initialize isKindOf: ConcreteSuperclass'' #''one def'') #(''different	^instVarName1 + instVarName2'' #everyone) #(''initialize	instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0'' #everyone))) #(#NoMoveSubclass #(#(''same	^123'' #''one def''))) #(''ConcreteSubclass class'' #(#(''bar	^self storeString'' #testing))) #(''ConcreteSuperclass class'' #(#(''foo	^classInstVarName1 + ClassVarName1 + ClassVarName2'' #testing) #(''new	^super new initialize'' #testing) #(''bar	^self printString'' #testing))) #(''NoMoveSubclass class'' #())) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:45'!inlineMethodTestData^ '| m |(m := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#RenameClassVariableChange #VariableCompositeRefactoryChange #RenameInstanceVariableChange #CompositeRefactoryChange #RenameVariableChange #RefactoryChange) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#() inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #RefactoryChange	instanceVariableNames: ''''name ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RefactoryChange subclass: #CompositeRefactoryChange	instanceVariableNames: ''''changes ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''CompositeRefactoryChange subclass: #VariableCompositeRefactoryChange	instanceVariableNames: ''''className isMeta ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''VariableCompositeRefactoryChange subclass: #RenameVariableChange	instanceVariableNames: ''''oldName newName ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameClassVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameInstanceVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''') 	do: [:each | m defineClass: each].#(#(#RenameClassVariableChange #(#(''removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute'' #private) #(''addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass at: newName asSymbol put: oldValue'' #private))) #(#VariableCompositeRefactoryChange #(#(''displayClassName	^isMeta 		ifTrue: [self changeClassName , '''' class'''']		ifFalse: [self changeClassName asString]'' #printing) #(''isMeta	^isMeta'' #private) #(''changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]'' #accessing) #(''hash	^self changeClassName hash'' #comparing) #(''changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]'' #accessing) #(''changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]'' #accessing) #(''printOn: aStream	aStream nextPutAll: self displayString'' #printing) #(''changeClassName	^className'' #accessing) #(''= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]'' #comparing))) #(#RenameInstanceVariableChange #(#(''removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute'' #private) #(''addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | each instVarAt: newIndex put: (each instVarAt: oldIndex)]]'' #private))) #(#CompositeRefactoryChange #(#(''compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)'' #''refactory-changes'') #(''addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''removeChange: aChange 	changes remove: aChange ifAbsent: []'' #''private-inspector accessing'') #(''addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)'' #''refactory-changes'') #(''initialize	super initialize.	changes := OrderedCollection new'' #''initialize-release'') #(''defineClass: aString 	^self addChange: (AddClassChange definition: aString)'' #''refactory-changes'') #(''changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''printOn: aStream 	aStream nextPutAll: name'' #printing) #(''inspect	RefactoryBuilderInspector openOn: self'' #''user interface'') #(''flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]'' #private) #(''hash	^changes size'' #comparing) #(''= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true'' #comparing) #(''renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)'' #''refactory-changes'') #(''renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself'' #accessing) #(''postCopy	super postCopy.	changes := changes collect: [:each | each copy]'' #copying) #(''changes: aCollection 	changes := aCollection'' #''private-inspector accessing'') #(''addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)'' #''refactory-changes'') #(''changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo'' #private) #(''changes	^changes'' #''private-inspector accessing'') #(''removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)'' #''refactory-changes'') #(''removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass)'' #''refactory-changes'') #(''addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]'' #accessing) #(''displayString	^super displayString asText allBold'' #printing) #(''problemCount	^self changesSize'' #accessing))) #(#RenameVariableChange #(#(''oldName: aString	oldName := aString'' #private) #(''executeNotifying: aBlock 	| undo |	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	^undo'' #private) #(''newName: aString 	newName := aString'' #private) #(''changeString	^''''Rename '''' , oldName , '''' to '''' , newName'' #printing))) #(#RefactoryChange #(#(''flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes'' #private) #(''name: aString	name := aString'' #''initialize-release'') #(''initialize'' #''initialize-release'') #(''changeForMetaclass: aSymbol selector: aSelector 	^nil'' #accessing) #(''changeString	^self class name'' #printing) #(''changeForClass: aRBClass selector: aSelector 	^nil'' #accessing) #(''executeWithMessage: aString 	| tally controller m done |	m := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: m label: aString].	m value: 0.	^	[self executeNotifying: 			[done := done + 1.			m value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]'' #''performing-changes'') #(''executeNotifying: aBlock 	self subclassResponsibility'' #private) #(''changes	^Array with: self'' #accessing) #(''execute	^self executeNotifying: []'' #''performing-changes'') #(''inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect'' #''user interface'') #(''flattenOnto: aCollection 	aCollection add: self'' #private) #(''name	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #accessing) #(''changesSize	^1'' #accessing) #(''displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #printing) #(''renameChangesForClass: aClassName to: newClassName 	"We are in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility'' #accessing)))) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'private'!shouldFail: aRefactoring 	self proceedThroughWarning: 			[self should: [self executeRefactoring: aRefactoring]				raise: RefactoringError]! !!RefactoringTest methodsFor: 'private'!shouldWarn: aRefactoring 	self should: [self executeRefactoring: aRefactoring]		raise: RefactoringWarning! !!RefactoringTest methodsFor: 'set up'!setUp	| assoc |	super setUp.	assoc := RefactoringManager classPool associationAt: #Instance				ifAbsent: [RefactoringManager classPool associationAt: 'Instance'].	manager := assoc value.	assoc value: nil.	model := RBNamespace new! !!RefactoringTest methodsFor: 'set up'!setupImplementorToInlineFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #implementorToInline put: [:ref :imps | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupInlineExpressionFor: aRefactoring toReturn: aBoolean 	| options |	options := aRefactoring options copy.	options at: #inlineExpression put: [:ref :string | aBoolean].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector withArguments: stringCollection 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				arguments: stringCollection;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupSelfArgumentNameFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selfArgumentName put: [:ref | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableToMoveToFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selectVariableToMoveTo put: [:ref :class :selector | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableTypesFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #variableTypes put: [:ref :ignore1 :ignore2 | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!tearDown	super tearDown.	RefactoringManager instance release.	(RefactoringManager classPool associationAt: #Instance		ifAbsent: [RefactoringManager classPool associationAt: 'Instance']) 			value: manager! !!RefactoringTest methodsFor: 'tests' stamp: 'bh 4/2/2000 22:28'!testConditions	| condition newCondition |	condition := RBCondition new 				type: #false				block: [false]				errorString: 'false'.	condition errorMacro: '<1?true:false>'.	self deny: condition check.	self assert: condition errorString = 'false'.	self assert: condition not check.	self assert: condition printString = 'false'.	self assert: condition not printString = 'NOT false'.	self deny: (condition not & condition) check.	self 		assert: (condition not & condition) printString = 'NOT false & false'.	self assert: (condition & condition) not check.	self assert: (condition | condition not) check.	self deny: (newCondition := condition | condition) check.	self assert: newCondition errorString = 'false AND false'.	self assert: (condition not | condition not) check.	self deny: (newCondition := condition & condition) check.	self assert: newCondition errorString = 'false'.	self assert: (condition not & condition not) check.	self assert: (condition & condition) errorString = 'false OR false'! !!RefactoringTest methodsFor: 'tests' stamp: 'md 8/2/2005 22:19'!testPrintRefactoringManager	Transcript		show: RefactoringManager instance printString;		cr.! !!AbstractClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractClassVariableTest methodsFor: 'tests'!testAbstractClassVariable	| refactoring meta class |	refactoring := AbstractClassVariableRefactoring 				variable: 'RecursiveSelfRule'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	meta := class metaclass.	self assert: (meta parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self 		assert: (meta parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (meta parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke							self recursiveSelfRule: nil').	self 		assert: (meta parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1							self recursiveSelfRule: ParseTreeSearcher new.							self recursiveSelfRule								addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')										-> [:aNode :answer | true]').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 							class := aSmalllintContext selectedClass.							(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 									[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)										ifFalse: 											[builder compile: rewriteRule tree printString												in: class												classified: aSmalllintContext protocols]]')! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariable	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName1'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1 ^ClassVarName1').	self 		assert: (meta parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject ^ClassVarName1 := anObject').	self 		assert: (meta parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').	self assert: (class parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1							^self class classVarName1').	self 		assert: (class parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject							^self class classVarName1: anObject').	self 		assert: (class parseTreeFor: #asdf) = (RBParser 						parseMethod: 'asdf						^self classVarName1: (self class classVarName1: self class classVarName1 + 1)').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					instVarName1 := instVarName1 + instVarName2 + self class classVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + instVarName2 + self class classVarName1')! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariableOverridenMethodsInSubclass	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName21) 				= (RBParser parseMethod: 'classVarName21 ^ClassVarName2').	self 		assert: (meta parseTreeFor: #classVarName21:) = (RBParser 						parseMethod: 'classVarName21: anObject ClassVarName2 := anObject')! !!AbstractClassVariableTest methodsFor: 'failure tests'!testInheritedName	self 		shouldFail: (AbstractClassVariableRefactoring variable: #DependentsFields				class: BasicLintRuleTest)! !!AbstractClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (AbstractClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest class)! !!AbstractClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!AbstractInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractInstanceVariable	| refactoring class |	refactoring := AbstractInstanceVariableRefactoring variable: 'class'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject	class := anObject').	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args'' 				-> (					[:aNode | 					(self class1 withAllSubclasses 						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil] 							-> ''self `@message: ``@args'').	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	self class: aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[builder 						compile: rewriteRule tree printString						in: self class1						classified: aSmalllintContext protocols]]')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithAssignmentUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo						^self instVarName21: 3').	self 		assert: (class parseTreeFor: #instVarName2:) = (RBParser 						parseMethod: 'instVarName2: anObject						self instVarName21: anObject').	self 		assert: (class parseTreeFor: #instVarName21:) = (RBParser 						parseMethod: 'instVarName21: anObject						^instVarName2 := anObject').	self assert: (class parseTreeFor: #instVarName2) 				= (RBParser parseMethod: 'instVarName2						^instVarName2').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithDefaultNamesUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #bar) = (RBParser 						parseMethod: 'bar						"Add one to instVarName1"						self instVarName11: self instVarName11 + 1').	self 		assert: (class parseTreeFor: #instVarName11:) = (RBParser 						parseMethod: 'instVarName11: anObject						instVarName1 := anObject').	self assert: (class parseTreeFor: #instVarName11) 				= (RBParser parseMethod: 'instVarName11						^instVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testMetaclassInstanceVariables	| refactoring class |	class := model metaclassNamed: #Foo.	class addInstanceVariable: 'foo'.	class compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'foo'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo1) 				= (RBParser parseMethod: 'foo1						^foo').	self assert: (class parseTreeFor: #foo:) 				= (RBParser parseMethod: 'foo: anObject						^foo := anObject').	self assert: (class parseTreeFor: #zzz) 				= (RBParser parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testInheritedName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'name'				class: BasicLintRuleTest)! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!AddClassTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassTest methodsFor: 'tests'!testAddClass	| refactoring newClass superClass classTest |	refactoring := AddClassRefactoring 				addClass: #FooTest				superclass: RefactoringTest				subclasses: (Array with: self class)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := refactoring model classNamed: #FooTest.	superClass := refactoring model classNamed: #RefactoringTest.	classTest := refactoring model classNamed: self class name.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: classTest superclass = newClass.	self assert: (newClass subclasses includes: classTest).	self assert: classTest metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: classTest metaclass)! !!AddClassTest methodsFor: 'tests' stamp: 'bh 3/27/2000 22:39'!testModelAddClass	| refactoring newClass superClass subclass |	subclass := model classNamed: #Bar.	superClass := model classNamed: #Foo.	refactoring := AddClassRefactoring 				model: model				addClass: #FooTest				superclass: superClass				subclasses: (Array with: subclass)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := model classNamed: #FooTest.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: subclass superclass = newClass.	self assert: (newClass subclasses includes: subclass).	self assert: subclass metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: subclass metaclass)! !!AddClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (AddClassRefactoring 				addClass: #Object				superclass: self class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: CompositeLintRuleTest				subclasses: (Array with: BasicLintRuleTest)				category: #'Refactory-Tesing')! !!AddClassTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: self class class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'failure tests'!testModelExistingName	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo				superclass: Object				subclasses: #()				category: #'Refactory-Testing'.	self shouldFail: refactoring! !!AddClassTest methodsFor: 'failure tests'!testModelInvalidSubclass	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo2				superclass: Object				subclasses: (Array with: (model classNamed: #Bar))				category: #'Refactory-Tesing'.	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassVariableTest methodsFor: 'tests'!testAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring variable: 'Asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #Asdf)! !!AddClassVariableTest methodsFor: 'tests'!testModelAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar).	self executeRefactoring: refactoring.	self assert: ((model classNamed: #Bar) 				directlyDefinesClassVariable: #ClassVarName3)! !!AddClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddClassVariableRefactoring variable: #RecursiveSelfRule					class: TransformationRuleTest);		shouldFail: (AddClassVariableRefactoring variable: self objectClassVariable					class: TransformationRuleTest)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassVariableRefactoring variable: #VariableName				class: TransformationRuleTest class)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring variable: #ClassVarName3				class: (model classNamed: #Object) metaclass.	refactoring model: model.	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName2				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'failure tests'!testModelMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar) metaclass.	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddInstanceVariableTest methodsFor: 'tests'!testAddInstanceVariable	| refactoring |	refactoring := AddInstanceVariableRefactoring variable: 'asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:07'!testAddToModel	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #FOOBAR) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddInstanceVariableRefactoring variable: 'class'					class: TransformationRuleTest);		shouldFail: (AddInstanceVariableRefactoring variable: 'name'					class: TransformationRuleTest)! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelMetaclassAlreadyExistingName	| refactoring |	(model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewHierarchyExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	model 		defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #BARFOO).	self shouldFail: refactoring! !!AddMethodTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddMethodTest methodsFor: 'tests'!testAddMethod	| refactoring |	refactoring := AddMethodRefactoring 				addMethod: 'printString1 ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #printString1) 					= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'tests'!testModelAddMethod	| refactoring class |	class := model metaclassNamed: #Bar.	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString1 ^super printString'				toClass: class				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #printString1) 				= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'failure tests'!testBadMethod	self shouldFail: (AddMethodRefactoring 				addMethod: 'asdf ^super ^printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'failure tests'!testExistingSelector	self shouldFail: (AddMethodRefactoring 				addMethod: 'printString ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'failure tests'!testModelExistingSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'classVarName1 ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddMethodTest methodsFor: 'failure tests'!testModelInheritedSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddParameterTest methodsFor: 'tests'!testAddParameterForTwoArgumentMessage	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('called:' , 'on:') asSymbol				in: RefactoryTestDataApp				newSelector: #called:bar:on:				initializer: '#(1.0)'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #called:bar:on:) = (RBParser 						parseMethod: 'called: anObject bar: aBlock on: anObject1							Transcript								show: anObject printString;								cr.								aBlock value').	self 		assert: (class parseTreeFor: #caller) = (RBParser 						parseMethod: 'caller							| anObject |							anObject := 5.							self 								called: anObject + 1								bar: [^anObject] on: #(1.0)').	self deny: (class directlyDefinesMethod: ('called:' , 'on:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesGlobalAndLiteral	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'OrderedCollection new: 5'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self 		assert: (class parseTreeFor: #callFoo) = (RBParser 						parseMethod: 'callFoo ^self testFoo: 5 bar: (OrderedCollection new: 5)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesModelGlobal	| refactoring class |	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'Bar new'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo) 				= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (Bar new)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests' stamp: 'bh 3/14/2000 18:15'!testAddParameterThatReferencesSelf	| refactoring class |	refactoring := AddParameterRefactoring				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'self printString'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #testFoo:bar:)			= (RBParser parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo)			= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (self printString)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'failure tests'!testBadInitializationCode	self		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo:');		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo')! !!AddParameterTest methodsFor: 'failure tests'!testModelBadInitializationCode	| refactoring |	model removeClassNamed: #Refactoring.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'AddParameterRefactoring new'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testModelNonExistantName	| refactoring |	(model classNamed: #LintRuleTest) removeMethod: #name.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name				in: LintRuleTest				newSelector: #nameNew:				initializer: 'nil'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AddParameterRefactoring 				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'nil')! !!AddParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #foo				in: Object				newSelector: #foo123124321s:				initializer: '1'.	self shouldFail: refactoring.	refactoring := AddParameterRefactoring 				addParameterToMethod: #at:				in: Object				newSelector: #at:foo:				initializer: '1'.	self shouldFail: refactoring.	! !!ChildrenToSiblingsTest methodsFor: 'set up' stamp: 'md 7/25/2005 18:08'!setUp	super setUp.	model :=  Compiler evaluate: self childrenToSiblingTestData.! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #'Obje ct'				class: LintRuleTest				subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testExistingName	self		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Object					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest));		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Processor					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest				subclasses: (Array with: BasicLintRule with: CompositeLintRule))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest class				subclasses: (Array with: BasicLintRuleTest class						with: CompositeLintRuleTest class))! !!ChildrenToSiblingsTest methodsFor: 'tests'!testModelChildrenToSibling	| refactoring class subclass superclass |	class := model classNamed: #ConcreteSuperclass.	subclass := model classNamed: #ConcreteSubclass.	refactoring := ChildrenToSiblingsRefactoring 				model: model				name: #AbstractSuperclass				class: class				subclasses: (Array with: subclass).	self executeRefactoring: refactoring.	superclass := refactoring model classNamed: #AbstractSuperclass.	self assert: class superclass = superclass.	self assert: class metaclass superclass = superclass metaclass.	self assert: subclass superclass = superclass.	self assert: subclass metaclass superclass = superclass metaclass.	self 		assert: (superclass parseTreeFor: #same) = (RBParser 						parseMethod: 'same ^self initialize isKindOf: AbstractSuperclass').	self assert: (superclass parseTreeFor: #different) 				= (RBParser parseMethod: 'different self subclassResponsibility').	self 		assert: (superclass parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize							instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName1').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName2').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName1').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName2').	self assert: (superclass metaclass 				directlyDefinesInstanceVariable: 'classInstVarName1').	self 		assert: (superclass metaclass parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo							^classInstVarName1 + ClassVarName1 + ClassVarName2').	self assert: (superclass metaclass parseTreeFor: #new) 				= (RBParser parseMethod: 'new							^super new initialize').	self assert: (superclass metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							self subclassResponsibility').	self deny: (class directlyDefinesInstanceVariable: 'instVarName1').	self deny: (class directlyDefinesInstanceVariable: 'instVarName2').	self deny: (class directlyDefinesClassVariable: 'ClassVarName1').	self deny: (class directlyDefinesClassVariable: 'ClassVarName2').	self 		deny: (class metaclass directlyDefinesInstanceVariable: 'classInstVarName1').	self deny: (class directlyDefinesMethod: #same).	self deny: (class directlyDefinesMethod: #initialize).	self deny: (class metaclass directlyDefinesMethod: #new).	self assert: (class parseTreeFor: #different) 				= (RBParser parseMethod: 'different							^instVarName1 + instVarName2').	self assert: (class metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							^self printString')! !!CreateAccessorsForVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testExistingInstanceVariableAccessors	| ref |	ref := CreateAccessorsForVariableRefactoring 				variable: 'name'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	self assert: ref changes changes isEmpty.	self assert: ref setterMethod == #name:.	self assert: ref getterMethod == #name! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewClassVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'Foo1'				class: LintRuleTest				classVariable: true.	self executeRefactoring: ref.	class := ref model metaclassNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^Foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject Foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewInstanceVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'foo1'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	class := ref model classNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: #Foo					class: BasicLintRuleTest					classVariable: true);		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: 'foo'					class: BasicLintRuleTest					classVariable: true)! !!ExtractMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:13'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor	| rules |	rules := self failedRules.	^self foo: rules').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: rules	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatMovesTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (22 to: 280)						for: (TransformationRuleTest sourceCodeAt: #superSends))				from: #superSends				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := self foo.	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo | rule | 	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args''				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').		^rule')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsArgument	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (145 to: 343)						for: (TransformationRuleTest sourceCodeAt: #checkMethod:))				from: #checkMethod:				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (78 to: 197)						for: (LintRuleTest sourceCodeAt: #displayName))				from: #displayName				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')! !!ExtractMethodTest methodsFor: 'tests'!testModelExtractMethodWithTemporariesSelected	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'foo [| temp | temp := 5. temp * temp] value'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (6 to: 36)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo [self foobar] value').	self assert: (class parseTreeFor: #foobar) 				= (RBParser parseMethod: 'foobar |temp | temp := 5. ^temp * temp')! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 9/16/2001 21:06'!testModelExtractMethodWithTemporaryAssigned	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class 		compile: 'foo 				| temp bar | 				bar := 5. 				temp := bar * bar. 				Transcript show: temp printString; cr. 				^temp * temp'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (26 to: 102)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').	self 		assert: ((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | bar temp | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.')) |				((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.'))! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodToComponentRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractMethodToComponentTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:14'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self setupSelfArgumentNameFor: refactoring toReturn: 'asdf'.	self setupVariableToMoveToFor: refactoring toReturn: 'rules'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Collection)).	class := refactoring model classNamed: #LintRuleTest.	selectorsSize := class selectors size.	self proceedThroughWarning: [self executeRefactoring: refactoring].	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor								| rules |								rules := self failedRules.								^rules foo: self').	self 		assert: ((refactoring model classNamed: #Collection) parseTreeFor: #foo:) 				= (RBParser 						parseMethod: 'foo: asdf								self isEmpty ifTrue: [^asdf].								self size == 1 ifTrue: [^self first viewResults].								SmalllintResultEditor openOn: asdf label: asdf name.								^asdf').	self assert: class selectors size = selectorsSize! !!ExtractMethodToComponentTest methodsFor: 'tests'!testMoveWithoutSelfReference	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (118 to: 285)						for: (RBReadBeforeWrittenTester sourceCodeAt: #copyDictionary:))				from: #copyDictionary:				in: RBReadBeforeWrittenTester.	self setupMethodNameFor: refactoring toReturn: #copyWithAssociations.	self setupVariableToMoveToFor: refactoring toReturn: 'aDictionary'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Dictionary)).	class := refactoring model classNamed: #RBReadBeforeWrittenTester.	selectorsSize := class selectors size.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #copyDictionary:) = (RBParser 						parseMethod: 'copyDictionary: aDictionary ^aDictionary copyWithAssociations').	self 		assert: ((refactoring model classNamed: #Dictionary) 				parseTreeFor: #copyWithAssociations) = (RBParser 							parseMethod: 'copyWithAssociations 							| newDictionary |							newDictionary := Dictionary new: self size.							self								keysAndValuesDo: [:key :value | newDictionary at: key put: value].							^newDictionary').	self assert: class selectors size = selectorsSize! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					to: 'asdf'					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (14 to: 105)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod1))					to: 'asdf'					from: #testMethod1					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (61 to: 101)							for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))					to: 'asdf'					from: #noMoveDefinition					in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'a sdf'				from: #testMethod				in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (14 to: 23)				to: 'asdf'				from: #checkClass1:				in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryForLastStatementInBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (52 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				to: 'temp'				from: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2	^(1 to: 10) inject: 1 into: [:sum :each | | temp | temp := sum * (self foo: each). temp]')! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryInsideBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (133 to: 141)						for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))				to: 'asdf'				from: #noMoveDefinition				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #noMoveDefinition) = (RBParser 							parseMethod: 'noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | | asdf | asdf := each size. temp := asdf + temp]')! !!InlineAllMethodTest methodsFor: 'tests'!testInlineMethodWithMultipleSendersInMethod	| refactoring |	refactoring := InlineAllSendersRefactoring sendersOf: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]] ').	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #multipleCalls) = (RBParser 							parseMethod: 'multipleCalls	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)].	(1 to: 10) inject: 1 into: [:sum1 :each1 | sum1 * (self foo: each1)]')! !!InlineAllMethodTest methodsFor: 'tests'!testRecursiveMethod	| class |	model := RBNamespace new.	class := model classNamed: self class name.	class		compile: 'foo ^self foo' classified: #(#accessing);		compile: 'bar ^self foo' classified: #(#accessing).	self executeRefactoring: (InlineAllSendersRefactoring 				model: model				sendersOf: #foo				in: class).	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo ^self foo').	self assert: (class parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar ^self foo')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentIntoCascadedMessage	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 79)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			(refactoring model classNamed: #Behavior) 				compile: 'hasImmediateInstances ^self format = 0'				classified: #(#accessing).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a aBehavior |	a := 5.	aBehavior := a class.	aBehavior superclass.	aBehavior format = 0.	^aBehavior yourself')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentMethodMax	| refactoring |	self proceedThroughWarning: 			[| class |			refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (47 to: 58)								for: (RefactoryTestDataApp sourceCodeAt: #inlineMax))						inMethod: #inlineMax						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: true.			class := refactoring model classNamed: #Magnitude.			class 				compile: 'max: aMagnitude 					"Answer the receiver or the argument, whichever has the greater magnitude."					self > aMagnitude						ifTrue: [^self]						ifFalse: [^aMagnitude]'				classified: #(#accessing).			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMax) = (RBParser 							parseMethod: 'inlineMax								| x y q |								x := 5.								y := 10.								q := x + 1 > y									ifTrue: [x + 1]									ifFalse: [y].								^q')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineEmptyComponentMethod	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 91)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a anObject |	a := 5.	anObject := a class.	anObject superclass.	anObject hasImmediateInstances.	^anObject')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a a9: b b9: c'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a + b + c')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames1	| class refactoring |	model := RBNamespace new.	class := model classNamed: #Rectangle.	class 		compile: 'rectangleRelativeTo: aRectangle ^self origin extent: aRectangle extent'		classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle rectangleRelativeTo: temp'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (77 to: 112)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle origin extent: temp extent')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames2	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c a9: b b9: a'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c + b + a')! !!InlineMethodFromComponentTest methodsFor: 'failure tests'!testInlineMethodFromComponentFailure	self shouldFail: (InlineMethodFromComponentRefactoring 				inline: (self convertInterval: (50 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineFailed))				inMethod: #inlineFailed				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (13 to: 23)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (14 to: 17)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (1 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSendThatAlsoSendsSuper	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	refactoring := InlineMethodRefactoring 				inline: (102 to: 131)				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self shouldFail: refactoring! !!InlineMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (InlineMethodRefactoring 				inline: (14 to: 17)				inMethod: #checkClass1:				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testOverriden	self shouldWarn: (InlineMethodRefactoring 				inline: (self convertInterval: (15 to: 26)						for: (LintRuleTest sourceCodeAt: #failedRules))				inMethod: #failedRules				forClass: LintRuleTest)! !!InlineMethodTest methodsFor: 'failure tests'!testPrimitive	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				inMethod: #testMethod				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testReturn	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (418 to: 485)						for: (BasicLintRuleTest class sourceCodeAt: #utilityMethods))				inMethod: #utilityMethods				forClass: BasicLintRuleTest class)! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (455 to: 504)						for: (BasicLintRuleTest class 								sourceCodeAt: #sentNotImplementedInApplication))				inMethod: #sentNotImplementedInApplication				forClass: BasicLintRuleTest class.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model metaclassNamed: #BasicLintRuleTest) 				parseTreeFor: #sentNotImplementedInApplication) = (RBParser 							parseMethod: 'sentNotImplementedInApplication									| detector |									detector := self new.									detector name: ''Messages sent but not implemented in application''.									detector methodBlock: 											[:context :result | 											| message class block |											message := context messages 														detect: [:each | (context isItem: each in: context application) not]														ifNone: [nil].											class := context selectedClass.											block := 													[:each | 													| app methodApp root |													app := context application.													((class canUnderstand: each) 														ifTrue: 															[root := app rootApplication.															methodApp := ((class whichClassIncludesSelector: each) 																		compiledMethodAt: each) application 																		rootApplication.															methodApp == root or: [root isBasedOn: methodApp]]														ifFalse: [false]) not].											message isNil 												ifTrue: [message := context selfMessages detect: block ifNone: [nil]].											message isNil 												ifTrue: 													[class := class superclass.													class isNil 														ifTrue: 															[context superMessages isEmpty 																ifFalse: [message := context superMessages asArray first]]														ifFalse: [message := context superMessages detect: block ifNone: [nil]]].											message notNil 												ifTrue: 													[result addSearchString: message.													result addClass: context selectedClass selector: context selector]].									^detector')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod1	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (39 to: 84)						for: (RefactoryTestDataApp sourceCodeAt: #caller))				inMethod: #caller				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller) = (RBParser 							parseMethod: 'caller 									| anObject anObject1 | 									anObject := 5.									anObject1 := anObject + 1.									Transcript										show: anObject1 printString;										cr.									^anObject')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod2	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (40 to: 120)						for: (RefactoryTestDataApp sourceCodeAt: #caller1))				inMethod: #caller1				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller1) = (RBParser 							parseMethod: 'caller1 								| anObject each1 anObject1 | 								anObject := 5.								anObject1 := anObject + 1.								each1 := anObject1 printString.								Transcript									show: each1;									cr.								[:each | each printString. ^anObject] value: each1')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod3	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (58 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				inMethod: #caller2				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2								^(1 to: 10) inject: 1 into: [:sum :each | sum * ((1 to: 10) inject: each into: [:sum1 :each1 | sum1 + each1])]	')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod4	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (31 to: 112)						for: (RefactoryTestDataApp sourceCodeAt: #inlineJunk))				inMethod: #inlineJunk				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineJunk) = (RBParser 							parseMethod: 'inlineJunk										| asdf bar1 baz1 asdf1 |										bar1 := 												[:each | 												| temp |												temp := each.												temp , temp] value: self.										baz1 := bar1 + bar1.										asdf1 := baz1 + bar1.										asdf := asdf1.										^asdf foo: 												[:bar | 												| baz |												baz := bar.												baz * baz]')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod5	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (53 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineLast))				inMethod: #inlineLast				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')! !!InlineMethodTest methodsFor: 'tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSend	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	(model classNamed: #RenameVariableChange) removeMethod: #executeNotifying:.	refactoring := InlineMethodRefactoring 				model: model				inline: (self convertInterval: (102 to: 131)						for: ((model classNamed: #RenameInstanceVariableChange) 								sourceCodeFor: #executeNotifying:))				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self executeRefactoring: refactoring.	self 		assert: ((model classNamed: #RenameInstanceVariableChange) 				parseTreeFor: #executeNotifying:) = (RBParser 							parseMethod: 'executeNotifying: aBlock 									| undo undos undo1 |									self addNewVariable.									self copyOldValuesToNewVariable.									undos := changes collect: [:each | each executeNotifying: aBlock].									undo1 := self copy.									undo1 changes: undos reverse.									undo := undo1.									self removeOldVariable.									^undo')! !!InlineMethodTest methodsFor: 'tests'!testInlineRecursiveCascadedMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (33 to: 62)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				inMethod: #inlineMethod				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod									| temp temp1 |									self foo.									temp1 := self foo; inlineMethod; bar.									temp := self bar.									^temp')! !!InlineMethodTest methodsFor: 'tests'!testModelInlineRecursiveMethod	| refactoring class |	class := model classNamed: #Object.	class compile: 'foo self bar. self foo. self bar' classified: #(#accessing).	refactoring := InlineMethodRefactoring 				model: model				inline: (15 to: 23)				inMethod: #foo				forClass: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo self bar. self bar. self foo. self bar. self bar')! !!InlineParameterTest methodsFor: 'failure tests'!testInlineBlockFailure	self shouldFail: (InlineParameterRefactoring 				inlineParameter: 'aBlock'				in: RefactoryTestDataApp				selector: ('inline' , 'Foo:') asSymbol)! !!InlineParameterTest methodsFor: 'tests'!testInlineLiteralArray	| refactoring class |	refactoring := InlineParameterRefactoring 				inlineParameter: 'aSymbol'				in: RefactoryTestDataApp				selector: ('inline' , 'ParameterMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #inlineParameterMethod) = (RBParser 						parseMethod: 'inlineParameterMethod | aSymbol | aSymbol := #(asdf). ^aSymbol isSymbol').	self 		assert: (class parseTreeFor: #sendInlineParameterMethod) = (RBParser 						parseMethod: 'sendInlineParameterMethod ^self inlineParameterMethod').	self deny: (class 				directlyDefinesMethod: ('inline' , 'ParameterMethod:') asSymbol)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporary	| refactoring |	refactoring := InlineTemporaryRefactoring 				inline: (self convertInterval: (24 to: 72)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				from: #inlineMethod				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod										^self													foo;													inlineMethod;													bar')! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryBadInterval	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (29 to: 100)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryMutlipleAssignment	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (60 to: 83)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryReadBeforeWritten	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (48 to: 56)						for: (RefactoryTestDataApp sourceCodeAt: #inlineTemporary))				from: #inlineTemporary				in: RefactoryTestDataApp)! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoArgument	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'aSmalllintContext'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #SmalllintContext)).			self setupMethodNameFor: refactoring toReturn: #foo:.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').	self 		assert: ((refactoring model classNamed: #SmalllintContext) 				parseTreeFor: #foo:) = (RBParser 							parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self 		assert: (class metaclass parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (class metaclass parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:30'!testMoveMethodIntoClassVariable	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'RecursiveSelfRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #ParseTreeSearcher)).			self 				setupMethodNameFor: refactoring				toReturn: #foo:foo:				withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext RecursiveSelfRule foo: self foo: aSmalllintContext').	self 		assert: ((refactoring model classNamed: #ParseTreeSearcher) 				parseTreeFor: #foo:foo:) = (RBParser 							parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(transformationRule rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(self executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests' stamp: 'jws 10/23/2016 05:38'!testMoveMethodIntoInstanceVariable	| refactoring class |	self		proceedThroughWarning: [ 			refactoring := MoveMethodRefactoring selector: #checkMethod: class: TransformationRuleTest variable: 'rewriteRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #ParseTreeRewriter)).			self setupMethodNameFor: refactoring toReturn: #foo:foo: withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring ].	class := refactoring model classNamed: #TransformationRuleTest.	self		assert:			(class parseTreeFor: #checkMethod:)				= (RBParser parseMethod: 'checkMethod: aSmalllintContext rewriteRule foo: self foo: aSmalllintContext').	self		assert:			((refactoring model classNamed: #ParseTreeRewriter) parseTreeFor: #foo:foo:)				=					(RBParser						parseMethod:							'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(self executeTree: aSmalllintContext parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: self tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: self tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) = (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) = (RBParser parseMethod: 'class: anObject class := anObject').	self		assert:			(class metaclass parseTreeFor: #recursiveSelfRule:)				= (RBParser parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self		assert:			(class metaclass parseTreeFor: #recursiveSelfRule) = (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) = (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) = (RBParser parseMethod: 'builder: anObject builder := anObject')! !!MoveMethodTest methodsFor: 'tests' stamp: 'bh 5/1/2000 00:09'!testMoveMethodThatReferencesPoolDictionary	| refactoring class |	self		proceedThroughWarning: 			[refactoring := MoveMethodRefactoring						selector: #junk						class: LintRuleTest						variable: 'RefactoryTestDataApp'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: 'RefactoryTestDataApp class' asSymbol)).			self setupMethodNameFor: refactoring toReturn: #junk1.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self assert: (class parseTreeFor: #junk)			= (RBParser parseMethod: 'junk ^RefactoryTestDataApp junk1').	self assert: ((refactoring model metaclassNamed: #RefactoryTestDataApp)			parseTreeFor: #junk1)			= (RBParser parseMethod: 'junk1	^self printString copyFrom: 1 to: CR').	self assert: (class directlyDefinesPoolDictionary: 'TextConstants' asSymbol)! !!MoveMethodTest methodsFor: 'failure tests'!testMovePrimitiveMethod	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := MoveMethodRefactoring 				model: model				selector: #foo				class: Object				variable: 'OrderedCollection'.	self shouldFail: refactoring! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinition	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (19 to: 22)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #moveDefinition.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #moveDefinition) = (RBParser 							parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (48 to: 58)						for: (RefactoryTestDataApp sourceCodeAt: #referencesConditionFor:))				in: RefactoryTestDataApp				selector: #referencesConditionFor:.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #referencesConditionFor:) = (RBParser 							parseMethod: 'referencesConditionFor: aClass 								| environment  |								^(RBCondition withBlock: 										[| association |association := Smalltalk associationAt: aClass name													ifAbsent: [self refactoringError: ''Could not find class''].										environment := (self environment referencesTo: association) 													| (self environment referencesTo: aClass name).										environment isEmpty])									errorMacro: aClass , '' is referenced.<n>Browse references?'';									errorBlock: [environment openEditor];									yourself')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNoMoveDefinition	self shouldFail: (MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (21 to: 24)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #noMoveDefinition)! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNonExistantName	self		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (1 to: 10)					in: LintRuleTest					selector: #name1);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (44 to: 54)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (16 to: 25)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName)! !!ProtectInstanceVariableTest methodsFor: 'tests'!testProtectInstanceVariable	| refactoring class |	refactoring := ProtectInstanceVariableRefactoring 				variable: 'rewrite' , 'Rule1'				class: SubclassOfClassToRename.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #SubclassOfClassToRename.	self 		assert: (class parseTreeFor: #calls1) = (RBParser 						parseMethod: 'calls1								^rewriteRule1 := (rewriteRule1 := self calls)').	self 		assert: (class parseTreeFor: #calls) = (RBParser 						parseMethod: 'calls								^rewriteRule1 := rewriteRule1 , rewriteRule1').	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)! !!ProtectInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 4/29/2000 21:33'!testVariableNotDefined	| refactoring |	refactoring := ProtectInstanceVariableRefactoring variable: 'rewrite' class: SubclassOfClassToRename.	self shouldFail: refactoring.! !!PullUpClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest class)! !!PullUpClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PullUpClassVariableRefactoring variable: #Foo				class: LintRuleTest)! !!PullUpClassVariableTest methodsFor: 'tests'!testPullUpClassVariable	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule).	self deny: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule)! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelNonExistantName	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownToMultipleSubclassesFailure	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariable	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariableToClassDownTwoLevels	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model metaclassNamed: #AnotherSubclass.	class compile: 'bar ^Foo' classified: #(#accessing).	class := class nonMetaclass.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass superclass).	self 		deny: (class superclass superclass directlyDefinesClassVariable: #Foo).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownVariableToMultipleClassesInSameHierarchy	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	self 		assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests'!testPushDownClassVariable	| refactoring |	refactoring := PushDownClassVariableRefactoring variable: #Foo1				class: LintRuleTest.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #Foo1).	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesClassVariable: #Foo1)]! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMetaclass	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #Subclass) compile: 'foo ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model metaclassNamed: #SomeClass)).	self 		deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMultipleSubclasses	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #AnotherSubclass) compile: 'bar ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').	self assert: ((model classNamed: #AnotherSubclass) 				directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests'!testPushDownInstanceVariable	| refactoring |	refactoring := PushDownInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesInstanceVariable: 'foo1')]! !!PushDownInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!PushDownMethodTest methodsFor: 'tests'!testPushDownMethod	| refactoring class |	refactoring := PushDownMethodRefactoring pushDown: #(#name:)				from: LintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #name:).	class subclasses do: 			[:each | 			self assert: (each parseTreeFor: #name:) 						= (RBParser parseMethod: 'name: aString name := aString')]! !!PushDownMethodTest methodsFor: 'tests' stamp: 'bh 3/17/2000 13:33'!testPushDownMethodThatReferencesPoolDictionary	| refactoring class parseTree |	parseTree := LintRuleTest parseTreeFor: #junk.	self		proceedThroughWarning: 			[refactoring := PushDownMethodRefactoring pushDown: #(junk ) from: LintRuleTest.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #junk).	class subclasses do: 		[:each | 		self assert: (each parseTreeFor: #junk)				= parseTree.		self assert: (each directlyDefinesPoolDictionary: 'TextConstants' asSymbol)]! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownMethodOnNonAbstractClass	| refactoring |	refactoring := PushDownMethodRefactoring pushDown: #(#yourself)				from: Object.	self shouldFail: refactoring! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownNonExistantMenu	| refactoring |	refactoring := PushDownMethodRefactoring 				pushDown: #(#someMethodThatDoesNotExist)				from: LintRuleTest.	self shouldFail: refactoring! !!PushUpInstanceVariableTest methodsFor: 'tests'!testPullUpInstVar	| refactoring |	self proceedThroughWarning: 			[refactoring := PullUpInstanceVariableRefactoring variable: 'result'						class: LintRuleTest.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesInstanceVariable: 'result').	self deny: ((refactoring model classNamed: #BasicLintRuleTest) 				directlyDefinesInstanceVariable: 'result')! !!PushUpInstanceVariableTest methodsFor: 'failure tests'!testPullUpVariableNotDefined	self shouldFail: (PullUpInstanceVariableRefactoring 				variable: 'notDefinedVariable'				class: LintRuleTest)! !!PushUpMethodTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:11'!testPushUpAndCopyDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self executeRefactoring: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class).	self assert: (class superclass parseTreeFor: #yourself) 				= (RBParser parseMethod: 'yourself ^1').	self deny: (class directlyDefinesMethod: #yourself).	class := model classNamed: #Foo2.	self assert: (class directlyDefinesMethod: #yourself).	self assert: (class parseTreeFor: #yourself) 				= ((model classNamed: #Object) parseTreeFor: #yourself)! !!PushUpMethodTest methodsFor: 'tests'!testPushUpMethodWithCopyOverriddenMethodsDown	| refactoring |	self proceedThroughWarning: 			[refactoring := PushUpMethodRefactoring pushUp: #(#isComposite)						from: CompositeLintRuleTest.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^true').	self deny: ((refactoring model classNamed: #CompositeLintRuleTest) 				directlyDefinesMethod: #isComposite)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpClassMethod	| class |	class := model classNamed: #Object.	class addClassVariable: #Foo.	class metaclass compile: 'foo ^Foo' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class metaclass)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpReferencesInstVar	self shouldFail: (PushUpMethodRefactoring pushUp: #(#checkClass:)				from: BasicLintRuleTest)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithInvalidSuperSend	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Foo2) compile: 'yourself ^super yourself + 1'		classified: #(#accessing).	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithMethodThatCannotBePushedDown	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #SomeClass) compile: 'yourself ^54'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: (model classNamed: #SomeClass))! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithSuperSendThatCannotBeCopiedDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Object) compile: 'foo ^3' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^super foo'		classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(class := model classNamed: #Foo2) compile: 'foo ^1'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class)! !!RefactoringWarning methodsFor: 'private - actions'!defaultAction	"Proceed through warnings"	^nil! !!RefactoringWarning methodsFor: 'description' stamp: 'dvf 11/12/2002 00:47'!isResumable	^true.! !!RefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'accessing'!changes	^Array with: self! !!RefactoryChange methodsFor: 'accessing'!changesSize	^1! !!RefactoryChange methodsFor: 'accessing'!name	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	"We're in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility! !!RefactoryChange methodsFor: 'printing'!changeString	^self class name! !!RefactoryChange methodsFor: 'printing'!displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'copying' stamp: 'bh 3/16/2000 23:27'!copy	^(super copy)		postCopy;		yourself! !!RefactoryChange methodsFor: 'copying' stamp: 'dvf 9/21/2003 16:35'!postCopy	^self! !!RefactoryChange methodsFor: 'performing-changes'!execute	^self executeNotifying: []! !!RefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	self subclassResponsibility! !!RefactoryChange methodsFor: 'private' stamp: 'dvf 9/21/2003 16:35'!flattenOnto: aCollection 	aCollection add: self! !!RefactoryChange methodsFor: 'private'!flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes! !!RefactoryChange methodsFor: 'initialize-release'!initialize! !!RefactoryChange methodsFor: 'initialize-release'!name: aString	name := aString! !!RefactoryChange methodsFor: 'user interface' stamp: 'bh 5/8/2000 21:13'!inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect! !!CompositeRefactoryChange methodsFor: 'comparing'!= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true! !!CompositeRefactoryChange methodsFor: 'comparing'!hash	^changes size! !!CompositeRefactoryChange methodsFor: 'accessing'!addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'accessing'!addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'accessing'!changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]! !!CompositeRefactoryChange methodsFor: 'accessing'!problemCount	^self changesSize! !!CompositeRefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!defineClass: aString 	^self addChange: (AddClassChange definition: aString)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass name)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassNamed: aSymbol 	self addChange: (RemoveClassChange removeClassName: aSymbol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes	^changes! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes: aCollection 	changes := aCollection! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!removeChange: aChange 	changes remove: aChange ifAbsent: []! !!CompositeRefactoryChange methodsFor: 'printing'!displayString	^super displayString asText allBold! !!CompositeRefactoryChange methodsFor: 'printing' stamp: 'dvf 9/16/2001 00:56'!printOn: aStream 	name ifNotNil: [aStream nextPutAll: name] ifNil: [aStream nextPutAll: 'a CompositeRefactoringChange']! !!CompositeRefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo! !!CompositeRefactoryChange methodsFor: 'private'!flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]! !!CompositeRefactoryChange methodsFor: 'initialize-release'!initialize	super initialize.	changes := OrderedCollection new! !!CompositeRefactoryChange methodsFor: 'user interface' stamp: 'bh 11/8/2000 13:45'!inspect	"CompositeRefactoryChangeInspector openOn: self"	self needsWork.	^super inspect.! !!CompositeRefactoryChange methodsFor: 'copying'!postCopy	super postCopy.	changes := changes collect: [:each | each copy]! !!CompositeRefactoryChange class methodsFor: 'instance creation'!named: aString 	^(self new)		name: aString;		yourself! !!RefactoryChangeManager methodsFor: 'public access'!addUndo: aRefactoringChange 	undo addLast: aRefactoringChange.	undo size > UndoSize ifTrue: [undo removeFirst].	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'public access'!ignoreChangesWhile: aBlock 	isPerformingRefactoring ifTrue: [^aBlock value].	isPerformingRefactoring := true.	aBlock ensure: [isPerformingRefactoring := false]! !!RefactoryChangeManager methodsFor: 'public access'!performChange: aRefactoringChange 	self ignoreChangesWhile: [self addUndo: aRefactoringChange execute]! !!RefactoryChangeManager methodsFor: 'public access'!redoChange	^redo last! !!RefactoryChangeManager methodsFor: 'public access'!redoOperation	redo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := redo removeLast.			undo add: change execute]! !!RefactoryChangeManager methodsFor: 'public access'!undoChange	^undo last! !!RefactoryChangeManager methodsFor: 'public access'!undoOperation	undo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := undo removeLast.			redo add: change execute]! !!RefactoryChangeManager methodsFor: 'private'!clearUndoRedoList	undo := OrderedCollection new.	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'initialize-release'!connectToChanges	ChangeSet addDependent: self! !!RefactoryChangeManager methodsFor: 'initialize-release'!disconnectFromChanges	ChangeSet removeDependent: self! !!RefactoryChangeManager methodsFor: 'initialize-release'!initialize	undo := OrderedCollection new.	redo := OrderedCollection new.	isPerformingRefactoring := false.	self connectToChanges! !!RefactoryChangeManager methodsFor: 'initialize-release'!release	super release.	self disconnectFromChanges! !!RefactoryChangeManager methodsFor: 'testing'!hasRedoableOperations	^redo isEmpty not! !!RefactoryChangeManager methodsFor: 'testing'!hasUndoableOperations	^undo isEmpty not! !!RefactoryChangeManager methodsFor: 'updating'!update: anAspectSymbol with: aParameter from: aSender 	| changeType |	(aSender == ChangeSet and: [isPerformingRefactoring not]) ifFalse: [^self].	anAspectSymbol == #reorganizeClass: ifTrue: [^self].	changeType := (anAspectSymbol isString 				ifTrue: [anAspectSymbol asString]				ifFalse: ['class']) asLowercase.	(changeType indexOfSubCollection: 'class' startingAt: 1) 		+ (changeType indexOfSubCollection: 'selector' startingAt: 1) > 0 		ifTrue: [self clearUndoRedoList]! !!RefactoryChangeManager class methodsFor: 'class initialization'!initialize	self nuke.	UndoSize := 5! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize	^UndoSize! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize: anInteger 	UndoSize := anInteger max: 0! !!RefactoryChangeManager class methodsFor: 'instance creation'!instance	Instance isNil 		ifTrue: 			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoryChangeManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoryChangeManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoryClassChange methodsFor: 'comparing'!= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]! !!RefactoryClassChange methodsFor: 'comparing'!hash	^self changeClassName hash! !!RefactoryClassChange methodsFor: 'converting'!asUndoOperation	^self subclassResponsibility! !!RefactoryClassChange methodsFor: 'accessing'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]! !!RefactoryClassChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName	^className! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RefactoryClassChange methodsFor: 'accessing'!methodSourceFor: aSymbol 	(self changeClass includesSelector: aSymbol) ifFalse: [^nil].	^self changeClass sourceCodeAt: aSymbol! !!RefactoryClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	self changeClassName == aClassName 		ifTrue: 			[^(self copy)				changeClassName: newClassName;				yourself].	^self! !!RefactoryClassChange methodsFor: 'printing'!changeString	^self displayClassName! !!RefactoryClassChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RefactoryClassChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RefactoryClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	undo := self asUndoOperation.	undo name: self name.	self primitiveExecute.	aBlock value.	^undo! !!RefactoryClassChange methodsFor: 'private'!isMeta	^isMeta! !!RefactoryClassChange methodsFor: 'private'!primitiveExecute	^self subclassResponsibility! !!AddClassChange methodsFor: 'comparing'!= anAddClassChange 	self class = anAddClassChange class ifFalse: [^false].	^definition = anAddClassChange definition! !!AddClassChange methodsFor: 'comparing'!hash	^definition hash! !!AddClassChange methodsFor: 'converting'!asUndoOperation	| class |	class := Smalltalk at: self changeClassName ifAbsent: [nil].	^class isBehavior 		ifTrue: [AddClassChange definition: class definition]		ifFalse: [RemoveClassChange removeClassName: self changeClassName]! !!AddClassChange methodsFor: 'accessing'!category	category isNil ifTrue: [self fillOutDefinition].	^category! !!AddClassChange methodsFor: 'accessing'!changeClassName	className isNil ifTrue: [self fillOutDefinition].	^className! !!AddClassChange methodsFor: 'accessing'!classVariableNames	classVariableNames isNil ifTrue: [self fillOutDefinition].	^classVariableNames! !!AddClassChange methodsFor: 'accessing'!instanceVariableNames	instanceVariableNames isNil ifTrue: [self fillOutDefinition].	^instanceVariableNames! !!AddClassChange methodsFor: 'accessing'!poolDictionaryNames	poolDictionaryNames isNil ifTrue: [self fillOutDefinition].	^poolDictionaryNames! !!AddClassChange methodsFor: 'accessing'!superclassName	className isNil ifTrue: [self fillOutDefinition].	^superclassName! !!AddClassChange methodsFor: 'printing'!changeString	^'Define ' , self displayClassName! !!AddClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: definition;		nextPut: $!!! !!AddClassChange methodsFor: 'private'!controller	^nil! !!AddClassChange methodsFor: 'private'!definingSuperclass	^self class! !!AddClassChange methodsFor: 'private'!definition	^definition! !!AddClassChange methodsFor: 'private' stamp: 'jws 10/30/2016 22:57'!fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidSubclassCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	superclassName := parseTree receiver isVariable 				ifTrue: [parseTree receiver name asSymbol]				ifFalse: [parseTree receiver value].	className := parseTree arguments first value.	instanceVariableNames := self namesIn: (parseTree arguments at: 2) value.	classVariableNames := self namesIn: (parseTree arguments at: 3) value.	poolDictionaryNames := self namesIn: (parseTree arguments at: 4) value.	category := parseTree arguments size < 5 				ifTrue: [#Unknown]				ifFalse: [(parseTree arguments at: 5) value asSymbol]! !!AddClassChange methodsFor: 'private'!namesIn: aString 	| names stream nameStream |	names := OrderedCollection new.	stream := ReadStream on: aString.		[stream skipSeparators.	stream atEnd] whileFalse: 				[nameStream := WriteStream on: (String new: 10).				[stream atEnd or: [stream peek isSeparator]] 					whileFalse: [nameStream nextPut: stream next].				names add: nameStream contents].	^names! !!AddClassChange methodsFor: 'private'!parseDefinitionError	className := #'Unknown Class'.	instanceVariableNames := #().	classVariableNames := #().	poolDictionaryNames := #()! !!AddClassChange methodsFor: 'private'!primitiveExecute	^self definingSuperclass subclassDefinerClass 		evaluate: definition		notifying: self controller		logged: true! !!AddClassChange methodsFor: 'initialize-release'!definition: aString 	definition := aString! !!AddClassChange methodsFor: 'initialize-release'!initialize	super initialize.	isMeta := false! !!AddClassChange methodsFor: 'testing' stamp: 'bh 11/8/2000 12:29'!isValidMessageName: aMessageNode 	^#("#subclass:instanceVariableNames:classVariableNames:poolDictionaries:" #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableByteSubclass:classVariableNames:poolDictionaries:" #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:" #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:) 		includes: aMessageNode selector! !!AddClassChange methodsFor: 'testing'!isValidSubclassCreationMessage: aMessageNode 	(aMessageNode receiver isVariable or: [aMessageNode receiver isLiteral]) 		ifFalse: [^false].	(self isValidMessageName: aMessageNode) ifFalse: [^false].	^(aMessageNode arguments detect: [:each | each isLiteral not] ifNone: [nil]) 		isNil! !!AddClassChange class methodsFor: 'instance creation' stamp: 'bh 11/8/2000 13:51'!definition: aString 	^self new definition: aString! !!AddMethodChange methodsFor: 'comparing'!= anAddMethodChange 	super = anAddMethodChange ifFalse: [^false].	^self parseTree = anAddMethodChange parseTree! !!AddMethodChange methodsFor: 'comparing'!hash	^self parseTree hash! !!AddMethodChange methodsFor: 'converting'!asUndoOperation	^(self changeClass includesSelector: self selector) 		ifTrue: 			[| oldProtocol |			oldProtocol := BrowserEnvironment new whichProtocolIncludes: self selector						in: self changeClass.			oldProtocol isNil ifTrue: [oldProtocol := #accessing].			AddMethodChange 				compile: (self methodSourceFor: self selector)				in: self changeClass				classified: oldProtocol]		ifFalse: [RemoveMethodChange remove: selector from: self changeClass]! !!AddMethodChange methodsFor: 'accessing'!changeForClass: aSymbol selector: aSelector 	^(isMeta not and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^(isMeta and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'accessing'!protocol	^self protocols first! !!AddMethodChange methodsFor: 'accessing'!protocols	^protocols! !!AddMethodChange methodsFor: 'accessing'!selector	selector isNil 		ifTrue: 			[selector := RBParser parseMethodPattern: source.			selector isNil ifTrue: [selector := #unknown]].	^selector! !!AddMethodChange methodsFor: 'printing'!changeString	^self displayClassName , '>>' , self selector! !!AddMethodChange methodsFor: 'printing' stamp: 'nk 3/5/2005 15:51'!printOn: aStream 	aStream		nextPut: $!!;		nextPutAll: self displayClassName;		nextPutAll: ' methodsFor: ''';		nextPutAll: self protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass protocol: aProtocol source: aString 	self changeClass: aClass.	self protocols: aProtocol.	source := aString! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass source: aString 	self changeClass: aClass.	source := aString.	self protocols: (BrowserEnvironment new whichProtocolIncludes: self selector in: aClass)! !!AddMethodChange methodsFor: 'initialize-release'!protocols: aCollection 	protocols := aCollection isString 				ifTrue: [Array with: aCollection]				ifFalse: [aCollection].	protocols isNil ifTrue: [protocols := #(#accessing)]! !!AddMethodChange methodsFor: 'private'!controller	^nil! !!AddMethodChange methodsFor: 'private'!parseTree	^RBParser parseMethod: source onError: [:str :pos | ^nil]! !!AddMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass 		compile: source		classified: self protocol		notifying: self controller! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass 	^self new class: aClass source: aString! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol 	^self new 		class: aBehavior		protocol: aProtocol		source: aString! !!InteractiveAddClassChange methodsFor: 'private'!controller	^controller! !!InteractiveAddClassChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddClassChange methodsFor: 'private'!primitiveExecute	definedClass := super primitiveExecute! !!InteractiveAddClassChange methodsFor: 'accessing'!definedClass	^definedClass! !!InteractiveAddClassChange class methodsFor: 'instance creation'!definition: aString for: aController 	^(self definition: aString)		controller: aController;		yourself! !!InteractiveAddMethodChange methodsFor: 'private'!controller	^controller! !!InteractiveAddMethodChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddMethodChange methodsFor: 'private'!primitiveExecute	^definedSelector := super primitiveExecute! !!InteractiveAddMethodChange methodsFor: 'accessing'!definedSelector	^definedSelector! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol for: aController 	^(self 		compile: aString		in: aBehavior		classified: aProtocol)		controller: aController;		yourself! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass for: aController 	^(self compile: aString in: aClass)		controller: aController;		yourself! !!RefactoryTestDataApp methodsFor: 'lint'!asOrderedCollectionNotNeeded	self foo addAll: (1 to: 10) asOrderedCollection! !!RefactoryTestDataApp methodsFor: 'lint'!assignmentInBlock	[^self printString] ensure: [self close]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!assignmentInIfTrue	| variable |	self isVariable 		ifTrue: [variable := self]		ifFalse: [variable := self printString].	^variable! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'md 3/14/2006 16:47'!atIfAbsent	^ Smalltalk at: #MyTest		ifAbsent: 			[| collection |			collection := #().			Smalltalk at: #MyTest put: collection]! !!RefactoryTestDataApp methodsFor: 'lint'!badMessage	self become: String new! !!RefactoryTestDataApp methodsFor: 'lint'!booleanPrecedence	^true & 4 = 45! !!RefactoryTestDataApp methodsFor: 'lint'!collectSelectNotUsed	(1 to: 10) select: [:each | each = 4]! !!RefactoryTestDataApp methodsFor: 'lint'!collectionMessagesToExternalObject	self someObject collection remove: 10! !!RefactoryTestDataApp methodsFor: 'lint'!collectionProtocol	| newCollection |	newCollection := OrderedCollection new.	(1 to: 10) asOrderedCollection do: 			[:each | 			| new |			new := each * 2.			newCollection add: new].	^newCollection! !!RefactoryTestDataApp methodsFor: 'lint'!consistencyCheck	^(1 to: 10) at: 1! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!contains	^((1 to: 10) detect: [:each | each > 2] ifNone: [nil]) isNil! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 16:49'!cruft	self halt! !!RefactoryTestDataApp methodsFor: 'lint'!detectContains	^(1 to: 10) do: [:each | each > 2 ifTrue: [^each]]! !!RefactoryTestDataApp methodsFor: 'lint'!endTrueFalse	self isVariable 		ifTrue: 			[self printString.			self isVariable printString]		ifFalse: 			[self printString.			^4]! !!RefactoryTestDataApp methodsFor: 'lint'!equalNotUsed	| string |	string = '' yourself.	(1 to: 10) do: [:i | string := i printString].	^string! !!RefactoryTestDataApp methodsFor: 'lint'!equalsTrue	^true == self! !!RefactoryTestDataApp methodsFor: 'lint'!extraBlock	^[:arg | arg + 43] value: 45! !!RefactoryTestDataApp methodsFor: 'lint'!fileBlocks	| file |	^	[file := 'asdf' asFilename readStream.	file contents] ensure: [file close]! !!RefactoryTestDataApp methodsFor: 'lint'!fullBlocks	^[thisContext]! !!RefactoryTestDataApp methodsFor: 'lint'!guardingClause	self isSymbol 		ifFalse: 			[self printString.			self isSymbol printString]! !!RefactoryTestDataApp methodsFor: 'lint'!ifTrueReturns	self isSymbol ifFalse: [^true].	^false! !!RefactoryTestDataApp methodsFor: 'lint'!isLiteral	^false! !!RefactoryTestDataApp methodsFor: 'lint'!justSendsSuper	super justSendsSuper! !!RefactoryTestDataApp methodsFor: 'lint'!literalArrayCharacters	^#($a $b $c) includes: $a! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 14:52'!literalArrayWithTrueFalseOrNil	| a b c |	a := #(true false nil).	b := #(#true #false #nil).	c := {true. false. nil}.	^{a. b. c}! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 16:40'!literalArrayWithTrueFalseOrNil2	| b c |	b := #(#true #false #nil).	c := #(#true (#true #false #nil) #false #nil).^b! !!RefactoryTestDataApp methodsFor: 'lint'!longMethods	self printString.	self printString.	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!minMax	"Bug in 3<5 ifTrue: [3]  ifFalse: [5]"^3<5 ifTrue: [3]  ifFalse: [5]"	| var |	var := 4.	var < 5 ifTrue: [var := 5].	^var"! !!RefactoryTestDataApp methodsFor: 'lint'!missingYourself	^(OrderedCollection new)		add: 1;		add: 2;		removeFirst! !!RefactoryTestDataApp methodsFor: 'lint'!modifiesCollection	| collection |	collection := (1 to: 10) asOrderedCollection.	collection do: [:each | each > 5 ifTrue: [collection remove: each]].	^collection! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 14:51'!noIsNil: arg	^arg = nil or: [ arg ~= nil ]! !!RefactoryTestDataApp methodsFor: 'lint'!precedence	^self isArray ifFalse: [self block + 5 * 34] ifTrue: [self printString = 10]! !!RefactoryTestDataApp methodsFor: 'lint'!refersToClass	^RefactoryTestDataApp! !!RefactoryTestDataApp methodsFor: 'lint'!release	self printString! !!RefactoryTestDataApp methodsFor: 'lint'!returnInEnsure	[self error: 'asdf'] ensure: [^4]! !!RefactoryTestDataApp methodsFor: 'lint'!returnsBooleanAndOther	self isVariable ifTrue: [^false].	self printString! !!RefactoryTestDataApp methodsFor: 'lint'!returnsIfTrue	^self isNil ifTrue: [4]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'bh 4/2/2000 22:25'!searchingLiteral	^self printString = #a or: [#() = self printString | ( #() == self printString)]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!sendsDifferentSuper	super printString! !!RefactoryTestDataApp methodsFor: 'lint'!sizeCheck	self isEmpty		ifFalse: [self do: 					[:each | 					Transcript						show: each;						cr]]! !!RefactoryTestDataApp methodsFor: 'lint'!stringConcatenation	| string |	string := '' yourself.	(1 to: 10) do: [:i | string := string , i printString].	^string! !!RefactoryTestDataApp methodsFor: 'lint'!tempVarOverridesInstVar	| temporaryVariable |	temporaryVariable := 4.	^temporaryVariable! !!RefactoryTestDataApp methodsFor: 'lint'!tempsReadBeforeWritten	| temp |	self isVariable ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'lint'!threeElementPoint	^5 @ 5 + 6 @ 6! !!RefactoryTestDataApp methodsFor: 'lint'!toDo	1 to: self size do: [:i | (self at: i) printString]! !!RefactoryTestDataApp methodsFor: 'lint'!toDoCollect	| array |	array := Array new: 10.	1 to: 10 do: [:i | array at: i put: i * i].	^array! !!RefactoryTestDataApp methodsFor: 'lint'!toDoWithIncrement	| counter |	counter := 0.	1 to: 10		by: 2		do: [:i | counter := counter + 2].	^counter! !!RefactoryTestDataApp methodsFor: 'lint'!usesAdd	^(1 to: 10) asOrderedCollection addAll: (11 to: 20)! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 2/25/2005 16:50'!variableAssignedLiteral	temporaryVariable := #() ! !!RefactoryTestDataApp methodsFor: 'lint'!whileTrue	| i |	i := 1.	[i < self size] whileTrue: 			[(self at: i) printString.			i := i + 1]! !!RefactoryTestDataApp methodsFor: 'lint'!yourselfNotUsed	self		printString;		printString;		yourself! !!RefactoryTestDataApp methodsFor: 'test'!callFoo	^self testFoo: 5! !!RefactoryTestDataApp methodsFor: 'test'!callMethod	^self renameThisMethod: 5! !!RefactoryTestDataApp methodsFor: 'test'!exampleCall	^self rename: 1 two: 2! !!RefactoryTestDataApp methodsFor: 'test'!inlineFoo: aBlock 	| bar baz asdf |	bar := aBlock value: self.	baz := bar + bar.	asdf := baz + bar.	^asdf! !!RefactoryTestDataApp methodsFor: 'test'!inlineJunk	| asdf |	asdf := self inlineFoo: 					[:each | 					| temp |					temp := each.					temp , temp].	^asdf foo: 			[:bar | 			| baz |			baz := bar.			baz * baz]! !!RefactoryTestDataApp methodsFor: 'test'!inlineMethod	| temp |	temp := self				foo;				inlineMethod;				bar.	^temp! !!RefactoryTestDataApp methodsFor: 'test'!inlineParameterMethod: aSymbol	^aSymbol isSymbol! !!RefactoryTestDataApp methodsFor: 'test'!moveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: 			[:each | 			temp := each size.			temp odd]! !!RefactoryTestDataApp methodsFor: 'test'!noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | temp := each size + temp]! !!RefactoryTestDataApp methodsFor: 'test'!rename: this two: argumentMethod	^self printString , this , argumentMethod! !!RefactoryTestDataApp methodsFor: 'test'!renameThisMethod: anArg	^self! !!RefactoryTestDataApp methodsFor: 'test'!selectorNotReferenced	^self selectorNotReferenced + 4! !!RefactoryTestDataApp methodsFor: 'test'!sendInlineParameterMethod	^self inlineParameterMethod: #(#asdf)! !!RefactoryTestDataApp methodsFor: 'test'!symbolReference	^#(#renameThisMethod: #(4 #renameThisMethod:))! !!RefactoryTestDataApp methodsFor: 'test'!testFoo: anObject	^self class + anObject! !!RefactoryTestDataApp methodsFor: 'test'!testMethod	^self class! !!RefactoryTestDataApp methodsFor: 'test'!testMethod1	^self testMethod1 		, ([:each | each testMethod1] value: #(#(#testMethod1) 2 #testMethod1))! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on1: aBlock 	| each |	each := anObject printString.	Transcript		show: each;		cr.	aBlock value: each! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on: aBlock 	Transcript		show: anObject printString;		cr.	aBlock value! !!RefactoryTestDataApp methodsFor: 'inline'!caller	| anObject |	anObject := 5.	self 		called: anObject + 1		on: [^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller1	| anObject |	anObject := 5.	self called: anObject + 1		on1: 			[:each | 			each printString.			^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller2	^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]! !!RefactoryTestDataApp methodsFor: 'inline'!foo: aValue	^(1 to: 10) inject: aValue into: [:sum :each | sum + each]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineComponent	| a |	a := 5.	^a class		superclass;		hasImmediateInstances;		yourself! !!RefactoryTestDataApp methodsFor: 'inline'!inlineFailed	| x y q |	x := 5.	y := 10.	q := x + 1 fooMax: y.	^q! !!RefactoryTestDataApp methodsFor: 'inline'!inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^self caller2]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineMax	| x y q |	x := 5.	y := 10.	q := x + 1 max: y.	^q! !!RefactoryTestDataApp methodsFor: 'inline'!inlineTemporary	| temp |	self isNil ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'inline'!multipleCalls	self caller2.	self caller2! !!RefactoryTestDataApp methodsFor: 'accessing'!referencesConditionFor: aClass 	| environment association |	^(RBCondition withBlock: 			[association := Smalltalk associationAt: aClass name						ifAbsent: [self refactoringError: 'Could not find class'].			environment := (self environment referencesTo: association) 						| (self environment referencesTo: aClass name).			environment isEmpty])		errorMacro: aClass , ' is referenced.<n>Browse references?';		errorBlock: [environment openEditor];		yourself! !!RefactoryTyper methodsFor: 'printing'!collectionNameFor: aString 	^'-<1s>-' expandMacrosWith: aString! !!RefactoryTyper methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: class name;		cr.	class instanceVariableNames do: 			[:each | 			aStream				tab;				nextPutAll: each;				tab;				nextPut: $<.			self printTypeFor: each on: aStream.			aStream				nextPut: $>;				cr]! !!RefactoryTyper methodsFor: 'printing'!printType: aClass for: aString on: aStream 	| name colTypes |	colTypes := #().	name := self collectionNameFor: aString.	(aClass includesClass: (model classFor: Collection))		ifTrue: [colTypes := self guessTypesFor: name].	colTypes isEmpty ifFalse: [aStream nextPut: $(].	aClass printOn: aStream.	colTypes isEmpty		ifFalse: 			[aStream nextPutAll: ' of: '.			colTypes size > 1 ifTrue: [aStream nextPut: $(].			self printTypeFor: name on: aStream.			colTypes size > 1 ifTrue: [aStream nextPut: $)]].	colTypes isEmpty ifFalse: [aStream nextPut: $)]! !!RefactoryTyper methodsFor: 'printing'!printTypeFor: aString on: aStream 	| types |	types := (self guessTypesFor: aString) 				asSortedCollection: [:a :b | a name < b name].	1 to: types size		do: 			[:i | 			i == 1 ifFalse: [aStream nextPutAll: ' | '].			self 				printType: (types at: i)				for: aString				on: aStream]! !!RefactoryTyper methodsFor: 'equivalence classes' stamp: 'jws 10/23/2016 05:39'!computeEquivalenceClassesForMethodsAndVars	| searcher |	bindings := Set new.	backpointers := Dictionary new.	class instanceVariableNames do: [ :each | backpointers at: each put: (bindings add: (Set with: each)) ].	class withAllSubclasses		do: [ :sub | sub selectors do: [ :each | backpointers at: each put: (bindings add: (Set with: each)) ] ].	searcher := ParseTreeSearcher new.	searcher matches: '^``@object' do: [ :aNode :answer | self processNode: aNode value ].	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'equivalence classes' stamp: 'rr 3/15/2004 14:06'!merge: aName 	"rr 3/15/2004 14:05 add: the ifAbsent: keyword in the last line, as I encountered a failing case"	| set1 set2 |	set1 := backpointers at: methodName ifAbsent: [nil].	set2 := backpointers at: aName ifAbsent: [nil].	(set1 isNil or: [set2 isNil or: [set1 == set2]]) ifTrue: [^self].	set1 addAll: set2.	set2 do: [:each | backpointers at: each put: set1].	bindings remove: set2 ifAbsent: [] ! !!RefactoryTyper methodsFor: 'equivalence classes'!processNode: aNode 	(aNode isVariable and: [class instanceVariableNames includes: aNode name]) 		ifTrue: [^self merge: aNode name].	(aNode isMessage 		and: [aNode receiver isVariable and: [aNode receiver name = 'self']]) 			ifTrue: [^self merge: aNode selector].	aNode isAssignment 		ifTrue: 			[self				processNode: aNode value;				processNode: aNode variable].	(aNode isMessage and: 			[#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 				includes: aNode selector]) 		ifTrue: 			[aNode arguments do: 					[:each | 					each isBlock 						ifTrue: 							[each body statements isEmpty 								ifFalse: [self processNode: each body statements last]]]]! !!RefactoryTyper methodsFor: 'selectors' stamp: 'jws 10/23/2016 05:39'!computeMessagesSentToVariables	| searcher |	variableMessages := Dictionary new.	class instanceVariableNames do: [ :each | variableMessages at: each put: Set new ].	searcher := ParseTreeSearcher new.	class instanceVariableNames		do: [ :each | 			| block |			block := [ :aNode :answer | 			(variableMessages at: each ifAbsentPut: [ Set new ]) add: aNode selector.			self processCollectionMessagesFor: each in: aNode ].			searcher matches: each , ' `@messageName: ``@args' do: block.			(backpointers at: each)				do: [ :sel | 					sel isSymbol						ifTrue: [ 							searcher								matches:									('(self <1s>) `@messageName: ``@args' expandMacrosWith: (ParseTreeSearcher buildSelectorString: sel)) asString								do: block ] ] ].	searcher answer: variableMessages.	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'computing types'!computeTypes	variableMessages		keysAndValuesDo: [:key :value | variableTypes at: key put: (self findTypeFor: value)]! !!RefactoryTyper methodsFor: 'computing types'!findTypeFor: selectorCollection 	^selectorCollection inject: model rootClasses		into: 			[:classes :each | 			self refineTypes: classes				with: (selectorLookup at: each ifAbsentPut: [self implementorsOf: each])]! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector 	| classes |	classes := OrderedCollection new.	model rootClasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes].	^classes! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector in: aClass storeIn: classes 	(aClass directlyDefinesMethod: aSelector) 		ifTrue: 			[classes add: aClass.			^self].	aClass subclasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes]! !!RefactoryTyper methodsFor: 'computing types'!refineTypes: aClassCollection with: anotherClassCollection 	| classSet |	classSet := Set new.	aClassCollection do: 			[:each | 			anotherClassCollection do: 					[:cls | 					(cls includesClass: each) 						ifTrue: [classSet add: cls]						ifFalse: [(each includesClass: cls) ifTrue: [classSet add: each]]]].	^classSet! !!RefactoryTyper methodsFor: 'private'!executeSearch: searcher 	class withAllSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					methodName := sel.					parseTree := each parseTreeFor: sel.					parseTree notNil ifTrue: [searcher executeTree: parseTree]]]! !!RefactoryTyper methodsFor: 'private'!model	^model! !!RefactoryTyper methodsFor: 'private'!model: aRBSmalltalk	model := aRBSmalltalk! !!RefactoryTyper methodsFor: 'private'!rootClasses	^Class rootsOfTheWorld! !!RefactoryTyper methodsFor: 'assignments'!guessTypeFromAssignment: aNode 	| type set newType |	type := nil.	aNode value isAssignment 		ifTrue: 			[^self guessTypeFromAssignment: (RBAssignmentNode variable: aNode variable						value: aNode value value)].	aNode value isBlock ifTrue: [type := model classFor: [] class].	aNode value isLiteral 		ifTrue: 			[aNode value value isNil ifTrue: [^self].			type := model classFor: (self typeFor: aNode value value)].	aNode value isMessage 		ifTrue: 			[aNode value receiver isVariable 				ifTrue: [type := model classNamed: aNode value receiver name asSymbol].			aNode value selector == #asValue 				ifTrue: [type := model classNamed: #ValueHolder].			(#(#and: #or: #= #== #~= #~~ #<= #< #~~ #> #>=) 				includes: aNode value selector) ifTrue: [type := model classFor: Boolean]].	type isNil ifTrue: [^self].	set := variableTypes at: aNode variable name.	newType := set detect: [:each | type includesClass: each] ifNone: [nil].	newType isNil ifTrue: [^self].	newType = (model classFor: Object) ifTrue: [newType := type].	(bestGuesses at: aNode variable name ifAbsentPut: [Set new]) add: newType! !!RefactoryTyper methodsFor: 'assignments' stamp: 'jws 10/23/2016 05:39'!refineTypesByLookingAtAssignments	| searcher needsSearch |	needsSearch := false.	searcher := ParseTreeSearcher new.	variableTypes		keysAndValuesDo: [ :key :value | 			key first == $-				ifFalse: [ 					needsSearch := true.					searcher matches: key , ' := ``@object' do: [ :aNode :answer | self guessTypeFromAssignment: aNode ] ] ].	needsSearch		ifTrue: [ self executeSearch: searcher ]! !!RefactoryTyper methodsFor: 'assignments' stamp: 'bh 4/3/2000 11:52'!typeFor: anObject 	'' class == anObject class ifTrue: [^String].	^( {true. false} includes: anObject) 		ifTrue: [Boolean]		ifFalse: [anObject class]! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName 	^bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^bestGuesses at: anInstVarName		ifAbsent: [self typesFor: anInstVarName in: aClass]! !!RefactoryTyper methodsFor: 'accessing'!runOn: aClass 	variableTypes := Dictionary new.	variableMessages := Dictionary new.	bestGuesses := Dictionary new.	class := model classFor: aClass.	class instanceVariableNames isEmpty ifTrue: [^self].	self		selectedClass: aClass;		computeEquivalenceClassesForMethodsAndVars;		computeMessagesSentToVariables;		computeTypes;		refineTypesByLookingAtAssignments! !!RefactoryTyper methodsFor: 'accessing'!selectedClass: aClass 	class := model classFor: aClass! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName 	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!RefactoryTyper methodsFor: 'initialize-release'!initialize	model := RBNamespace new.	class := model classFor: Object.	variableTypes := Dictionary new.	variableMessages := Dictionary new.	selectorLookup := IdentityDictionary new.	bestGuesses := Dictionary new! !!RefactoryTyper methodsFor: 'selectors-collections' stamp: 'jws 10/23/2016 05:39'!processCollectionFor: key messagesTo: aName in: aBlock	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aName , ' `@message: ``@args'		do: [ :aNode :answer | 			self processCollectionMessagesFor: key in: aNode.			answer				add: aNode selector;				yourself ].	searcher		executeTree: aBlock		initialAnswer: (variableMessages at: (self collectionNameFor: key) ifAbsentPut: [ Set new ])! !!RefactoryTyper methodsFor: 'selectors-collections'!processCollectionMessagesFor: variableName in: aParseTree 	| parent block |	aParseTree isMessage ifFalse: [^self].	(#(#first #at: #last) includes: aParseTree selector) 		ifTrue: 			[parent := aParseTree parent.			(parent notNil and: [parent isMessage]) ifFalse: [^self].			aParseTree == parent receiver ifFalse: [^self].			(variableMessages at: (self collectionNameFor: variableName)				ifAbsentPut: [Set new]) add: parent selector.			self processCollectionMessagesFor: (self collectionNameFor: variableName)				in: parent].	(#(#do: #do:separatedBy: #collect: #reject: #select: #detect: #detect:ifNone:) 		includes: aParseTree selector) 			ifTrue: 				[block := aParseTree arguments first.				block isBlock ifFalse: [^self].				self 					processCollectionFor: variableName					messagesTo: block arguments first name					in: block].	#inject:into: == aParseTree selector 		ifTrue: 			[block := aParseTree arguments last.			block isBlock ifFalse: [^self].			self 				processCollectionFor: variableName				messagesTo: block arguments last name				in: block]! !!RefactoryTyper class methodsFor: 'instance creation'!newFor: aRBNamespace 	^(self new)		model: aRBNamespace;		yourself! !!RefactoryTyper class methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!typesFor: variableName in: aParseTree model: aRBSmalltalk	| searcher messages |	searcher := ParseTreeSearcher new.	searcher		matches: variableName , ' `@message: ``@args'		do: [ :aNode :answer | 			answer				add: aNode selector;				yourself ].	messages := searcher executeTree: aParseTree initialAnswer: Set new.	^ self new		model: aRBSmalltalk;		findTypeFor: messages! !!RefactoryVariableChange methodsFor: 'comparing'!= aRefactoryVariableChange 	^super = aRefactoryVariableChange 		and: [variable = aRefactoryVariableChange variable]! !!RefactoryVariableChange methodsFor: 'comparing'!hash	^self class hash bitXor: variable hash! !!RefactoryVariableChange methodsFor: 'private'!changeObject	^self variable! !!RefactoryVariableChange methodsFor: 'private'!changeSymbol	self subclassResponsibility! !!RefactoryVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3p>'! !!RefactoryVariableChange methodsFor: 'private' stamp: 'bh 4/29/2000 18:16'!primitiveExecute	| changeSymbol |	changeSymbol := self changeSymbol.	self changeClass perform: changeSymbol with: self changeObject.	self needsWork. "the following is to handle a VW bug.  Is it also a problem for Squeak?"	"ChangeSet current changeClass: self changeClass.	SourceFileManager default logChange: (self changesFileTemplate			expandMacrosWith: self changeClass			with: changeSymbol			with: self variable)"! !!RefactoryVariableChange methodsFor: 'private'!variable	^variable! !!RefactoryVariableChange methodsFor: 'initialize-release'!class: aBehavior variable: aString 	self changeClass: aBehavior.	variable := aString! !!AddClassVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveClassVariableChange remove: variable from: self changeClass! !!AddClassVariableChange methodsFor: 'printing'!changeString	^'Add class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddClassVariableChange methodsFor: 'private'!changeSymbol	^#addClassVarName:! !!AddClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!AddInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveInstanceVariableChange remove: variable from: self changeClass! !!AddInstanceVariableChange methodsFor: 'printing'!changeString	^'Add instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddInstanceVariableChange methodsFor: 'private'!changeSymbol	^#addInstVarName:! !!AddPoolVariableChange methodsFor: 'converting'!asUndoOperation	^RemovePoolVariableChange remove: variable from: self changeClass! !!AddPoolVariableChange methodsFor: 'private' stamp: 'nk 7/31/2004 09:22'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk classNamed: variable]				ifFalse: [variable].	^dictionary! !!AddPoolVariableChange methodsFor: 'private'!changeSymbol	^#addSharedPool:! !!AddPoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!AddPoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!AddPoolVariableChange methodsFor: 'printing'!changeString	^'Add pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!AddPoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!RefactoryVariableChange class methodsFor: 'instance creation'!add: aVariable to: aBehavior 	"This should only be called on the Add*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!RefactoryVariableChange class methodsFor: 'instance creation'!remove: aVariable from: aBehavior 	"This should only be called on the Remove*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPaths	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |	paths := ReferenceFinder findAllPathsTo: RefactoringManager instance.	self deny: paths isEmpty.	paths do: 		[:each | 		self assert: each last == RefactoringManager instance.		self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPathsToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |     	paths := ReferenceFinder findAllPathsToInstanceOf: RefactoringManager. 	    self deny: paths isEmpty.     	paths do:      	[:each |      	self assert: each last class == RefactoringManager.     	self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: RefactoringManager instance.	self assert: path last == RefactoringManager instance.	self assert: (path at: path size - 1) isVariableBinding.	self assert: (path at: path size - 1) key == #Instance.	self assert: path first == Smalltalk"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testNotFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: Object new.	self assert: path isNil"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testPathToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathToInstanceOf: RefactoringManager.	self assert: path last class == RefactoringManager.	self assert: path first == Smalltalk"! !!RemoveClassChange methodsFor: 'converting'!asUndoOperation	| classChanges |	classChanges := CompositeRefactoryChange new.	self changeClass withAllSubclasses do: 			[:each | 			classChanges defineClass: each definition.			each class instVarNames 				do: [:varName | classChanges addInstanceVariable: varName to: each class].			each selectors 				do: [:selector | classChanges compile: (each sourceCodeAt: selector) in: each].			each class selectors 				do: [:selector | classChanges compile: (each class sourceCodeAt: selector) in: each class]].	^classChanges! !!RemoveClassChange methodsFor: 'printing'!changeString	^'Remove class ', self displayClassName! !!RemoveClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeFromSystem';		nextPut: $!!! !!RemoveClassChange methodsFor: 'private'!primitiveExecute	self changeClass removeFromSystem! !!RemoveClassChange class methodsFor: 'instance creation'!remove: aClass 	^self new changeClass: aClass! !!RemoveClassChange class methodsFor: 'instance creation'!removeClassName: aSymbol 	^self new changeClassName: aSymbol! !!RemoveClassRefactoring methodsFor: 'initialize-release'!classNames: aClassNameCollection 	classNames := aClassNameCollection! !!RemoveClassRefactoring methodsFor: 'preconditions'!hasReferencesTo: aSymbol 	| literal |	literal := Smalltalk associationAt: aSymbol.	BrowserEnvironment new classesDo: 			[:each | 			(classNames 				includes: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name) 					ifFalse: 						[(each whichSelectorsReferTo: literal) isEmpty ifFalse: [^true].						(each whichSelectorsReferTo: aSymbol) isEmpty ifFalse: [^true]]].	^false! !!RemoveClassRefactoring methodsFor: 'preconditions'!preconditions	^classNames inject: RBCondition empty		into: 			[:sum :each | 			| aClass |			aClass := self model classNamed: each asSymbol.			aClass isNil ifTrue: [self refactoringError: 'No such class'].			sum 				& (((RBCondition isMetaclass: aClass) 						errorMacro: 'Cannot remove just the metaclass') not 						& ((RBCondition withBlock: [(self hasReferencesTo: each asSymbol) not])								errorMacro: each , ' is referenced.<n>Browse references?';								errorBlock: 										[self openBrowserOn: (BrowserEnvironment new 													referencesTo: (Smalltalk associationAt: each ifAbsent: [each]))];								yourself) 							& ((RBCondition hasSubclasses: aClass) not 									| ((RBCondition isEmptyClass: aClass) 											& ((RBCondition withBlock: [aClass superclass notNil])													errorMacro: 'Cannot remove top level class<n>when it has subclasses';													yourself))))]! !!RemoveClassRefactoring methodsFor: 'transforming'!removeClasses	classNames do: [:each | self model removeClassNamed: each]! !!RemoveClassRefactoring methodsFor: 'transforming'!reparentSubclasses	classNames do: 			[:each | 			| class |			class := self model classNamed: each.			self model reparentClasses: class subclasses copy to: class superclass]! !!RemoveClassRefactoring methodsFor: 'transforming'!transform	self		reparentSubclasses;		removeClasses! !!RemoveClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' classNames: '.	classNames asArray storeOn: aStream.	aStream nextPut: $)! !!RemoveClassRefactoring class methodsFor: 'instance creation'!classNames: aClassNameCollection 	^self new classNames: aClassNameCollection! !!RemoveClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk classNames: aClassNameCollection 	^(self new)		model: aRBSmalltalk;		classNames: aClassNameCollection;		yourself! !!RemoveClassTest methodsFor: 'failure tests'!testBadName	self 		shouldFail: (RemoveClassRefactoring classNames: #(#RecursiveSelfRule))! !!RemoveClassTest methodsFor: 'failure tests'!testRemoveReferenced	self 		shouldFail: (RemoveClassRefactoring classNames: #(#BasicLintRuleTest))! !!RemoveClassTest methodsFor: 'tests'!testRemoveClass	| refactoring |	refactoring := RemoveClassRefactoring 				classNames: (Array with: ('Foo' , 'LintRuleTest') asSymbol).	self executeRefactoring: refactoring.	self 		assert: (refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				isNil.	self 		assert: (refactoring model classNamed: #TransformationRuleTest) superclass 				= (refactoring model classNamed: #LintRuleTest)! !!RemoveClassVariableChange methodsFor: 'converting'!asUndoOperation	^AddClassVariableChange add: variable to: self changeClass! !!RemoveClassVariableChange methodsFor: 'printing'!changeString	^'Remove class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemoveClassVariableChange methodsFor: 'private'!changeSymbol	^#removeClassVarName:! !!RemoveClassVariableChange methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!primitiveExecute	[super primitiveExecute] on: Notification do: [:ex | ex resume] ! !!RemoveClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!RemoveClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule1				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'failure tests'!testReferencedVariable	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'tests'!testRemoveClassVar	| refactoring class |	refactoring := RemoveClassVariableRefactoring variable: 'Foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesClassVariable: 'Foo1').	self executeRefactoring: refactoring.	self deny: (class definesClassVariable: 'Foo1')! !!RemoveInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^AddInstanceVariableChange add: variable to: self changeClass! !!RemoveInstanceVariableChange methodsFor: 'printing'!changeString	^'Remove instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemoveInstanceVariableChange methodsFor: 'private'!changeSymbol	^#removeInstVarName:! !!RemoveInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRemoveInstanceVariable	| class |	model 		defineClass: 'nil subclass: #Object instanceVariableNames: ''foo1'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Object.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: (RemoveInstanceVariableRefactoring 				model: model				variable: 'foo1'				class: class).	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveInstanceVariableTest methodsFor: 'tests'!testRemoveInstVar	| refactoring class |	refactoring := RemoveInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: refactoring.	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name1'				class: LintRuleTest)! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testReferencedVariable	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name'				class: LintRuleTest)! !!RemoveMethodChange methodsFor: 'comparing'!= aRemoveMethodChange 	super = aRemoveMethodChange ifFalse: [^false].	^selector = aRemoveMethodChange selector! !!RemoveMethodChange methodsFor: 'comparing'!hash	^selector hash! !!RemoveMethodChange methodsFor: 'converting'!asUndoOperation	^AddMethodChange compile: (self methodSourceFor: selector)		in: self changeClass! !!RemoveMethodChange methodsFor: 'printing'!changeString	^'Remove method, #<1s>, from: <2s>' expandMacrosWith: selector		with: self displayClassName! !!RemoveMethodChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSelector: ';		nextPutAll: selector;		nextPut: $!!! !!RemoveMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass removeSelector: selector! !!RemoveMethodChange methodsFor: 'private'!selector	^selector! !!RemoveMethodChange methodsFor: 'initialize-release'!selector: aSymbol 	selector := aSymbol! !!RemoveMethodChange class methodsFor: 'instance creation'!remove: aSymbol from: aClass 	^(self new)		changeClass: aClass;		selector: aSymbol;		yourself! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToAnyOf: aSelectorCollection 	aSelectorCollection do: 			[:each | 			self model allReferencesTo: each				do: 					[:aRBMethod | 					(aSelectorCollection includes: aRBMethod selector) 						ifFalse: 							[self 								refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' 										expandMacrosWith: aRBMethod modelClass										with: each)								with: [self openBrowserOn: (BrowserEnvironment new referencesTo: each)]]]]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToSuperSendsToAnyOf: superMessages 	[superMessages isEmpty] whileFalse: 			[self 				refactoringWarning: ('Although <1s> is equivalent to a superclass method,<n>it contains a super send so it might modify behavior.' 						expandMacrosWith: superMessages first).			superMessages remove: superMessages first]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkSuperMethods	| superMessages nonSupers |	nonSupers := OrderedCollection new.	superMessages := OrderedCollection new.	(selectors reject: [:each | self justSendsSuper: each]) do: 			[:each | 			(self superclassEquivalentlyDefines: each) 				ifTrue: 					[(class parseTreeFor: each) superMessages isEmpty 						ifFalse: [superMessages add: each]]				ifFalse: [nonSupers add: each]].	nonSupers isEmpty & superMessages isEmpty ifTrue: [^self].	self checkReferencesToAnyOf: nonSupers.	self checkReferencesToSuperSendsToAnyOf: superMessages! !!RemoveMethodRefactoring methodsFor: 'preconditions' stamp: 'jws 10/23/2016 05:39'!justSendsSuper: aSelector	| matcher parseTree superclass |	matcher := ParseTreeSearcher justSendsSuper.	parseTree := class parseTreeFor: aSelector.	(matcher executeTree: parseTree initialAnswer: false)		ifFalse: [ ^ false ].	parseTree lastIsReturn		ifTrue: [ ^ true ].	superclass := class superclass whichClassIncludesSelector: aSelector.	superclass isNil		ifTrue: [ ^ true ].	"Since there isn't a superclass that implements the message, we can 								 delete it since it would be an error anyway."	parseTree := superclass parseTreeFor: aSelector.	matcher := ParseTreeSearcher new.	matcher		matches: '^``@object'		do: [ :aNode :answer | 			answer				add: aNode value;				yourself ].	matcher executeTree: parseTree initialAnswer: Set new.	^ (matcher answer detect: [ :each | (each isVariable and: [ each name = 'self' ]) not ] ifNone: [ nil ]) isNil! !!RemoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: RBCondition empty		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkSuperMethods.						true])! !!RemoveMethodRefactoring methodsFor: 'preconditions'!superclassEquivalentlyDefines: aSelector 	| superTree myTree |	class superclass isNil ifTrue: [^false].	superTree := class superclass parseTreeFor: aSelector.	myTree := class parseTreeFor: aSelector.	(superTree isNil or: [myTree isNil]) ifTrue: [^false].	^superTree equalTo: myTree exceptForVariables: #()! !!RemoveMethodRefactoring methodsFor: 'initialize-release'!removeMethods: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!RemoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' removeMethods: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!RemoveMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | class removeMethod: each]! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeMethods: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		removeMethods: selectorCollection from: aClass;		yourself! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!removeMethods: selectorCollection from: aClass	^self new removeMethods: selectorCollection from: aClass! !!RemoveMethodTest methodsFor: 'tests'!testModelRecursiveMethodThatIsNotReferencedFromOtherMethods	| class otherClass |	class := model classNamed: #Object.	class compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).	self assert: (class definesMethod: #someMethodThatIsNotReferenced).	otherClass := model metaclassNamed: self class superclass name.	otherClass 		compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced'		classified: #(#accessing).	model removeClassNamed: self class name.	self executeRefactoring: (RemoveMethodRefactoring 				model: model				removeMethods: #(#someMethodThatIsNotReferenced)				from: class).	self deny: (class definesMethod: #someMethodThatIsNotReferenced)! !!RemoveMethodTest methodsFor: 'tests'!testRemoveMethod	| refactoring selectors |	selectors := Array with: ('selectorNot' , 'Referenced') asSymbol.	refactoring := RemoveMethodRefactoring removeMethods: selectors				from: RefactoryTestDataApp.	self assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first).	self executeRefactoring: refactoring.	self deny: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveReferenced	self shouldFail: (RemoveMethodRefactoring removeMethods: #(#checkClass:)				from: BasicLintRuleTest)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveSameMethodButSendsSuper	self shouldWarn: (RemoveMethodRefactoring removeMethods: #(#new)				from: BasicLintRuleTest class)! !!RemoveParameterRefactoring methodsFor: 'private' stamp: 'md 8/2/2005 22:25'!computeNewSelector	| keywords stream |	oldSelector numArgs == 0 		ifTrue: [self refactoringError: 'This method contains no arguments'].	oldSelector isInfix 		ifTrue: [self refactoringError: 'Cannot remove parameters of infix selectors'].	keywords := oldSelector keywords asOrderedCollection.	keywords size = 1 ifTrue: [^(keywords first copyWithout: $:) asSymbol].	keywords removeAt: parameterIndex.	stream := WriteStream on: ''.	keywords do: [:each | stream nextPutAll: each].	^stream contents asSymbol! !!RemoveParameterRefactoring methodsFor: 'transforming'!getNewSelector	| tree |	(class directlyDefinesMethod: oldSelector)		ifFalse: [self refactoringError: 'Method doesn''t exist'].	tree := class parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources'].	parameterIndex := tree argumentNames indexOf: argument ifAbsent: [self refactoringError: 'Select a parameter!!!!'].	permutation := (1 to: oldSelector numArgs)				copyWithout: parameterIndex.	newSelector := self computeNewSelector! !!RemoveParameterRefactoring methodsFor: 'transforming'!hasReferencesToTemporaryIn: each 	| tree |	tree := each parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources.'].	^tree references: (tree argumentNames at: parameterIndex)! !!RemoveParameterRefactoring methodsFor: 'preconditions'!myConditions	| imps |	imps := self model allImplementorsOf: oldSelector.	self getNewSelector.	^imps inject: (RBCondition definesSelector: oldSelector in: class)		into: 			[:cond :each | 			cond 				& (RBCondition withBlock: [(self hasReferencesToTemporaryIn: each) not]						errorString: 'This argument is still referenced in atleast one implementor!!!!')]! !!RemoveParameterRefactoring methodsFor: 'initialize-release'!removeParameter: aString in: aClass selector: aSelector 	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!RemoveParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' removeParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector.	aStream nextPut: $)! !!InlineParameterRefactoring methodsFor: 'private'!allExpressionsToInline	| coll |	coll := Set new.	self model allReferencesTo: oldSelector		do: 			[:each | 			| tree |			tree := each parseTree.			tree notNil ifTrue: [coll addAll: (self expressionsToInlineFrom: tree)]].	^coll asOrderedCollection! !!InlineParameterRefactoring methodsFor: 'private' stamp: 'jws 10/23/2016 05:39'!expressionsToInlineFrom: aTree	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '``@obj ' , (self buildSelectorString: oldSelector)		do: [ :aNode :answer | 			answer				add: (aNode arguments at: parameterIndex);				yourself ].	^ searcher executeTree: aTree initialAnswer: OrderedCollection new! !!InlineParameterRefactoring methodsFor: 'initialize-release'!inlineParameter: aString in: aClass selector: aSelector	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!InlineParameterRefactoring methodsFor: 'transforming'!modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copy.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copy value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass! !!InlineParameterRefactoring methodsFor: 'preconditions'!myConditions	self getNewSelector.	expressions := self allExpressionsToInline.	^(RBCondition definesSelector: oldSelector in: class) 		& ((RBCondition withBlock: [expressions isEmpty not]) 				errorMacro: 'No callers. Use Remove Method instead.') 			& ((RBCondition withBlock: [expressions size = 1]) 					errorMacro: 'All values passed as this argument must be identical.') 			& ((RBCondition withBlock: [expressions first isLiteral]) 					errorMacro: 'All values passed must be literal.')! !!InlineParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' inlineParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector;		nextPut: $)! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		removeParameter: aString			in: aClass			selector: aSelector;		yourself! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!removeParameter: aString in: aClass selector: aSelector	^self new removeParameter: aString in: aClass selector: aSelector! !!InlineParameterRefactoring class methodsFor: 'instance creation'!inlineParameter: aString in: aClass selector: aSelector 	^self new 		inlineParameter: aString		in: aClass		selector: aSelector! !!InlineParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inlineParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		inlineParameter: aString			in: aClass			selector: aSelector;		yourself! !!RemoveParameterTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'asdf'					in: BasicLintRuleTest					selector: #checkClass:);		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'aSmalllintContext'					in: BasicLintRuleTest					selector: #checkClass1:)! !!RemoveParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo123: a <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := RemoveParameterRefactoring 				model: model				removeParameter: 'a'				in: Object				selector: #foo123:.	self shouldFail: refactoring! !!RemoveParameterTest methodsFor: 'tests'!testRemoveParameter	| refactoring class |	refactoring := RemoveParameterRefactoring 				removeParameter: 'anArg'				in: RefactoryTestDataApp				selector: ('rename' , 'ThisMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod) 				= (RBParser parseMethod: 'renameThisMethod								^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod								^(self renameThisMethod)').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RemovePoolVariableChange methodsFor: 'converting'!asUndoOperation	^AddPoolVariableChange add: variable to: self changeClass! !!RemovePoolVariableChange methodsFor: 'private'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk at: variable asSymbol]				ifFalse: [variable].	^dictionary! !!RemovePoolVariableChange methodsFor: 'private'!changeSymbol	^#removeSharedPool:! !!RemovePoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!RemovePoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!RemovePoolVariableChange methodsFor: 'printing'!changeString	^'Remove pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!RemovePoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!RenameClassChange methodsFor: 'comparing'!= aRenameClassChange 	super = aRenameClassChange ifFalse: [^false].	^oldName = aRenameClassChange oldName 		and: [newName = aRenameClassChange newName]! !!RenameClassChange methodsFor: 'accessing'!changeClass	^Smalltalk at: oldName asSymbol ifAbsent: [Smalltalk at: newName asSymbol]! !!RenameClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	| change |	change := super renameChangesForClass: aClassName to: newClassName.	oldName asSymbol == aClassName 		ifTrue: [change rename: newClassName to: newName].	^change! !!RenameClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undos |	self changeClass rename: newName.	undos := changes collect: 					[:each | 					(each renameChangesForClass: oldName asSymbol to: newName asSymbol) 						executeNotifying: aBlock].	^(self copy)		changes: undos reverse;		rename: newName to: oldName;		yourself! !!RenameClassChange methodsFor: 'private'!flattenOnto: aCollection 	aCollection 		add: (self copy changes: (changes inject: OrderedCollection new						into: 							[:sum :each | 							each flattenOnto: sum.							sum]))! !!RenameClassChange methodsFor: 'private'!newName	^newName! !!RenameClassChange methodsFor: 'private'!oldName	^oldName! !!RenameClassChange methodsFor: 'initialize-release'!rename: oldString to: newString 	oldName := oldString.	newName := newString! !!RenameClassChange class methodsFor: 'instance creation'!rename: oldString to: newString 	^(self new)		rename: oldString to: newString;		yourself! !!RenameClassRefactoring methodsFor: 'initialize-release'!className: aName newName: aNewName 	className := aName asSymbol.	class := self model classNamed: className.	newName := aNewName asSymbol! !!RenameClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition withBlock: [class notNil and: [class isMeta not]]		errorString: className , ' is not a valid class name') 			& (RBCondition isValidClassName: newName) 			& (RBCondition isGlobal: newName in: self model) not! !!RenameClassRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!renameReferences	| replacer |	replacer := (ParseTreeRewriter replaceLiteral: className with: newName)		replace: className with: newName;		replaceArgument: newName			withValueFrom: [ :aNode | self refactoringError: newName , ' already exists within the reference scope' ];		yourself.	self model		allReferencesToClass: class		do: [ :method | 			(method modelClass hierarchyDefinesVariable: newName)				ifTrue: [ self refactoringError: newName , ' is already defined in hierarchy of ' , method modelClass printString ].			self convertMethod: method selector for: method modelClass using: replacer ]! !!RenameClassRefactoring methodsFor: 'transforming'!transform	self model 		renameClass: class		to: newName		around: [self renameReferences]! !!RenameClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' rename: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newName;		nextPut: $)! !!RenameClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aClass to: aNewName 	^(self new)		model: aRBSmalltalk;		className: aClass name newName: aNewName;		yourself! !!RenameClassRefactoring class methodsFor: 'instance creation'!rename: aClass to: aNewName	^self new className: aClass name newName: aNewName! !!RenameClassTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameClassRefactoring rename: LintRuleTest					to: self objectClassVariable);		shouldFail: (RenameClassRefactoring rename: LintRuleTest to: #'Ob ject')! !!RenameClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (RenameClassRefactoring rename: self class to: #Object)! !!RenameClassTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (RenameClassRefactoring rename: self class class to: #Foo)! !!RenameClassTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRenameClass	| refactoring class |	model 		defineClass: 'Object subclass: #Foo instanceVariableNames: ''a'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo.	class		compile: 'foo	^Object' classified: #(#accessing);		compile: 'objectName ^#(Object)' classified: #(#accessing).	refactoring := RenameClassRefactoring 				model: model				rename: Object				to: #Thing.	self executeRefactoring: refactoring.	self assert: (model includesClassNamed: #Thing).	self deny: (model includesClassNamed: #Object).	self 		assert: (class parseTreeFor: #foo) = (RBParser parseMethod: 'foo ^Thing').	self assert: (class parseTreeFor: #objectName) 				= (RBParser parseMethod: 'objectName ^#(Thing)').	self assert: class superclass name = #Thing! !!RenameClassTest methodsFor: 'tests'!testRenameClass	| refactoring class |	refactoring := RenameClassRefactoring 				rename: (Smalltalk at: ('Class' , 'ToRename') asSymbol)				to: 'New' , 'ClassName' asSymbol.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: ('New' , 'ClassName') asSymbol) 				parseTreeFor: #method1) = (RBParser parseMethod: 'method1	^self method2').	self deny: (refactoring model 				includesClassNamed: ('Class' , 'ToRename') asSymbol).	class := refactoring model 				classNamed: ('Subclass' , 'OfClassToRename') asSymbol.	self assert: class superclass 				= (refactoring model classNamed: ('New' , 'ClassName') asSymbol).	self assert: (class parseTreeFor: #symbolReference) 				= (RBParser parseMethod: 'symbolReference								^#NewClassName').	self assert: (class parseTreeFor: #reference) 				= (RBParser parseMethod: 'reference								^NewClassName new')! !!RenameClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: self objectClassVariable				in: TransformationRuleTest)! !!RenameClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #Foo				in: TransformationRuleTest class)! !!RenameClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameClassVariableRefactoring 				rename: #foo				to: #newFoo				in: BasicLintRuleTest)! !!RenameClassVariableTest methodsFor: 'tests'!testRenameClassVar	| refactoring class |	refactoring := RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #RSR				in: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class directlyDefinesClassVariable: #RSR).	self deny: (class directlyDefinesClassVariable: #RecursiveSelfRule).	self 		assert: (class metaclass parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1								RSR := ParseTreeSearcher new.								RSR									addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')											-> [:aNode :answer | true]').	self assert: (class metaclass parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke								RSR := nil').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 								class := aSmalllintContext selectedClass.								(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 										[(RSR executeTree: rewriteRule tree initialAnswer: false)											ifFalse: 												[builder compile: rewriteRule tree printString													in: class													classified: aSmalllintContext protocols]]')! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'name'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'foo'				to: 'newFoo'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'tests'!testRenameInstVar	| refactoring class |	refactoring := RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'asdf'				in: BasicLintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #BasicLintRuleTest.	self assert: (class directlyDefinesInstanceVariable: 'asdf').	self deny: (class directlyDefinesInstanceVariable: 'classBlock').	self 		assert: (class parseTreeFor: #checkClass:) = (RBParser 						parseMethod: 'checkClass: aSmalllintContext 								^asdf value: aSmalllintContext value: result').	self 		assert: (class parseTreeFor: #classBlock:) = (RBParser 						parseMethod: 'classBlock: aBlock								asdf := aBlock testMethod1').	self 		assert: (class parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize								super initialize.								asdf := [:context :aResult | ].								methodBlock := [:context :aResult | ].								self resultClass: SelectorEnvironment.')! !!RenameMethodRefactoring methodsFor: 'testing'!hasPermutedArguments	^hasPermutedArguments isNil 		ifTrue: [hasPermutedArguments := super hasPermutedArguments]		ifFalse: [hasPermutedArguments]! !!RenameMethodRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^self hasPermutedArguments not! !!RenameMethodRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: newSelector printString 				, ' doesn''t have the correct number of arguments.'! !!RenameMethodRefactoring methodsFor: 'preconditions'!preconditions	| newCondition |	newCondition := (RBCondition withBlock: [newSelector = oldSelector]				errorString: 'The selectors are <1?:not >equivalent') & (RBCondition 							withBlock: [permutation asArray ~= (1 to: oldSelector numArgs) asArray]							errorString: 'The arguments are <1?:not >permuted').	^newCondition | super preconditions! !!RenameMethodRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!parseTreeRewriter	| rewriteRule oldString newString |	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector withPermuteMap: permutation.	rewriteRule := self hasPermutedArguments		ifTrue: [ ParseTreeRewriter new ]		ifFalse: [ ParseTreeRewriter replaceLiteral: oldSelector with: newSelector ].	rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.	^ rewriteRule! !!RenameMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' renameMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newSelector;		nextPutAll: ' permuation: '.	permutation storeOn: aStream.	aStream nextPut: $)! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:29'!model: aRBSmalltalk renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^(self new)		model: aRBSmalltalk;		renameMethod: aSelector			in: aClass			to: newSelector			permutation: aMap;		yourself! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:26'!renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^self new renameMethod: aSelector		in: aClass		to: newSelector		permutation: aMap! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testExistingSelector	self shouldFail: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #runOnEnvironment:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testMultipleSelectors	self shouldWarn: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #foo:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenamePermuteArgs	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename:' , 'two:') asSymbol				in: RefactoryTestDataApp				to: ('rename:' , 'two:') asSymbol				permutation: #(2 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: ('rename:' , 'two:') asSymbol) = (RBParser 						parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').	self assert: (class parseTreeFor: #exampleCall) 				= (RBParser parseMethod: 'exampleCall ^self rename: 2 two: 1')! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenamePrimitive	| refactoring count |	count := 0.	model allReferencesTo: #basicAt:put: do: [:method | count := count + 1].	refactoring := RenameMethodRefactoring 				model: model				renameMethod: #basicAt:put:				in: Object				to: ('at:' , 'bar:') asSymbol				permutation: (1 to: 2).	self proceedThroughWarning: [self executeRefactoring: refactoring].	model allReferencesTo: #basicAt:put:		do: 			[:method | 			count := count - 1.			self assert: method source isNil].	model allReferencesTo: ('at:' , 'bar:') asSymbol		do: [:method | count := count - 1].	self assert: count = 0! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenameTestMethod	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename' , 'ThisMethod:') asSymbol				in: RefactoryTestDataApp				to: #renameThisMethod2:				permutation: (1 to: 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod2:) 				= (RBParser parseMethod: 'renameThisMethod2: anArg	^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod	^(self renameThisMethod2: 5)').	self 		assert: (class parseTreeFor: #symbolReference) = (RBParser 						parseMethod: 'symbolReference		^ #(#renameThisMethod2: #(4 #renameThisMethod2:))').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenameTestMethod1	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('test' , 'Method1') asSymbol				in: RefactoryTestDataApp				to: #testMethod2				permutation: (1 to: 0).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testMethod2) = (RBParser 						parseMethod: 'testMethod2	^self testMethod2 , ([:each | each testMethod2] value: #(#(#testMethod2) 2 #testMethod2))').	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #classBlock:) = (RBParser 							parseMethod: 'classBlock: aBlock	classBlock := aBlock testMethod2').	self deny: (class directlyDefinesMethod: ('test' , 'Method1') asSymbol)! !!RenameTemporaryRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval newName: aString 	class := self classObjectFor: aClass.	selector := aSelector.	interval := anInterval.	newName := aString! !!RenameTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newName for: class) 			& (RBCondition definesInstanceVariable: newName in: class) not 			& (RBCondition definesClassVariable: newName in: class) not 			& (RBCondition withBlock: 						[| methodSource |						interval first > interval last 							ifTrue: [self refactoringError: 'Invalid variable name'].						methodSource := class sourceCodeFor: selector.						methodSource size >= interval last 							ifFalse: [self refactoringError: 'Invalid range for variable'].						oldName := methodSource copyFrom: interval first to: interval last.						true])! !!RenameTemporaryRefactoring methodsFor: 'tranforming' stamp: 'jws 10/23/2016 05:38'!renameNode: aParseTree	(aParseTree whoDefines: newName) notNil		ifTrue: [ self refactoringError: newName , ' is already defined' ].	(aParseTree allDefinedVariables includes: newName)		ifTrue: [ self refactoringError: newName , ' is already defined' ].	(ParseTreeRewriter rename: oldName to: newName) executeTree: aParseTree! !!RenameTemporaryRefactoring methodsFor: 'tranforming'!transform	| definingNode variableNode |	parseTree := class parseTreeFor: selector.	variableNode := self 				whichVariableNode: parseTree				inInterval: interval				name: oldName.	(variableNode isNil or: [variableNode isVariable not]) 		ifTrue: [self refactoringError: oldName , ' isn''t a valid variable'].	variableNode name = oldName 		ifFalse: [self refactoringError: 'Invalid selection'].	definingNode := variableNode whoDefines: oldName.	definingNode isNil 		ifTrue: [self refactoringError: oldName , ' isn''t defined by the method'].	self renameNode: definingNode.	class compileTree: parseTree! !!RenameTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' renameTemporaryFrom: '.	interval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval			newName: newName;		yourself! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval		newName: newName! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadInterval	self shouldFail: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (14 to: 17)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'asdf'				in: RefactoryTestDataApp				selector: #testMethod)! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'name'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'rules'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'DependentFields'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'a b'					in: LintRuleTest					selector: #openEditor)! !!RenameTemporaryTest methodsFor: 'failure tests'!testModelBadName	| class |	model := RBNamespace new.	class := model classNamed: #Object.	class 		compile: 'aMethod: temp1 ^[| temp2 | temp2 := [:temp3 | temp3 = 5] value: 5. temp2] value'		classified: #(#accessing).	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp3'					in: class					selector: #aMethod:);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp1'					in: class					selector: #aMethod:)! !!RenameTemporaryTest methodsFor: 'tests' stamp: 'bh 4/29/2000 21:21'!testRenameTemporary	| refactoring |	refactoring := RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (15 to: 19)						for: (LintRuleTest sourceCodeAt: #openEditor))				to: 'asdf'				in: LintRuleTest				selector: #openEditor.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #openEditor) = (RBParser 							parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults].								SmalllintResultEditor openOn: self label: name')! !!RenameVariableChange methodsFor: 'comparing'!= aRenameVariableChange 	self class = aRenameVariableChange class ifFalse: [^false].	^className = aRenameVariableChange changeClassName and: 			[isMeta = aRenameVariableChange isMeta and: 					[oldName = aRenameVariableChange oldName 						and: [newName = aRenameVariableChange newName]]]! !!RenameVariableChange methodsFor: 'comparing'!hash	^(self changeClassName hash bitXor: self oldName hash) 		bitXor: self newName hash! !!RenameVariableChange methodsFor: 'private'!addNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	self removeOldVariable.	^undo! !!RenameVariableChange methodsFor: 'private'!isMeta	^isMeta! !!RenameVariableChange methodsFor: 'private'!newName: aString 	newName := aString! !!RenameVariableChange methodsFor: 'private'!oldName: aString	oldName := aString! !!RenameVariableChange methodsFor: 'private'!removeOldVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'accessing'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]! !!RenameVariableChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RenameVariableChange methodsFor: 'accessing'!changeClassName	^className! !!RenameVariableChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RenameVariableChange methodsFor: 'accessing'!newName	^newName! !!RenameVariableChange methodsFor: 'accessing'!oldName	^oldName! !!RenameVariableChange methodsFor: 'printing'!changeString	^'Rename ' , oldName , ' to ' , newName! !!RenameVariableChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RenameVariableChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RenameClassVariableChange methodsFor: 'private'!addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute! !!RenameClassVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass classPool at: newName asSymbol put: oldValue! !!RenameClassVariableChange methodsFor: 'private'!removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute! !!RenameInstanceVariableChange methodsFor: 'private'!addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute! !!RenameInstanceVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | inst instVarAt: newIndex put: (inst instVarAt: oldIndex)]]! !!RenameInstanceVariableChange methodsFor: 'private'!removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute! !!RenameVariableChange class methodsFor: 'instance creation'!rename: oldName to: newName in: aClass 	^(self new)		oldName: oldName;		newName: newName;		changeClass: aClass;		yourself! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.7! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/1/2005 07:36'!createMorphicWindow	| window replacementPane |	window := super createMorphicWindow.	replacementPane := PluggableTextMorph 				on: self				text: #replacementString				accept: #replacementString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: replacementPane frame: self replacementPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #replace)				label: 'Replace';				onColor: Color white offColor: Color lightGray)		frame: self replaceButtonFrame.	^window! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 17:55'!fileOutSource: source onStream: stream forMethodNamed: methodName inCategory: protocol forClassNamed: className 	stream		nextPut: $!!;		nextPutAll: className;		nextPutAll: ' methodsFor: ''';		nextPutAll: protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!methodCheckBoxFrame	^0.6 @ 0.9 corner: 1 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'jws 10/23/2016 05:38'!replace	| rewriteRule compiledMethod changes organizer |	self foundEnvironment ifNil: [ self search ].	rewriteRule := ParseTreeRewriter new.	rewriteRule replace: self searchPatternString asString with: self replacementString asString.	changes := String		streamContents: [ :stream | 			stream				header;				timeStamp;				nextPutAll: '"This is the result of replacing';				cr;				nextPutAll: self searchString asString;				cr;				nextPutAll: 'with';				cr;				nextPutAll: self replacementString asString;				nextPutAll: '"!!'.			self foundEnvironment				classesAndSelectorsDo: [ :cls :sel | 					organizer := cls organization.					compiledMethod := cls compiledMethodAt: sel.					(rewriteRule canMatchMethod: compiledMethod)						ifTrue: [ 							(rewriteRule executeTree: compiledMethod parseTree)								ifTrue: [ 									stream cr.									self										fileOutSource: rewriteRule tree printString										onStream: stream										forMethodNamed: sel										inCategory: (organizer categoryOfElement: sel)										forClassNamed: cls name ] ] ] ].	FileContentsBrowser browseStream: changes readStream named: 'Prospective replacements'! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!replaceButtonFrame	^0.3 @ 0.9 corner: 0.6 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 11:48'!replaceEnabled	^foundEnvironment notNil! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!replacementPaneFrame	^0 @ 0.7 corner: 1.0 @ 0.9! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:32'!searchButtonFrame	^0 @ 0.9 corner: 0.3 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!RewriteTool methodsFor: 'initialization' stamp: 'nk 3/1/2005 07:33'!initialize	super initialize.	replacementString := self searchPatternString.! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 13:07'!replacementString	^replacementString! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 2/23/2005 13:35'!replacementString: anObject	replacementString := anObject.	self changed: #replacementString.	^true! !!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!initialize	TheWorldMenu registerOpenCommand: {'Rewrite Tool'. {self. #open}}.	self registerInFlapsRegistry.! !!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#RewriteTool #prototypicalToolWindow 'Rewrite Tool' 'For doing advanced edits to code' ) 						forFlapNamed: 'Tools']! !!RewriteTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:59'!jokerHelp	^self comment, FinderTool comment! !!RewriteTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name put: aClass selectors]		ifFalse: [classSelectors at: aClass name put: aClass selectors]! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name ifAbsentPut: [Set new]]		ifFalse: [classSelectors at: aClass name ifAbsentPut: [Set new]]) add: aSymbol! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspect	Transcript cr; cr; show:self name.	searchStrings ifNotNil:		[Transcript cr;show:'     ( '.		searchStrings do:[:string| Transcript show:string asString,' '].		Transcript show:')'.].	self logOrInspectDictionary:classSelectors.	self logOrInspectDictionary:metaClassSelectors.! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspectDictionary:aDictionary	aDictionary keysAndValuesDo: 		[:class :selectors | 		selectors do: 			[:sel |			Transcript cr; show: '     ',class name asString , '>>' , sel asString]].! !!SelectorEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:06'!asSelectorEnvironment	^ self! !!SelectorEnvironment methodsFor: 'accessing'!numberSelectors	"This doesn't compute the correct result when a method that is included in our method list is not in the	environment we are wrapping. It is implemented this way for efficiency."	^(classSelectors inject: 0 into: [:sum :each | sum + each size]) 		+ (metaClassSelectors inject: 0 into: [:sum :each | sum + each size])! !!SelectorEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	^(self privateSelectorsForClass: aClass) 		do: [:each | (aClass includesSelector: each) ifTrue: [aBlock value: each]]! !!SelectorEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new: classSelectors size + metaClassSelectors size.	names		addAll: classSelectors keys;		addAll: metaClassSelectors keys.	^names asOrderedCollection! !!SelectorEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: [(self includesClass: class) ifTrue: [aBlock value: class]]].	metaClassSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: 					[(self includesClass: class class) ifTrue: [aBlock value: class class]]]! !!SelectorEnvironment methodsFor: 'initialize-release'!classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary 	classSelectors := classSelectorDictionary.	metaClassSelectors := metaClassSelectorDictionary! !!SelectorEnvironment methodsFor: 'initialize-release'!classes: classArray metaClasses: metaArray 	"Used to recreate an environment from its storeString"	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	classArray 		do: [:each | classSelectors at: each first put: each last asSet].	metaArray 		do: [:each | metaClassSelectors at: each first put: each last asSet]! !!SelectorEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classSelectors := IdentityDictionary new.	metaClassSelectors := IdentityDictionary new! !!SelectorEnvironment methodsFor: 'initialize-release'!on: aDict 	aDict keysAndValuesDo: 			[:class :selectors | 			class isMeta 				ifTrue: [metaClassSelectors at: class soleInstance name put: selectors]				ifFalse: [classSelectors at: class name put: selectors]]! !!SelectorEnvironment methodsFor: 'private'!defaultLabel	^'some methods'! !!SelectorEnvironment methodsFor: 'private'!privateIncludesSelector: aSelector inClass: aClass 	^(self privateSelectorsForClass: aClass) includes: aSelector! !!SelectorEnvironment methodsFor: 'private'!privateSelectorsForClass: aClass 	^aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [#()]]		ifFalse: [classSelectors at: aClass name ifAbsent: [#()]]! !!SelectorEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(super includesCategory: aCategory) and: 			[(self classNamesFor: aCategory) contains: 					[:className | 					(classSelectors includesKey: className) 						or: [metaClassSelectors includesKey: className]]]! !!SelectorEnvironment methodsFor: 'testing'!includesClass: aClass 	^(self privateSelectorsForClass: aClass) isEmpty not 		and: [super includesClass: aClass]! !!SelectorEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass)		and: [(environment selectorsFor: aProtocol in: aClass)				contains: [:aSelector | self privateIncludesSelector: aSelector inClass: aClass]]! !!SelectorEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)		and: [self privateIncludesSelector: aSelector inClass: aClass]! !!SelectorEnvironment methodsFor: 'testing'!isEmpty	^classSelectors isEmpty and: [metaClassSelectors isEmpty]! !!SelectorEnvironment methodsFor: 'testing'!isSelector	^true! !!SelectorEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(SelectorEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!SelectorEnvironment methodsFor: 'copying'!postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	^super postCopy! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta 		ifTrue: [metaClassSelectors removeKey: aClass soleInstance name ifAbsent: []]		ifFalse: [classSelectors removeKey: aClass name ifAbsent: []]! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector 	(aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [^self]]		ifFalse: [classSelectors at: aClass name ifAbsent: [^self]]) 			remove: aSelector			ifAbsent: []! !!SelectorEnvironment methodsFor: 'printing'!storeOn: aStream 	| classBlock |	aStream		nextPutAll: '((';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream		nextPut: $);		nextPutAll: ' classes: #('.	classBlock := 			[:key :value | 			aStream				nextPutAll: '#(';				nextPutAll: key;				nextPutAll: ' #('.			value do: 					[:each | 					aStream						nextPutAll: each;						nextPut: $ ].			aStream				nextPutAll: '))';				cr].	classSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: ') metaClasses: #('.	metaClassSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: '))'! !!ParseTreeEnvironment methodsFor: 'initialize-release'!matcher: aParseTreeSearcher	matcher := aParseTreeSearcher! !!ParseTreeEnvironment methodsFor: 'accessing' stamp: 'bh 5/9/2000 00:19'!selectionIntervalFor: aString 	| parseTree node |	matcher isNil ifTrue: [^super selectionIntervalFor: aString].	parseTree := RBParser parseMethod: aString				onError: [:error :position | ^super selectionIntervalFor: aString].	node := matcher executeTree: parseTree initialAnswer: nil.	^node isNil 		ifTrue: [super selectionIntervalFor: aString]		ifFalse: [node sourceInterval]! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsMatching: aString in: anEnvironment 	| classDict metaDict |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := Set new.			anEnvironment selectorsForClass: class				do: [:each | (aString match: each) ifTrue: [selectors add: each]].			selectors isEmpty 				ifFalse: 					[class isMeta 						ifTrue: [metaDict at: class soleInstance name put: selectors]						ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aString;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	selectors := Array with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance name put: selectors]							ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aSelector;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!matches: aString in: anEnvironment 	| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)				label: 'Matching: ' , aString;				searchStrings: (Array with: aString);				yourself.	anEnvironment classesAndSelectorsDo: 			[:each :sel | 			| method |			method := each compiledMethodAt: sel.			method allLiterals do: 					[:lit | 					lit isString 						ifTrue: 							[(aString match: lit) ifTrue: [newEnvironment addClass: each selector: sel]]]].	^newEnvironment! !!SelectorEnvironment class methodsFor: 'instance creation'!onMethods: selectorCollection forClass: aClass in: anEnvironment 	| env |	env := self onEnvironment: anEnvironment.	selectorCollection do: [:each | env addClass: aClass selector: each].	^env! !!SelectorEnvironment class methodsFor: 'instance creation'!referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString |	literalPrintString := aLiteral isVariableBinding				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral)						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors isEmpty ifFalse: [classDict at: class put: selectors]].	^(self onEnvironment: anEnvironment) on: classDict;		label: 'References to: ' , literalPrintString;		searchStrings: (Array with: literalPrintString);		yourself! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 4/29/2000 21:41'!checker	"^ self checkerForAllRules"	"^ self checkerForSentNotImplemented"	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule utilityMethods;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'dvf 9/28/2001 22:40'!checkerForAllRules	^ CompositeLintRule rules: (OrderedCollection new addAll: 	(((BlockLintRule class methodDictionary keys asArray select: [:sel | sel 	numArgs == 0]) 	collect: [:sel | BlockLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 addAll: (((ParseTreeLintRule class methodDictionary keys asArray 	select: [:sel | sel numArgs == 0]) 	collect: [:sel | ParseTreeLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:38'!checkerForBugs	^CompositeLintRule ruleFor:BasicLintRule protocol:'bugs'.! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:40'!checkerForSentNotImplemented	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule sentNotImplemented;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:39'!checkerForSpecific	^CompositeLintRule rules:(OrderedCollection new       	        add:BlockLintRule sentNotImplemented;      	        add:BlockLintRule subclassResponsibilityNotDefined;      	        add:BlockLintRule usesTrue ;      	        add:BlockLintRule overridesSpecialMessage;      	        add:ParseTreeLintRule booleanPrecedence ;      	        add:BlockLintRule definesEqualNotHash ;      	        add:BlockLintRule undeclaredReference ;      	        yourself).! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 9/16/2001 22:06'!classes	self needsWork. "for complete testing, be sure to uncomment classesForAllClasses line.  This is very slow though."	^ self classesForAllClasses."	^ self classesForObject.	^ self classesForRefactoryClasses"! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForAllClasses	^ Object withAllSubclasses! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForObject	^ {Object}! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForRefactoryClasses	^ Object withAllSubclasses select: [:class | class theNonMetaClass category asString beginsWith: 'Refactory']! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/12/2000 13:35'!setUp	! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'md 2/27/2006 00:26'!test	| checker context |	checker := self checker.	context := SmalllintContext newNoCache.	checker resetResult.	self classes do: 		[:aClass | 		Transcript show: aClass printString;		 cr.		context selectedClass: aClass.		checker checkClass: context.		aClass methodDictionary keys do: [:each | (ExtraParsingAndFormattingTests methodsNotToTest includes: aClass >> each)				| (each = #DoIt)				ifFalse: 					[context selector: each.					checker checkMethod: context]]].	checker isEmpty ifTrue: ["'Nobody' inspect"].	Transcript cr;cr;cr.	(checker rules select: [:rule | rule result isEmpty not])		do: [:rule | rule result logOrInspect]! !!SharedPool class methodsFor: '*RefactoringEngine' stamp: 'dvf 9/17/2003 03:10'!keys	^self classPool keys! !!SmaCCAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!id	^self subclassResponsibility! !!SmaCCAction methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isReduce	^false! !!SmaCCAction methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isShift	^false! !!SmaCCAcceptAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!id	^2r00! !!SmaCCEdge methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!<= aSmaCCEdge 	^true! !!SmaCCEdge methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!= aSmaCCEdge 	self class = aSmaCCEdge class ifFalse: [^false].	^self to = aSmaCCEdge to and: [self transitionObjects = aSmaCCEdge transitionObjects]! !!SmaCCEdge methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!hash	^(self to hash bitShift: 14) bitXor: transitionObjects hash! !!SmaCCEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!canMergeWith: aSmaCCEdge 	^self class = aSmaCCEdge class! !!SmaCCEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!includes: anObject 	^self does: transitionObjects include: anObject! !!SmaCCEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isCharacterTransition	^false! !!SmaCCEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isEmpty	^transitionObjects isEmpty! !!SmaCCEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isEpsilonTransition	^transitionObjects isNil! !!SmaCCEdge methodsFor: 'private' stamp: ' 6/1/07 21:19'!does: aSequenceableCollection include: anObject 	^aSequenceableCollection includes: anObject! !!SmaCCEdge methodsFor: 'private' stamp: ' 6/1/07 21:19'!remove: aCollection 	transitionObjects := transitionObjects 				reject: [:each | self does: aCollection include: each]! !!SmaCCEdge methodsFor: 'private' stamp: ' 6/1/07 21:19'!transitionObjects	^transitionObjects! !!SmaCCEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!edgeFrequencyUsingTable: frequencyTable 	^0! !!SmaCCEdge methodsFor: 'printing' stamp: ' 6/1/07 21:19'!edgeLabel	^transitionObjects isNil 		ifTrue: ['epsilon']		ifFalse: 			[transitionObjects inject: '' into: [:sum :each | sum , each printString]]! !!SmaCCEdge methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	aStream		nextPutAll: '---';		nextPutAll: self edgeLabel;		nextPutAll: '--->';		nextPutAll: toNode printString! !!SmaCCEdge methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCEdge 	transitionObjects := Array 				withAll: (transitionObjects , aSmaCCEdge transitionObjects) asSet 						asSortedCollection! !!SmaCCEdge methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!to	^toNode! !!SmaCCEdge methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!to: aSmaCCNode 	toNode := aSmaCCNode! !!SmaCCEdge methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!to: aSmaCCNode on: aStringOrNil 	toNode := aSmaCCNode.	transitionObjects := aStringOrNil! !!SmaCCCharacterEdge methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!<= aSmaCCEdge 	^self class = aSmaCCEdge class 		and: [self transitionObjects <= aSmaCCEdge transitionObjects]! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!closestIsExpression	"Attempts to find the #is selector that most closely matches the character set that this edge transitions on."	| expressions closest |	expressions := IsExpressions keys 				select: [:each | each allSatisfy: [:ch | self includes: ch]].	expressions isEmpty ifTrue: [^nil].	closest := IsExpressions 				at: (expressions asSortedCollection: [:a :b | a size > b size]) first.	(self minMaxPairsWithout: closest) size 		<= (self minMaxPairsWithout: nil) size ifFalse: [^nil].	^closest! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!edgeFrequencyUsingTable: frequencyTable 	^self transitionObjects inject: 0		into: [:sum :each | sum + (frequencyTable at: each asInteger \\ frequencyTable size + 1)]! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!expression	| stream isSelector |	stream := WriteStream with: String new.	stream nextPut: $(.	transitionObjects size = SmaCCGrammar maximumCharacterValue 		ifTrue: [self outputInvertedMatchOn: stream]		ifFalse: 			[isSelector := self outputClosestIsMethodOn: stream.			self outputExpressionOn: stream without: isSelector].	stream nextPut: $).	^stream contents! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!minMaxPairsWithout: aSelector 	"Converts a list of characters into a collection of pairs representing the minimum and maximum of each sequence.	The list is first filtered to include only those characters that fail aSelector."	| start last pairs charsLeft |	charsLeft := aSelector isNil 				ifTrue: [transitionObjects]				ifFalse: [transitionObjects reject: [:ch | ch perform: aSelector]].	pairs := OrderedCollection new.	charsLeft isEmpty ifTrue: [^pairs].	last := charsLeft first.	start := nil.	charsLeft do: 			[:each | 			last asInteger + 1 = each asInteger 				ifFalse: 					[start notNil ifTrue: [pairs add: (Array with: start with: last)].					start := each].			last := each].	pairs add: (Array with: start with: last).	^pairs! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputClosestIsMethodOn: aStream 	| expr |	expr := self closestIsExpression.	expr isNil ifFalse: [aStream nextPutAll: 'currentCharacter ' , expr].	^expr! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputExpressionFor: aPair on: aStream 	aPair first = aPair last 		ifTrue: [^self outputMatchSingleCharacter: aPair first on: aStream].	aPair first = (Character value: 0) 		ifTrue: [^self outputMatchLessThan: aPair last on: aStream].	aPair last = (Character value: SmaCCGrammar maximumCharacterValue) 		ifTrue: [^self outputMatchGreaterThan: aPair first on: aStream].	self outputMatchRange: aPair on: aStream! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputExpressionOn: aStream without: aSelector 	| pairs |	pairs := self minMaxPairsWithout: aSelector.	pairs isEmpty ifTrue: [^self].	aSelector notNil ifTrue: [aStream nextPutAll: ' or: ['].	pairs do: [:each | self outputExpressionFor: each on: aStream]		separatedBy: [aStream nextPutAll: ' or: ['].	aStream next: pairs size - 1 put: $].	aSelector notNil ifTrue: [aStream nextPut: $]]! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: 'lr 1/7/2007 11:16'!outputInvertedMatchOn: aStream 	| char |	char := Character value: ((0 to: SmaCCGrammar maximumCharacterValue) 						detect: [:each | (transitionObjects includes: (Character value: each)) not]).	aStream		nextPutAll: 'currentCharacter ~= ';		nextPutAll: char storeString! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputMatchGreaterThan: aCharacter on: aStream 	aStream		nextPutAll: 'currentCharacter >= ';		nextPutAll: aCharacter storeString! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputMatchLessThan: aCharacter on: aStream 	aStream		nextPutAll: 'currentCharacter <= ';		nextPutAll: aCharacter storeString! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!outputMatchRange: aPair on: aStream 	aStream		nextPutAll: '(currentCharacter between: ';		nextPutAll: aPair first storeString;		nextPutAll: ' and: ';		nextPutAll: aPair last storeString;		nextPutAll: ')'! !!SmaCCCharacterEdge methodsFor: 'compiling' stamp: 'lr 1/7/2007 11:16'!outputMatchSingleCharacter: aCharacter on: aStream 	aStream		nextPutAll: 'currentCharacter = ';		nextPutAll: aCharacter storeString! !!SmaCCCharacterEdge methodsFor: 'private' stamp: ' 6/1/07 21:19'!does: aSequenceableCollection include: anObject 	| start stop mid |	(anObject isKindOf: Character) ifFalse: [^false].	start := 1.	stop := aSequenceableCollection size.	stop = 0 ifTrue: [^false].		[mid := (start + stop) // 2.	mid = start] whileFalse: 				[(aSequenceableCollection at: mid) asInteger < anObject asInteger 					ifTrue: [start := mid]					ifFalse: [stop := mid]].	^(aSequenceableCollection at: start) = anObject 		or: [(aSequenceableCollection at: stop) = anObject]! !!SmaCCCharacterEdge methodsFor: 'printing' stamp: ' 6/1/07 21:19'!edgeLabel	^transitionObjects! !!SmaCCCharacterEdge methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isCharacterTransition	^true! !!SmaCCCharacterEdge methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCEdge 	super mergeWith: aSmaCCEdge.	transitionObjects := String withAll: (transitionObjects 						asSortedCollection: [:a :b | a asInteger < b asInteger])! !!SmaCCEdge class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!to: aSmaCCNode on: aCollectionOrNil 	| edge |	edge := self new.	edge to: aSmaCCNode on: aCollectionOrNil.	^edge! !!SmaCCCharacterEdge class methodsFor: 'class initialization' stamp: 'lr 1/6/2007 22:50'!generateCharacterSetFor: aSelector 	| stream |	stream := WriteStream with: String new.	0 to: SmaCCGrammar maximumCharacterValue		do: 			[:i | 			| ch |			ch := Character value: i.			(ch perform: aSelector) ifTrue: [stream nextPut: ch]].	^stream contents! !!SmaCCCharacterEdge class methodsFor: 'class initialization' stamp: 'lr 1/8/2007 23:30'!initializeIsExpressions	"Creates a map from sets of characters to selectors that start with 'is' on Character. This allows generated scanners to take	full advantage of selectors that are already implemented on Character"	IsExpressions := Dictionary new.	"selectors := Character selectors select: 					[:each | 					('is*' match: each) 						and: [each numArgs = 0 and: [(each at: 3) isUppercase]]].	selectors do: 			[:sel | 			| string |			string := self generateCharacterSetFor: sel.			string isEmpty ifFalse: [IsExpressions at: string put: sel]]"! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addEmptySymbol	self addSymbol: SmaCCSymbol empty.	self addSymbol: SmaCCSymbol error! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addStartingSymbol: aSmaCCSymbol 	(otherStartingSymbols includes: aSmaCCSymbol) 		ifFalse: [otherStartingSymbols add: aSmaCCSymbol]! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!allStartingSymbols	"Return all starting symbols with the default starting symbol listed first."	| startingSymbols default |	default := self startSymbol.	startingSymbols := otherStartingSymbols copy.	startingSymbols remove: default ifAbsent: [].	startingSymbols := startingSymbols collect: 					[:each | 					(SmaCCStartingSymbol name: 'B e g i n' , each name)						addProduction: ((SmaCCRHS new)									add: each;									yourself);						yourself].	startingSymbols addFirst: default.	^startingSymbols! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!emptySymbols	^self symbols select: [:each | each isTerminal not and: [each isEmpty]]! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!initialItemSetFor: aSmaCCSymbol 	^(aSmaCCSymbol asLRItemSet)		type: type;		yourself! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!makeGroupFor: aSmaCCRHSCollection 	| symbol name |	name := aSmaCCRHSCollection inject: ''				into: [:sum :each | sum , ' | ' , each printString].	symbol := self nonTerminalSymbolNamed: 'Group: ' , name.	symbol isEmpty 		ifTrue: 			[(aSmaCCRHSCollection allSatisfy: [:each | each size = 1]) 				ifTrue: [aSmaCCRHSCollection do: [:each | each reduceAction: '''1''']].			aSmaCCRHSCollection do: [:each | symbol addProduction: each]].	^symbol! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!makeOptionalSymbolFor: aSmaCCSymbol 	| symbol |	symbol := self nonTerminalSymbolNamed: 'Optional: ' , aSmaCCSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							reduceAction: 'nil';							yourself);				addProduction: ((SmaCCRHS new)							add: aSmaCCSymbol;							reduceAction: '''1''';							yourself)].	^symbol! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!makeRepeatMultipleSymbolFor: aSmaCCSymbol 	| symbol |	symbol := self 				nonTerminalSymbolNamed: 'Repeat Multiple: ' , aSmaCCSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							add: aSmaCCSymbol;							reduceAction: 'OrderedCollection with: ''1''';							yourself);				addProduction: ((SmaCCRHS new)							add: symbol;							add: aSmaCCSymbol;							reduceAction: '''1'' add: ''2''; yourself';							yourself)].	^symbol! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!makeRepeatSymbolFor: aSmaCCSymbol 	| symbol |	symbol := self nonTerminalSymbolNamed: 'Repeat: ' , aSmaCCSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							reduceAction: 'OrderedCollection new';							yourself);				addProduction: ((SmaCCRHS new)							add: symbol;							add: aSmaCCSymbol;							reduceAction: '''1'' add: ''2''; yourself';							yourself)].	^symbol! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!makeTokenIdMethodFor: aString 	| token |	token := (scannerDefinition includesTokenNamed: aString) 				ifTrue: [self terminalSymbolNamed: aString]				ifFalse: 					[symbols detect: [:each | each name = aString]						ifNone: [symbols add: (SmaCCTerminalSymbol name: aString)]].	token createIdMethod: true! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!preferredActionFor: aSmaCCSymbol 	^shiftReduceTable at: aSmaCCSymbol ifAbsent: [nil]! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!setStartSymbolIfNone: aSmaCCSymbol 	| startSymbol |	self startSymbol notNil ifTrue: [^self].	startSymbol := SmaCCStartingSymbol name: 'B e g i n'.	self addSymbol: startSymbol.	startSymbol addProduction: ((SmaCCRHS new)				add: aSmaCCSymbol;				yourself)! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!startSymbol	^symbols detect: [:each | each isStartingSymbol] ifNone: [nil]! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!tokens	^scannerDefinition tokens! !!SmaCCGrammar methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!unusedSymbols	| nonTerminals problemSymbols todo symbol |	nonTerminals := self symbols reject: [:each | each isTerminal].	problemSymbols := nonTerminals asSet.	problemSymbols remove: self startSymbol.	todo := OrderedCollection with: self startSymbol.	[todo isEmpty] whileFalse: 			[symbol := todo removeFirst.			symbol productionsDo: 					[:rhs | 					rhs do: 							[:each | 							each isTerminal 								ifFalse: 									[(problemSymbols includes: each) 										ifTrue: 											[todo add: each.											problemSymbols remove: each]]]]].	^problemSymbols! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!addSymbol: aSmaCCSymbol 	^symbols add: aSmaCCSymbol! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!calculateFirstSets	| changed |	changed := true.	[changed] whileTrue: 			[changed := false.			self symbols 				do: [:each | changed := changed | each calculateFirstTerminals]]! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!keywordRegularExpressionFor: aString 	| regularExpressionString regex |	regularExpressionString := (aString copyFrom: 2 to: aString size - 1) 				copyReplaceAll: '""'				with: '"'.	regex := regularExpressionString inject: nil				into: 					[:sum :each | 					sum isNil 						ifTrue: [SmaCCCharacterRENode characters: (String with: each)]						ifFalse: [sum , (SmaCCCharacterRENode characters: (String with: each))]].	regex addStates: scannerDefinition states.	^regex! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!keywordTerminalNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols addFirst: ((SmaCCTerminalSymbol name: aString)						regularExpression: (self keywordRegularExpressionFor: aString);						yourself)]! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!nonTerminalSymbolNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: [self addSymbol: (SmaCCNonTerminalSymbol name: aString)]! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!reduceTableIndexFor: aSmaCCSymbol rhs: aSmaCCRHS 	| index |	index := 0.	self symbols do: 			[:each | 			each = aSmaCCSymbol ifTrue: [^index + (each positionOf: aSmaCCRHS)].			index := index + each size].	^0! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!symbols	^symbols! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!symbols: aCollection	symbols := aCollection! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!terminalSymbolNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols add: ((SmaCCTerminalSymbol name: aString)						regularExpression: (scannerDefinition tokenNamed: aString);						yourself)]! !!SmaCCGrammar methodsFor: 'private' stamp: ' 6/1/07 21:19'!terminalSymbolNamed: aString ifAbsent: aBlock 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols add: ((SmaCCTerminalSymbol name: aString)						regularExpression: (scannerDefinition tokenNamed: aString									ifAbsentPut: 										[| node |										node := self class implicitToken: aString.										node isNil ifTrue: [^aBlock value].										node addStates: scannerDefinition nonExcludeStates.										node]);						yourself)]! !!SmaCCGrammar methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	type := #LALR1.	symbols := OrderedCollection new.	shiftReduceTable := Dictionary new.	otherStartingSymbols := OrderedCollection new! !!SmaCCGrammar methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!scannerDefinition: aSmaCCScannerDefinition	scannerDefinition := aSmaCCScannerDefinition! !!SmaCCGrammar methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!type: aSmaCCSymbol	type := aSmaCCSymbol! !!SmaCCGrammar methodsFor: 'precedence' stamp: ' 6/1/07 21:19'!leftPrecedenceFor: aSmaCCSymbol 	shiftReduceTable at: aSmaCCSymbol put: SmaCCReduceAction! !!SmaCCGrammar methodsFor: 'precedence' stamp: ' 6/1/07 21:19'!nonAssociativePrecedenceFor: aSmaCCSymbol 	shiftReduceTable at: aSmaCCSymbol put: SmaCCRejectAction! !!SmaCCGrammar methodsFor: 'precedence' stamp: ' 6/1/07 21:19'!rightPrecedenceFor: aSmaCCSymbol 	shiftReduceTable at: aSmaCCSymbol put: SmaCCShiftAction! !!SmaCCGrammar methodsFor: 'precedence' stamp: ' 6/1/07 21:19'!setOperatorPrecedenceFor: aSmaCCSymbol to: anInteger	aSmaCCSymbol precedence: anInteger! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!allCharacters	^String withAll: ((0 to: self maximumCharacterValue) 				collect: [:each | Character value: each])! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!ignoreCase	^IgnoreCase! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!ignoreCase: aBoolean 	IgnoreCase := aBoolean! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!implicitToken: aString 	| symbol node |	symbol := (aString copyFrom: 2 to: aString size - 1) asSymbol.	(Character canUnderstand: symbol) ifFalse: [^nil].	node := SmaCCCharacterRENode 				characters: (self allCharacters select: [:each | each perform: symbol]).	node position: SmallInteger maxVal.	"Implicit nodes have least precedence"	^node! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!maximumCharacterValue	^MaximumCharacterValue! !!SmaCCGrammar class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!maximumCharacterValue: anInteger 	MaximumCharacterValue := anInteger.	SmaCCCharacterEdge initializeIsExpressions! !!SmaCCGrammar class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!initialize	IgnoreCase := false.	self maximumCharacterValue: 255! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!actionForState: anInteger on: aSmaCCSymbol 	| action newStateIndex |	action := (itemSets at: anInteger) action: aSmaCCSymbol				prefer: (grammar preferredActionFor: aSmaCCSymbol).	action isShift 		ifTrue: 			[newStateIndex := shiftTable 						at: (Array with: anInteger with: aSmaCCSymbol).			^(newStateIndex bitShift: 2) + action id].	action isReduce 		ifTrue: 			[^((grammar reduceTableIndexFor: action symbol rhs: action rhs) 				bitShift: 2) + action id].	^action id! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!arrayTypeMask	^self hasLiteralByteArrays ifTrue: [0] ifFalse: [2]! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!compressTable: table 	^table collect: [:row | self compressTableRow: row]! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!compressTableRow: row 	| uniqueItems |	uniqueItems := self uniqueNonErrorActionsForTableRow: row.	^uniqueItems size = 1 		ifTrue: [self singleActionTableRow: row forAction: uniqueItems first]		ifFalse: [self multipleActionTableRow: row]! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!compressedRowStream	^WriteStream with: (self hasLiteralByteArrays 				ifTrue: [ByteArray new]				ifFalse: [Array new])! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!createItemSets	| itemSet newState index |	startingStateMap := Dictionary new.	grammar calculateFirstSets.	itemSets := OrderedCollection new.	grammar allStartingSymbols do: 			[:each | 			itemSets add: (grammar initialItemSetFor: each).			startingStateMap at: each put: itemSets size].	shiftTable := Dictionary new.	index := 1.	[index <= itemSets size] whileTrue: 			[itemSet := itemSets at: index.			grammar symbols do: 					[:each | 					newState := itemSet moveOn: each.					newState notEmpty 						ifTrue: 							[shiftTable at: (Array with: index with: each)								put: (self indexOfState: newState)]].			index := index + 1]! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!createTransitionTable	| table |	table := (1 to: itemSets size) collect: 					[:index | 					scannerCompiler symbols 						collect: [:each | self actionForState: index on: each]].	actions := self compressTable: table! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!indexOfState: newState 	| newStateIndex |	newStateIndex := itemSets indexOf: newState.	newStateIndex = 0 		ifTrue: 			[itemSets add: newState.			newStateIndex := itemSets size]		ifFalse: [(itemSets at: newStateIndex) mergeWith: newState].	^newStateIndex! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!multipleActionTableRow: row 	| stream |	stream := self compressedRowStream.	stream nextPut: 1 + self arrayTypeMask.	row keysAndValuesDo: 			[:index :each | 			each ~= 3 				ifTrue: 					[self writeInteger: each on: stream.					self writeInteger: index on: stream]].	^stream contents! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!singleActionTableRow: row forAction: anInteger 	| stream |	stream := self compressedRowStream.	stream nextPut: 0 + self arrayTypeMask.	self writeInteger: anInteger on: stream.	row 		keysAndValuesDo: [:index :each | each ~= 3 ifTrue: [self writeInteger: index on: stream]].	^stream contents! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!transitionTable	actions isNil 		ifTrue: 			[self createItemSets.			self createTransitionTable].	^actions! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!uniqueNonErrorActionsForTableRow: row 	^(row asSet)		remove: 3 ifAbsent: [];		asArray! !!SmaCCGrammarCompiler methodsFor: 'action table' stamp: ' 6/1/07 21:19'!writeInteger: anInteger on: aStream 	self hasLiteralByteArrays 		ifTrue: 			[aStream				nextPut: (anInteger bitShift: -8);				nextPut: (anInteger bitAnd: 16rFF)]		ifFalse: [aStream nextPut: anInteger]! !!SmaCCGrammarCompiler methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!buildScanner: scannerString andParser: parserString 	| parser |	scannerCompiler grammar: self grammar.	scannerCompiler scannerDefinitionString: scannerString.	parserDefinitionString := parserString.	scannerCompiler parseTokens.	parser := SmaCCGrammarParser on: (ReadStream on: parserString).	parser grammar: grammar.	parser parse! !!SmaCCGrammarCompiler methodsFor: 'initialize-release' stamp: 'lr 1/6/2007 21:55'!initialize	scannerCompiler := SmaCCScannerCompiler new.	model := (RBNamespace new)				name: 'Compile Scanner/Parser';				yourself.	startingStateMap := Dictionary new! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!changes	^model changes! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: 'jws 10/23/2016 05:55'!compileChanges	RefactoryChangeManager instance performChange: self changes.	scannerCompiler scannerClass realClass 		ifNotNilDo: [:each | each initializeKeywordMap]! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileDefinitionComments	scannerCompiler compileScannerDefinitionComment.	self compileParserDefinitionComment! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileInto: sClass andParser: pClass 	self scannerClass: sClass.	self parserClass: pClass.	self createChanges.	self compileChanges! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileItemSetsComment	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'itemSetsComment';		cr;		cr;		tab;		nextPut: $";		cr.	itemSets keysAndValuesDo: 			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: (each printString copyReplaceAll: '"' with: '""');				cr].	stream nextPut: $".	self parserClass metaclass compile: stream contents		classified: #'generated-comments'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileParser	self compileTransitionTable.	self compileStartingStateIds.	self compileReductionTable.	self compileScannerClassIntoParser! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileParserDefinitionComment	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'parserDefinitionComment';		cr;		cr;		tab;		nextPut: $";		nextPutAll: (parserDefinitionString copyReplaceAll: '"' with: '""');		nextPut: $".	parserClass metaclass compile: stream contents		classified: #'generated-comments'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileReductionTable	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'reduceTable';		cr;		tab;		nextPutAll: '^#(';		cr.	self reduceTable do: 			[:each | 			stream nextPutAll: '#('.			each do: [:e | stream nextPutAll: e storeString]				separatedBy: [stream space].			stream				nextPut: $);				cr].	stream nextPut: $).	parserClass compile: stream contents classified: #'generated-tables'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileScanner	scannerCompiler compileScanner! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: 'lr 1/6/2007 22:36'!compileScannerClassIntoParser	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'scannerClass';		cr;		tab;		nextPutAll: '^';		nextPutAll: scannerCompiler scannerClass name.	self parserClass metaclass compile: stream contents		classified: #'generated-accessing'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileStartingStateIds	startingStateMap keysAndValuesDo: 			[:symbol :position | 			| stream |			stream := WriteStream with: String new.			stream				nextPutAll: 'startingStateFor';				nextPutAll: symbol compileName;				cr;				tab;				nextPutAll: '^';				nextPutAll: position printString.			parserClass metaclass compile: stream contents				classified: #'generated-starting states']! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileSymbolComment	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'symbolComment';		cr;		cr;		tab;		nextPut: $";		cr.	scannerCompiler symbols keysAndValuesDo: 			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: '. ';				nextPutAll: (each printString copyReplaceAll: '"' with: '""');				cr].	stream nextPut: $".	self parserClass metaclass compile: stream contents		classified: #'generated-comments'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileTransitionTable	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'transitionTable';		cr;		tab;		nextPutAll: '^#(';		cr.	self transitionTable do: 			[:each | 			stream 				nextPutAll: (self hasLiteralByteArrays ifTrue: ['#['] ifFalse: ['#(']).			each do: [:byte | stream nextPutAll: byte printString]				separatedBy: [stream nextPut: $ ].			stream				nextPut: (self hasLiteralByteArrays ifTrue: [$]] ifFalse: [$)]);				cr].	stream nextPut: $).	parserClass compile: stream contents classified: #'generated-tables'! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!createChanges	self removeOldMethods.	self checkForEmptySymbols.	self checkForUnusedSymbols.	self compileScanner.	self compileParser! !!SmaCCGrammarCompiler methodsFor: 'compiling' stamp: 'jws 10/30/2016 22:55'!defineClass: aString asSubclassOf: aBehavior	model defineClass: aBehavior name , ' subclass: #' , aString , ' instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: ''generated'' '.	^model classNamed: aString asSymbol! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: 'lr 1/7/2007 11:08'!checkFor: problemSymbols errorMessage: errorMessage 	| stream |	problemSymbols isEmpty ifTrue: [^self].	stream := WriteStream with: String new.	problemSymbols do: [:each | stream nextPutAll: each printString]		separatedBy: [stream space].	SmaCCCompilationNotification new		tag: stream contents;		signal: errorMessage! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: ' 6/1/07 21:19'!checkForEmptySymbols	self checkFor: grammar emptySymbols		errorMessage: 'Missing non-terminal productions'! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: ' 6/1/07 21:19'!checkForUnusedSymbols	self checkFor: grammar unusedSymbols		errorMessage: 'Unused non-terminal symbols'! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: ' 6/1/07 21:19'!generatedMethodsIn: aRBClass 	^aRBClass selectors select: 			[:each | 			(aRBClass protocolsFor: each) 				allSatisfy: [:protocol | protocol notNil and: ['generated*' match: protocol]]]! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: ' 6/1/07 21:19'!removeOldMethods	self		removeOldMethodsFrom: scannerCompiler scannerClass;		removeOldMethodsFrom: scannerCompiler scannerClass metaclass;		removeOldMethodsFrom: parserClass;		removeOldMethodsFrom: parserClass metaclass! !!SmaCCGrammarCompiler methodsFor: 'private' stamp: 'jws 10/30/2016 22:48'!removeOldMethodsFrom: aRBClass 	(self generatedMethodsIn: aRBClass) 		do: [:each | aRBClass removeMethod: each]! !!SmaCCGrammarCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!grammar	^grammar isNil ifTrue: [grammar := SmaCCGrammar new] ifFalse: [grammar]! !!SmaCCGrammarCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!parserClass	^parserClass! !!SmaCCGrammarCompiler methodsFor: 'accessing' stamp: 'jws 10/30/2016 22:59'!parserClass: aClassOrString 	(aClassOrString isKindOf: Behavior) 		ifTrue: [parserClass := model classFor: aClassOrString]		ifFalse: 			[parserClass := model classNamed: aClassOrString.			parserClass isNil 				ifTrue: [parserClass := self defineClass: aClassOrString asSubclassOf: SmaCCParser]]! !!SmaCCGrammarCompiler methodsFor: 'accessing' stamp: 'jws 10/30/2016 22:59'!scannerClass: aClassOrString 	(aClassOrString isKindOf: Behavior) 		ifTrue: [scannerCompiler scannerClass: (model classFor: aClassOrString)]		ifFalse:			[scannerCompiler scannerClass: (model classNamed: aClassOrString).			scannerCompiler scannerClass isNil 				ifTrue: 					[scannerCompiler 						scannerClass: (self defineClass: aClassOrString asSubclassOf: SmaCCScanner)]]! !!SmaCCGrammarCompiler methodsFor: 'testing' stamp: 'lr 1/8/2007 11:05'!hasLiteralByteArrays	^ false! !!SmaCCGrammarCompiler methodsFor: 'reduction table' stamp: ' 6/1/07 21:19'!reduceTable	| table nonterminals |	table := OrderedCollection new.	nonterminals := scannerCompiler symbols reject: [:each | each isTerminal].	nonterminals do: 			[:each | 			each productionsDo: 					[:rhs | 					table add: (Array 								with: (scannerCompiler symbols indexOf: each)								with: rhs size								with: (rhs compileSourceFor: each in: parserClass))]].	^table! !!SmaCCGrammarCompiler class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!new	^self basicNew initialize! !!SmaCCGraphAlgorithm methodsFor: 'nodes' stamp: ' 6/1/07 21:19'!createMergedNodeFrom: nodeCollection 	| newNode |	newNode := SmaCCNode new.	self mergeTransitionsFrom: nodeCollection into: newNode.	self mergeActionsFrom: nodeCollection into: newNode.	^newNode! !!SmaCCGraphAlgorithm methodsFor: 'nodes' stamp: ' 6/1/07 21:19'!mergeActionsFrom: nodeCollection into: aSmaCCNode 	nodeCollection do: [:each | aSmaCCNode addActions: each action]! !!SmaCCGraphAlgorithm methodsFor: 'nodes' stamp: ' 6/1/07 21:19'!mergeTransitionsFrom: nodeCollection into: aSmaCCNode 	| transitions |	transitions := Set new.	nodeCollection 		do: [:each | each transitions do: [:edge | transitions add: edge copy]].	aSmaCCNode transitions: transitions.	aSmaCCNode mergeTransitions! !!SmaCCGraphAlgorithm methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!isNode: firstSmaCCNode equivalentTo: secondSmaCCNode 	| firstTransitions secondTransitions |	firstSmaCCNode = secondSmaCCNode ifTrue: [^true].	firstSmaCCNode transitions size = secondSmaCCNode transitions size 		ifFalse: [^false].	firstSmaCCNode action = secondSmaCCNode action ifFalse: [^false].	((comparisonState at: firstSmaCCNode ifAbsent: [#()]) 		includes: secondSmaCCNode) ifTrue: [^true].	(comparisonState at: firstSmaCCNode ifAbsentPut: [Set new]) 		add: secondSmaCCNode.	(comparisonState at: secondSmaCCNode ifAbsentPut: [Set new]) 		add: firstSmaCCNode.	firstTransitions := firstSmaCCNode transitions 				asSortedCollection: [:a :b | a transitionObjects first <= b transitionObjects first].	secondTransitions := secondSmaCCNode transitions 				asSortedCollection: [:a :b | a transitionObjects first <= b transitionObjects first].	firstTransitions with: secondTransitions		do: 			[:first :second | 			first transitionObjects = second transitionObjects ifFalse: [^false].			(self isNode: first to equivalentTo: second to) ifFalse: [^false]].	^true! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!mergeAllTransitions	root allStates do: [:each | each mergeTransitions]! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!pairsDo: aBlock 	| nodes |	nodes := root allStates asOrderedCollection.	1 to: nodes size - 1		do: 			[:i | 			i + 1 to: nodes size				do: [:j | aBlock value: (nodes at: i) value: (nodes at: j)]]! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!removeDuplicateNodesIn: aSmaCCNode 	root := aSmaCCNode.	self removeDuplicates.	^root! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm' stamp: 'lr 1/8/2007 22:44'!removeDuplicates	| changed iterations |	changed := true.	iterations := root allStates size.	[changed and: [iterations > 0]] whileTrue: 			[changed := false.			iterations := iterations - 1.			self mergeAllTransitions.			self pairsDo: 					[:firstNode :secondNode | 					comparisonState := Dictionary new.					(self isNode: firstNode equivalentTo: secondNode) 						ifTrue: 							[firstNode mergeWith: secondNode.							changed := true]]]! !!SmaCCDuplicateNodeEliminator class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!removeDuplicateNodesIn: aSmaCCNode 	^self new removeDuplicateNodesIn: aSmaCCNode! !!SmaCCEpsilonRemoval methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!createNodeWithoutEpsilonEdges: aSmaCCNode 	| newNode newTransitions |	newNode := self 				createMergedNodeFrom: (self epsilonReachableNodesFrom: aSmaCCNode).	nodeMap at: aSmaCCNode put: newNode.	newTransitions := OrderedCollection new.	newNode transitions do: 			[:each | 			each isEpsilonTransition 				ifFalse: 					[newTransitions add: (each class to: (self removeEpsilonEdgesFrom: each to)								on: each transitionObjects)]].	newNode transitions: newTransitions.	^newNode! !!SmaCCEpsilonRemoval methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!epsilonReachableNodesFrom: aSmaCCNode 	| todo reachable node |	reachable := Set with: aSmaCCNode.	todo := OrderedCollection with: aSmaCCNode.	[todo notEmpty] whileTrue: 			[node := todo removeLast.			node transitions do: 					[:each | 					(each isEpsilonTransition and: [(reachable includes: each to) not]) 						ifTrue: 							[reachable add: each to.							todo add: each to]]].	^reachable! !!SmaCCEpsilonRemoval methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!removeEpsilonEdgesFrom: aSmaCCNode 	^nodeMap at: aSmaCCNode		ifAbsent: [self createNodeWithoutEpsilonEdges: aSmaCCNode]! !!SmaCCEpsilonRemoval methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	super initialize.	nodeMap := Dictionary new! !!SmaCCEpsilonRemoval class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!removeEpsilonEdgesFrom: aSmaCCNode 	"Returns an equivalent graph to aSmaCCNode that doesn't contain any epsilon transitions"	^self new removeEpsilonEdgesFrom: aSmaCCNode! !!SmaCCItemSet methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!= aSmaCCItemSet 	self class = aSmaCCItemSet class 		ifTrue: 			[type == #LALR1				ifTrue: [^self isLALREqualTo: aSmaCCItemSet]				ifFalse: [^self isLREqualTo: aSmaCCItemSet]].	^false! !!SmaCCItemSet methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!hash	^self inject: self class hash into: [:sum :each | sum bitXor: each hash]! !!SmaCCItemSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!action: aSmaCCSymbol prefer: aClass 	| action actionItem eachAction |	action := SmaCCRejectAction new.	self do: 			[:each | 			eachAction := each action: aSmaCCSymbol.			action class = SmaCCRejectAction 				ifTrue: 					[action := eachAction.					actionItem := each]				ifFalse: 					[(eachAction = action or: [eachAction class = SmaCCRejectAction]) 						ifFalse: 							[eachAction class = SmaCCShiftAction | (action class = SmaCCShiftAction) 								ifTrue: 									["Shift/Reduce conflict -- check precedence"									(aSmaCCSymbol precedence isNil 										or: [each precedence isNil or: [actionItem precedence isNil]]) 											ifTrue: 												["No precedence, choose shift"												eachAction class = SmaCCShiftAction 													ifTrue: 														[self 															raiseXReduceNotification: each															with: actionItem															type: 'Shift/Reduce Conflict'.														action := eachAction.														actionItem := each]													ifFalse: 														[self 															raiseXReduceNotification: actionItem															with: each															type: 'Shift/Reduce Conflict']]											ifFalse: 												[(each precedence > actionItem precedence 													or: [each precedence = actionItem precedence and: [eachAction class = aClass]]) 														ifTrue: 															[self 																raiseXReduceNotification: each																with: actionItem																type: 'Shift/Reduce Conflict (handled by precedence rules)'.															action := eachAction.															actionItem := each]														ifFalse: 															[(each precedence = actionItem precedence and: [SmaCCRejectAction = aClass]) 																ifTrue: 																	[self 																		raiseXReduceNotificationWithNoPreferredItem: actionItem																		with: each																		type: 'Shift/Reduce Conflict (handled by precedence rules)'.																	^aClass new]																ifFalse: 																	[self 																		raiseXReduceNotification: actionItem																		with: each																		type: 'Shift/Reduce Conflict (handled by precedence rules)']]]]								ifFalse: 									["Reduce/Reduce conflict -- just pick one and proceed"									self 										raiseXReduceNotification: actionItem										with: each										type: 'Reduce/Reduce Conflict']]]].	^action! !!SmaCCItemSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCItemSet 	self == aSmaCCItemSet ifTrue: [^self].	aSmaCCItemSet do: [:each | self add: each]! !!SmaCCItemSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!moveOn: aSmaCCSymbol 	| anItemSet |	anItemSet := self class new.	anItemSet type: type.	self 		do: [:each | each nextSymbol == aSmaCCSymbol ifTrue: [anItemSet add: each moveNext]].	^anItemSet! !!SmaCCItemSet methodsFor: 'accessing' stamp: 'lr 1/7/2007 11:06'!raiseXReduceNotification: preferredSmaCCLR1Item with: otherSmaCCLR1Item type: aString 	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: preferredSmaCCLR1Item printString;		nextPutAll: '	*****';		cr;		nextPutAll: otherSmaCCLR1Item printString.	SmaCCCompilationNotification new		tag: stream contents;		signal: aString! !!SmaCCItemSet methodsFor: 'accessing' stamp: 'lr 1/7/2007 11:07'!raiseXReduceNotificationWithNoPreferredItem: firstSmaCCLR1Item with: secondSmaCCLR1Item type: aString 	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: firstSmaCCLR1Item printString;		cr;		nextPutAll: secondSmaCCLR1Item printString.	SmaCCCompilationNotification new		tag: stream contents;		signal: aString! !!SmaCCItemSet methodsFor: 'adding' stamp: 'lr 1/6/2007 22:24'!add: aSmaCCLR1Item 	| index item |	aSmaCCLR1Item == nil ifTrue: [^aSmaCCLR1Item].	index := self findElementOrNil: aSmaCCLR1Item.	item := array at: index.	item == nil 		ifTrue: 			[self atNewIndex: index put: aSmaCCLR1Item.			self performClosureOn: aSmaCCLR1Item]		ifFalse: [item mergeWith: aSmaCCLR1Item].	^aSmaCCLR1Item! !!SmaCCItemSet methodsFor: 'copying' stamp: ' 6/1/07 21:19'!copyEmpty: anInteger 	^(super copyEmpty: anInteger)		type: type;		yourself! !!SmaCCItemSet methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	(self class superclass canUnderstand: #initialize) 		ifTrue: [super initialize].	type := #LALR1! !!SmaCCItemSet methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!type: aSmaCCSymbol 	type := aSmaCCSymbol! !!SmaCCItemSet methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isLALREqualTo: aSmaCCItemSet 	^aSmaCCItemSet size = self size 		and: [self allSatisfy: [:each | aSmaCCItemSet includes: each]]! !!SmaCCItemSet methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isLREqualTo: anItemSet 	^anItemSet size = self size and: 			[self allSatisfy: 					[:each | 					| item |					(item := anItemSet itemFor: each) notNil and: [each isLR1EqualTo: item]]]! !!SmaCCItemSet methodsFor: 'private' stamp: 'lr 1/6/2007 22:24'!itemFor: anObject 	^array at: (self findElementOrNil: anObject)! !!SmaCCItemSet methodsFor: 'private' stamp: ' 6/1/07 21:19'!performClosureOn: aSmaCCLR1Item 	| nextSymbol rest first followers |	nextSymbol := aSmaCCLR1Item nextSymbol.	nextSymbol isTerminal ifTrue: [^self].	rest := aSmaCCLR1Item rest.	first := rest firstTerminals.	followers := SmaCCSymbolSet new.	(first includes: SmaCCSymbol empty) 		ifTrue: 			[first remove: SmaCCSymbol empty.			followers baseOn: aSmaCCLR1Item followers].	followers addAll: first.	nextSymbol productionsDo: 			[:each | 			self add: (SmaCCLR1Item 						symbol: nextSymbol						rhs: each						follow: followers)]! !!SmaCCItemSet methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	self do: 			[:each | 			aStream				tab;				nextPutAll: each printString;				cr]! !!SmaCCItemSet class methodsFor: 'instance creation' stamp: 'lr 1/6/2007 22:47'!new: anInteger 	^(super new: anInteger)		initialize;		yourself! !!SmaCCLR1Item methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!= aSmaCCLR1Item 	^self class == aSmaCCLR1Item class and: 			[location = aSmaCCLR1Item location 				and: [rhs == aSmaCCLR1Item rhs and: [symbol == aSmaCCLR1Item symbol]]]! !!SmaCCLR1Item methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!hash	^(symbol identityHash bitXor: (location bitShift: 14)) 		bitXor: rhs identityHash! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!action: aSmaCCSymbol 	location > rhs size 		ifTrue: 			[(symbol isStartingSymbol and: [aSmaCCSymbol isEmptySymbol]) 				ifTrue: [^SmaCCAcceptAction new].			(followers includes: aSmaCCSymbol) 				ifTrue: [^SmaCCReduceAction symbol: symbol rhs: rhs]]		ifFalse: [(rhs at: location) = aSmaCCSymbol ifTrue: [^SmaCCShiftAction new]].	^SmaCCRejectAction new! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!followers	^followers! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCLR1Item 	followers mergeWith: aSmaCCLR1Item followers! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!moveNext	^(self copy)		followers: (followers class basedOn: followers);		location: location + 1;		yourself! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!nextSymbol	^location > rhs size 		ifTrue: [SmaCCSymbol sentinel]		ifFalse: [rhs at: location]! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!precedence	"If we don't have a precedence, then assume we are the lowest precedence (which will cause a shift action)."	| max |	max := -1.	rhs do: [:each | max := max max: (each precedence ifNil: [max])].	^max! !!SmaCCLR1Item methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!rest	| newRHS |	newRHS := SmaCCRHS new.	location + 1 to: rhs size do: [:each | newRHS add: (rhs at: each)].	^newRHS! !!SmaCCLR1Item methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!followers: aSmaCCSymbolSet 	followers := aSmaCCSymbolSet! !!SmaCCLR1Item methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!location: anInteger 	location := anInteger! !!SmaCCLR1Item methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!symbol: aSmaCCSymbol rhs: aSmaCCRHS follow: aSmaCCSymbolCollection 	symbol := aSmaCCSymbol.	rhs := aSmaCCRHS.	location := 1.	followers := aSmaCCSymbolCollection! !!SmaCCLR1Item methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isLR1EqualTo: aSmaCCLR1Item 	^self followers size = aSmaCCLR1Item followers size 		and: [self followers allSatisfy: [:each | aSmaCCLR1Item followers includes: each]]! !!SmaCCLR1Item methodsFor: 'private' stamp: ' 6/1/07 21:19'!location	^location! !!SmaCCLR1Item methodsFor: 'private' stamp: ' 6/1/07 21:19'!rhs	^rhs! !!SmaCCLR1Item methodsFor: 'private' stamp: ' 6/1/07 21:19'!symbol	^symbol! !!SmaCCLR1Item methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	| i |	aStream		nextPut: $[;		nextPutAll: symbol printString;		nextPutAll: ' :'.	i := 1.	rhs do: 			[:each | 			i = location ifTrue: [aStream nextPutAll: ' . '].			aStream				space;				nextPutAll: each printString.			i := i + 1].	location > rhs size ifTrue: [aStream nextPutAll: ' . '].	aStream nextPut: $;.	followers printOn: aStream.	aStream nextPut: $]! !!SmaCCLR1Item class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!symbol: aSmaCCSymbol rhs: aSmaCCRHS follow: aSmaCCSymbolCollection 	^(self new)		symbol: aSmaCCSymbol			rhs: aSmaCCRHS			follow: aSmaCCSymbolCollection;		yourself! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!atEnd	^sourceStream atEnd! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isReadable	^sourceStream isReadable! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isWritable	^sourceStream isWritable! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!columnNumber	^self columnNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!columnNumberFor: anInteger 	^anInteger - (eolPositions at: (self lineNumberFor: anInteger)) + 1! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!contents	^sourceStream contents! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!flush	^sourceStream flush! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumber	^self lineNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumberFor: anInteger	| index start stop pos |	pos := anInteger.	pos >= eolPositions last ifTrue: [^eolPositions size].	start := 1.	stop := eolPositions size.	[start + 1 < stop] whileTrue: 			[index := (start + stop) // 2.			(eolPositions at: index) <= pos 				ifTrue: [start := index]				ifFalse: [stop := index]].	^start! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!next	| character streamPosition |	character := sourceStream next.	streamPosition := sourceStream position.	streamPosition - 1 >= lastPosition 		ifTrue: 			[lastPosition := streamPosition.			character == Character cr 				ifTrue: 					[eolPositions add: lastPosition.					previousWasCR := true]				ifFalse: 					[character == Character lf 						ifTrue: 							[previousWasCR 								ifTrue: [eolPositions at: eolPositions size put: lastPosition]								ifFalse: [eolPositions add: lastPosition]].					previousWasCR := false]].	^character! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!nextPut: anObject 	^sourceStream nextPut: anObject! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!peek	^sourceStream peek! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^sourceStream position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position: anInteger 	anInteger > lastPosition 		ifTrue: 			[sourceStream position: lastPosition.			[sourceStream position < anInteger and: [sourceStream atEnd not]] 				whileTrue: [self next]]		ifFalse: [sourceStream position: anInteger]! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!skip: anInteger	^self position: self position + anInteger! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: 'lr 1/6/2007 20:56'!upTo: aCharacter 	| stream char |	stream := WriteStream on: String new.	[self atEnd or: [ (char := self next) = aCharacter]] 		whileFalse: [stream nextPut: char].	^ stream contents! !!SmaCCLineNumberStream methodsFor: 'error handling' stamp: ' 6/1/07 20:34'!doesNotUnderstand: aMessage 	^sourceStream perform: aMessage selector withArguments: aMessage arguments! !!SmaCCLineNumberStream methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!on: aReadStream 	sourceStream := aReadStream.	eolPositions := OrderedCollection with: aReadStream position.	lastPosition := aReadStream position.	previousWasCR := false! !!SmaCCLineNumberStream class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aReadStream 	^(self basicNew)		on: aReadStream;		yourself! !!SmaCCNFAtoDFA methodsFor: 'private-edges' stamp: ' 6/1/07 21:19'!commonTransitionObjectsForEdges: edgeCollection 	^edgeCollection inject: edgeCollection first transitionObjects		into: [:sum :each | sum select: [:char | each includes: char]]! !!SmaCCNFAtoDFA methodsFor: 'private-edges' stamp: ' 6/1/07 21:19'!createEdgeMerging: conflictingEdgeCollection 	| newNode common newEdge |	newNode := self 				mergedNodeFor: (conflictingEdgeCollection collect: [:each | each to]).	common := self commonTransitionObjectsForEdges: conflictingEdgeCollection.	newEdge := conflictingEdgeCollection first class to: newNode on: common.	conflictingEdgeCollection do: [:each | each remove: common].	^newEdge! !!SmaCCNFAtoDFA methodsFor: 'private-edges' stamp: ' 6/1/07 21:19'!setTransitionsOn: aSmaCCNode to: edgeCollection 	aSmaCCNode transitions: (edgeCollection reject: [:each | each isEmpty]).	aSmaCCNode transitions do: [:each | each to: (self convertToDFA: each to)]! !!SmaCCNFAtoDFA methodsFor: 'private-edges' stamp: ' 6/1/07 21:19'!someDuplicateIn: edgeCollection 	| objects |	objects := Set new.	edgeCollection do: 			[:edge | 			edge transitionObjects do: [:each | (objects includes: each) ifTrue: [^each]].			objects addAll: edge transitionObjects].	^nil! !!SmaCCNFAtoDFA methodsFor: 'algorithm' stamp: ' 6/1/07 21:19'!convertToDFA: aSmaCCNode 	^self mergedNodeFor: (Array with: aSmaCCNode)! !!SmaCCNFAtoDFA methodsFor: 'private-merging nodes' stamp: ' 6/1/07 21:19'!eliminateDuplicateTransitionsIn: aSmaCCNode 	| newTransitions conflictingObject |	newTransitions := aSmaCCNode transitions collect: [:each | each copy].		[conflictingObject := self someDuplicateIn: newTransitions.	conflictingObject notNil] 			whileTrue: 				[| conflictingEdges newEdge |				conflictingEdges := newTransitions 							select: [:each | each includes: conflictingObject].				newEdge := self createEdgeMerging: conflictingEdges.				newTransitions add: newEdge].	self setTransitionsOn: aSmaCCNode to: newTransitions! !!SmaCCNFAtoDFA methodsFor: 'private-merging nodes' stamp: ' 6/1/07 21:19'!mergedNodeFor: nodeCollection 	| mergedNodes |	mergedNodes := nodeCollection asSortedCollection asArray.	^mergedStates at: mergedNodes		ifAbsent: 			[| newNode |			newNode := self createMergedNodeFrom: mergedNodes.			mergedStates				at: mergedNodes put: newNode;				at: (Array with: newNode) put: newNode.			self eliminateDuplicateTransitionsIn: newNode.			newNode]! !!SmaCCNFAtoDFA methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	super initialize.	mergedStates := Dictionary new! !!SmaCCNFAtoDFA class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!convertToDFA: aSmaCCNode 	"Returns an equivalent DFA from the NFA specified by aSmaCCNode -- the NFA must not contain epsilon edges."	^self new convertToDFA: aSmaCCNode! !!SmaCCNode methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!<= aSmaCCNode 	^self id <= aSmaCCNode id! !!SmaCCNode methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!= anObject 	^self class = anObject class and: [self id = anObject id]! !!SmaCCNode methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!hash	^id bitShift: 4! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!action	^action! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!addActions: aCollection 	aCollection isNil ifTrue: [^self].	action isNil 		ifTrue: 			[action := aCollection copy.			^self].	action isSymbol ifTrue: [^self].	aCollection isSymbol ifTrue: [^action := aCollection].	aCollection 		do: [:each | (action includes: each) ifFalse: [action add: each]]! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!allStates	| nodes |	nodes := Set new.	self allStatesInto: nodes.	^nodes! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!allStatesInto: aSet 	(aSet includes: self) ifTrue: [^self].	aSet add: self.	transitions do: [:each | each to allStatesInto: aSet]! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!groupedTransitions	^transitions inject: OrderedCollection new		into: 			[:sum :each | 			(sum detect: [:edgeCollection | edgeCollection first canMergeWith: each]				ifNone: [sum add: OrderedCollection new]) add: each.			sum]! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!id	^id! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!mergeTransitions	self groupedTransitions do: 			[:edges | 			| toMap |			toMap := Dictionary new.			edges do: 					[:each | 					(toMap includesKey: each to) 						ifTrue: 							[(toMap at: each to) mergeWith: each.							transitions remove: each]						ifFalse: [toMap at: each to put: each]]]! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCNode 	id := aSmaCCNode id.	transitions := aSmaCCNode transitions.	action := aSmaCCNode action! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!removeDuplicateNodes	^SmaCCDuplicateNodeEliminator removeDuplicateNodesIn: self! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!startingNodeWithoutUnnecessaryDefaultTransition	| edge |	self transitions size = 1 ifFalse: [^self].	edge := self transitions first.	(edge includes: #default) ifTrue: [^edge to].	^self! !!SmaCCNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!transitions	^transitions! !!SmaCCNode methodsFor: 'private' stamp: 'lr 1/6/2007 22:08'!transitions: aCollection 	transitions reset.	transitions addAll: aCollection! !!SmaCCNode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!action: anObject 	anObject isNil ifTrue: [^self].	action := anObject isSymbol 				ifTrue: [anObject]				ifFalse: [SortedCollection with: anObject]! !!SmaCCNode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	id := NextId := NextId + 1.	transitions := SortedCollection new! !!SmaCCNode methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!actionForSpecificRegularExpression: aSmaCCRegularExpression 	| matchedAction strings |	strings := aSmaCCRegularExpression possibleMatches.	matchedAction := self simulate: (ReadStream on: strings first).	strings 		do: [:each | matchedAction = (self simulate: (ReadStream on: each)) ifFalse: [^nil]].	^matchedAction! !!SmaCCNode methodsFor: 'edges' stamp: ' 6/1/07 21:19'!addEdgeTo: aSmaCCNode 	transitions add: (SmaCCEdge to: aSmaCCNode on: nil)! !!SmaCCNode methodsFor: 'edges' stamp: ' 6/1/07 21:19'!addEdgeTo: aSmaCCNode onCharacters: characterCollection 	transitions add: (SmaCCCharacterEdge to: aSmaCCNode on: characterCollection)! !!SmaCCNode methodsFor: 'edges' stamp: ' 6/1/07 21:19'!addEdgeTo: aSmaCCNode onStates: symbolCollection 	transitions add: (SmaCCStateEdge to: aSmaCCNode on: symbolCollection)! !!SmaCCNode methodsFor: 'compiling' stamp: 'lr 1/7/2007 11:22'!addImplementationSpecificRewritesTo: rewriter! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!asStatement: methodMap usingSelectorMap: aDictionary forClass: aClass 	| stream |	stream := WriteStream with: String new.	self hasSimpleLoop ifTrue: [stream nextPut: $[].	self writeMatchingCodeOn: stream usingSelectorMap: aDictionary.	(self sortedTransitionsFor: aClass) do: 			[:each | 			each to = self 				ifTrue: 					[stream						nextPutAll: each expression;						nextPut: $];						nextPutAll: ' whileTrue.';						cr]				ifFalse: 					[stream						nextPutAll: each expression;						nextPutAll: ' ifTrue: ['.					stream						nextPutAll: (methodMap at: each to									ifAbsentPut: 										[each to 											asStatement: methodMap											usingSelectorMap: aDictionary											forClass: aClass]);						nextPutAll: '].';						cr]].	(transitions notEmpty or: [action isNil]) 		ifTrue: 			[stream				nextPutAll: '^self reportLastMatch';				cr].	^stream contents! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!compileInto: aClass usingSelectorMap: aDictionary 	| methodNodes methodMap index |	methodNodes := self statesToMakeIntoMethods.	methodMap := self methodNameMapFor: methodNodes.	index := 0.	methodNodes do: 			[:each | 			| stream |			stream := WriteStream with: String new.			stream				nextPutAll: (each = self 							ifTrue: ['scanForToken']							ifFalse: ['scan' , (index := index + 1) printString]);				cr.			stream nextPutAll: (each 						asStatement: methodMap						usingSelectorMap: aDictionary						forClass: aClass).			aClass 				compile: (self optimizedParseTreeFor: stream contents) formattedCode				classified: #'generated-scanner']! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!methodNameMapFor: methodNodes 	| index methodMap |	methodMap := Dictionary new.	index := 0.	methodNodes do: 			[:value | 			methodMap at: value				put: (value = self 						ifTrue: ['^self scanForToken']						ifFalse: ['^self scan' , (index := index + 1) printString])].	^methodMap! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!needsSeparateMethod	^self allStates size > MaxSubNodesInMethod! !!SmaCCNode methodsFor: 'compiling' stamp: 'jws 10/23/2016 05:54'!optimizationRewriter	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3].				`@.Stmts4'			with: '`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3';		replaceMethod: '`name							`@.Stmts1.							`@a ifTrue: [	^self `name].							`@.Stmts3'			with: '`name				[`@.Stmts1.				`@a] whileTrue.				`@.Stmts3';		replaceMethod: '`name							`@.Stmts1.							`@a ifTrue: [`@.Stmts2.									^self `name].							`@.Stmts3'			with: '`name				[`@.Stmts1.				`@a] whileTrue: [`@.Stmts2].				`@.Stmts3';		replace: '`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with: '`@.Stmts1.				`@.Stmts2';		replace: '`@.Stmts1.				`.Stmt.				`@.Stmts.				`@a ifTrue: [self step. `.Stmt. `@.Stmts].				`@.Stmts2'			with: '`@.Stmts1.				`@a ifTrue: [self step].				`.Stmt.				`@.Stmts.				`@.Stmts2';		replace: '`@.Stmts1.				`@a ifTrue: [`@.Stmts. ^self reportLastMatch]'			with: '`@.Stmts1.				`@a ifTrue: [`@.Stmts]'.	self addImplementationSpecificRewritesTo: rewriter.	^rewriter! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!optimizedParseTreeFor: aString 	| tree rewriter |	tree := RBParser parseMethod: aString.	rewriter := self optimizationRewriter.	[rewriter executeTree: tree] whileTrue: [tree := rewriter tree].	^tree! !!SmaCCNode methodsFor: 'compiling' stamp: 'lr 1/6/2007 22:10'!sortedTransitionsFor: aClass 	| frequencies |	frequencies := (aClass realClass ifNil: [SmaCCScanner]) frequencyTable.	^transitions asSortedCollection: 			[:a :b | 			| aFrequency bFrequency |			aFrequency := a edgeFrequencyUsingTable: frequencies.			bFrequency := b edgeFrequencyUsingTable: frequencies.			aFrequency > bFrequency or: [aFrequency = bFrequency and: [a <= b]]]! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!statesToMakeIntoMethods	| allStates incoming |	allStates := self allStates.	incoming := Dictionary new.	allStates do: 			[:each | 			each transitions do: 					[:edge | 					each ~= edge to 						ifTrue: [(incoming at: edge to ifAbsentPut: [Set new]) add: each]]].	^(allStates asOrderedCollection select: 			[:each | 			self = each or: 					[each isTerminalNode not and: 							[(incoming at: each ifAbsent: [#()]) size > 1 								or: [each needsSeparateMethod]]]]) 		asSortedCollection: [:a :b | a id < b id]! !!SmaCCNode methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!writeMatchingCodeOn: aStream usingSelectorMap: aDictionary 	| matchedItem |	(action notNil and: [action size > 0]) 		ifTrue: 			[matchedItem := aDictionary at: action first ifAbsent: [action asArray].			aStream nextPutAll: (transitions isEmpty 						ifTrue: ['^self recordAndReportMatch:']						ifFalse: ['self recordMatch: ']).			matchedItem isSymbol 				ifTrue: [aStream nextPutAll: matchedItem storeString]				ifFalse: 					[aStream nextPutAll: '#('.					matchedItem do: [:each | aStream nextPutAll: each storeString]						separatedBy: [aStream nextPut: $ ].					aStream nextPut: $)].			aStream				nextPut: $.;				cr].	(transitions anySatisfy: [:each | each isCharacterTransition]) 		ifTrue: 			[aStream				nextPutAll: 'self step.';				cr]! !!SmaCCNode methodsFor: 'converting' stamp: ' 6/1/07 21:19'!asDFA	| new |	new := (SmaCCNFAtoDFA convertToDFA: self asNFAWithoutEpsilonTransitions) 				startingNodeWithoutUnnecessaryDefaultTransition.	new removeDuplicateNodes.	^new! !!SmaCCNode methodsFor: 'converting' stamp: ' 6/1/07 21:19'!asNFAWithoutEpsilonTransitions	^SmaCCEpsilonRemoval removeEpsilonEdgesFrom: self! !!SmaCCNode methodsFor: 'testing' stamp: ' 6/1/07 21:19'!hasSimpleLoop	^transitions anySatisfy: [:each | each to = self]! !!SmaCCNode methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isTerminalNode	^transitions isEmpty or: [transitions size = 1 and: [self hasSimpleLoop]]! !!SmaCCNode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: id printString;		nextPut: $)! !!SmaCCNode methodsFor: 'simulating' stamp: ' 6/1/07 21:19'!simulate: aStream 	| char |	aStream atEnd ifTrue: [^action].	char := aStream next.	transitions 		do: [:each | (each includes: char) ifTrue: [^each to simulate: aStream]].	^nil! !!SmaCCNode class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!initialize	NextId := 0.	MaxSubNodesInMethod := 20! !!SmaCCNode class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!maxSubNodesInMethod	^MaxSubNodesInMethod! !!SmaCCNode class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!maxSubNodesInMethod: anInteger	MaxSubNodesInMethod := anInteger! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!acceptAction	^0! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionFor: aSymbolIndex 	^self actionForState: self currentState and: aSymbolIndex! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionForCurrentToken	^self actionFor: currentToken id first! !!SmaCCParser methodsFor: 'private' stamp: 'lr 1/8/2007 11:19'!actionForState: stateIndex and: aSymbolIndex 	| index row |	row := self transitionTable at: stateIndex.	^(row at: 1) == 2 		ifTrue: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 1.			index == 0 ifTrue: [^self errorAction] ifFalse: [^row at: 2]]		ifFalse: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 2.			index == 0 ifTrue: [^self errorAction] ifFalse: [^row at: index - 1]]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionMask	^2r11! !!SmaCCParser methodsFor: 'private'!binarySearchIn: aRow for: aSymbolIndex size: step 	| start mid length midItem stop |	start := 3.	stop := aRow size.	length := (stop - start) // step.	[length > 4] whileTrue: 			[length := length bitShift: -1.			mid := length * step + start.			midItem := aRow at: mid.			midItem <= aSymbolIndex ifTrue: [start := mid] ifFalse: [stop := mid]].	[start <= stop] whileTrue: 			[(aRow at: start) == aSymbolIndex ifTrue: [^start].			start := start + step].	^0! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!currentState	^stateStack last! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!errorAction	^3! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!findErrorHandlerIfNoneUseErrorNumber: anInteger 	| handlerStates index startingErrorToken newStack |	handlerStates := self errorHandlerStates reverse.	startingErrorToken := currentToken.		[index := (1 to: handlerStates size) detect: 					[:each | 					| state |					state := handlerStates at: each.					state ~= 0 and: 							[newStack := stateStack copyFrom: 1 to: handlerStates size - each + 1.							newStack add: state.							self willShift: newStack]]				ifNone: [nil].	index isNil] 			whileTrue: 				[self dismissErrorToken.				self isEOFToken 					ifTrue: 						[currentToken := startingErrorToken.						self reportError: anInteger]].	index - 1 timesRepeat: [self dismissStackTopForErrorRecovery].	stateStack addLast: (handlerStates at: index).	nodeStack addLast: startingErrorToken! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!getNextToken	currentToken isNil ifTrue: [currentToken := scanner next]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performAction: action 	| value actionType |	actionType := action bitAnd: self actionMask.	value := action bitShift: -2.	actionType == self shiftAction 		ifTrue: [self shift: value]		ifFalse: 			[actionType == self reduceAction 				ifTrue: [self reduce: value]				ifFalse: [self handleError: value]]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performParsingLoop	| action |		[self getNextToken.	action := self actionForCurrentToken.	action = self acceptAction] 			whileFalse: [self performAction: action].	self checkForErrors! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performReduceMethod: aSymbol with: items 	^aSymbol last == $: 		ifTrue: [self perform: aSymbol with: items]		ifFalse: [self perform: aSymbol]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduce: anInteger 	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := OrderedCollection new: (size := reduceEntry at: 2).	size timesRepeat: 			[items addFirst: nodeStack removeLast.			stateStack removeLast].	nodeStack add: (self performReduceMethod: (reduceEntry at: 3) with: items).	stateStack add: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduceAction	^2r10! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduceFor: aCollection 	| newCollection item |	(aCollection allSatisfy: [:each | each class ~~ OrderedCollection]) 		ifTrue: [^aCollection].	aCollection first class == OrderedCollection 		ifTrue: 			[newCollection := aCollection first.			2 to: aCollection size				do: 					[:i | 					item := aCollection at: i.					item class = OrderedCollection 						ifTrue: [newCollection addAll: item]						ifFalse: [newCollection add: item]].			^newCollection].	newCollection := OrderedCollection new.	aCollection do: 			[:each | 			each class == OrderedCollection 				ifTrue: [newCollection addAll: each]				ifFalse: [newCollection add: each]].	^newCollection! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!setDefaultStartingStateIfNone	stateStack isNil 		ifTrue: [self setStartingState: self class defaultStartingState]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!shift: stateIndex 	stateStack add: stateIndex.	nodeStack add: currentToken.	currentToken := nil! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!shiftAction	^2r01! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we don't 	want to return the result, so we raise a final exception that can't be proceeded."	errorToken isNil ifTrue: [^self].	currentToken := errorToken.	self reportErrorMessage: 'Token not expected'! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!dismissErrorToken	currentToken := nil.	self getNextToken! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!dismissStackTopForErrorRecovery	stateStack removeLast.	^nodeStack removeLast! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!errorHandlerStates	^stateStack collect: 			[:each | 			| action |			action := self actionForState: each and: self errorTokenId.			(action bitAnd: self actionMask) = 1 				ifTrue: [action bitShift: -2]				ifFalse: [0]]! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!handleError: anInteger 	errorToken isNil ifTrue: [errorToken := currentToken].	(self isEOFToken or: [self hasErrorHandler not]) 		ifTrue: [self reportError: anInteger].	self findErrorHandlerIfNoneUseErrorNumber: anInteger! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!hasErrorHandler	^self errorHandlerStates anySatisfy: [:each | each ~~ 0]! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!reportError: anInteger 	self reportErrorMessage: (anInteger = 0 				ifTrue: ['Token not expected']				ifFalse: [self errorTable at: anInteger])! !!SmaCCParser methodsFor: 'private-error handling' stamp: 'lr 1/6/2007 22:43'!reportErrorMessage: aString 	SmaCCParserError new 		tag: self;		signal: aString! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!willShift: potentialStateStack 	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last				and: currentToken id first.	action := compoundAction bitAnd: self actionMask.	action == self shiftAction ifTrue: [^true].	action == self reduceAction 		ifTrue: 			[reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [potentialStateStack removeLast].			potentialStateStack 				add: ((self actionForState: potentialStateStack last						and: (reduceEntry at: 1)) bitShift: -2).			^self willShift: potentialStateStack].	^false! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!emptySymbolTokenId	^scanner emptySymbolTokenId! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTable	^#()! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTokenId	^scanner errorTokenId! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse	self setDefaultStartingStateIfNone.	self performParsingLoop.	^nodeStack last! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^currentToken isNil 		ifTrue: [scanner position]		ifFalse: [currentToken startPosition]! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!reduceTable	^self subclassResponsibility! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!scanner	^scanner! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!transitionTable	^self subclassResponsibility! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!initialize	nodeStack := OrderedCollection new! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!scanner: aScanner 	scanner := aScanner! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!setStartingState: startingState 	stateStack := OrderedCollection with: startingState! !!SmaCCParser methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isEOFToken	^currentToken id first = self emptySymbolTokenId! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftFirstValue: aCollection 	^aCollection first! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftLastValue: aCollection 	^aCollection last! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftSecondValue: aCollection 	^aCollection at: 2! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!nil	^nil! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!stringValue: anOrderedCollection 	^anOrderedCollection first value! !!CParser methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!addTypeName: aString 	scanner addTypeName: aString! !!CParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:13'!reduceActionForenumXspecifier2: nodes 	self addTypeName: (nodes at: 2) value.	^ self reduceFor: nodes! !!CParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:13'!reduceActionForenumXspecifier3: nodes 	self addTypeName: (nodes at: 2) value.	^ self reduceFor: nodes! !!CParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:13'!reduceActionForstructXorXunionXspecifier1: nodes 	self addTypeName: (nodes at: 2) value.	^ self reduceFor: nodes! !!CParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:13'!reduceActionForstructXorXunionXspecifier3: nodes 	self addTypeName: (nodes at: 2) value.	^ self reduceFor: nodes! !!CParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:13'!reduceTable	^#(#(84 1 #reduceFor:)#(84 4 #reduceFor:)#(84 3 #reduceFor:)#(84 4 #reduceFor:)#(84 3 #reduceFor:)#(84 3 #reduceFor:)#(84 2 #reduceFor:)#(84 2 #reduceFor:)#(85 1 #reduceFor:)#(85 1 #reduceFor:)#(85 1 #reduceFor:)#(85 3 #reduceFor:)#(86 1 #reduceFor:)#(86 3 #reduceFor:)#(87 1 #reduceFor:)#(87 3 #reduceFor:)#(88 1 #reduceFor:)#(88 2 #reduceFor:)#(88 2 #reduceFor:)#(88 2 #reduceFor:)#(88 2 #reduceFor:)#(88 4 #reduceFor:)#(89 1 #reduceFor:)#(89 1 #reduceFor:)#(89 1 #reduceFor:)#(89 1 #reduceFor:)#(89 1 #reduceFor:)#(89 1 #reduceFor:)#(90 1 #reduceFor:)#(90 4 #reduceFor:)#(91 1 #reduceFor:)#(91 2 #reduceFor:)#(92 1 #reduceFor:)#(92 3 #reduceFor:)#(92 3 #reduceFor:)#(92 3 #reduceFor:)#(93 1 #reduceFor:)#(93 3 #reduceFor:)#(93 3 #reduceFor:)#(94 1 #reduceFor:)#(94 3 #reduceFor:)#(94 3 #reduceFor:)#(95 1 #reduceFor:)#(95 3 #reduceFor:)#(95 3 #reduceFor:)#(95 3 #reduceFor:)#(95 3 #reduceFor:)#(96 1 #reduceFor:)#(96 3 #reduceFor:)#(96 3 #reduceFor:)#(97 1 #reduceFor:)#(97 3 #reduceFor:)#(98 1 #reduceFor:)#(98 3 #reduceFor:)#(99 1 #reduceFor:)#(99 3 #reduceFor:)#(100 1 #reduceFor:)#(100 3 #reduceFor:)#(101 1 #reduceFor:)#(101 3 #reduceFor:)#(102 1 #reduceFor:)#(102 5 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(104 1 #reduceFor:)#(105 1 #reduceFor:)#(105 2 #reduceFor:)#(105 1 #reduceFor:)#(105 2 #reduceFor:)#(105 1 #reduceFor:)#(105 2 #reduceFor:)#(106 1 #reduceFor:)#(106 3 #reduceFor:)#(107 2 #reduceFor:)#(107 3 #reduceFor:)#(108 1 #reduceFor:)#(108 1 #reduceFor:)#(108 1 #reduceFor:)#(108 1 #reduceFor:)#(108 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(109 1 #reduceFor:)#(110 1 #reduceFor:)#(110 1 #reduceFor:)#(111 1 #reduceFor:)#(111 3 #reduceFor:)#(112 2 #reduceFor:)#(112 1 #reduceFor:)#(113 1 #reduceFor:)#(113 1 #reduceFor:)#(114 5 #reduceActionForstructXorXunionXspecifier1:)#(114 4 #reduceFor:)#(114 2 #reduceActionForstructXorXunionXspecifier3:)#(115 4 #reduceFor:)#(115 5 #reduceActionForenumXspecifier2:)#(115 2 #reduceActionForenumXspecifier3:)#(116 1 #reduceFor:)#(116 1 #reduceFor:)#(117 1 #reduceFor:)#(118 1 #reduceFor:)#(118 2 #reduceFor:)#(119 1 #reduceFor:)#(119 3 #reduceFor:)#(120 3 #reduceFor:)#(121 2 #reduceFor:)#(121 1 #reduceFor:)#(121 2 #reduceFor:)#(121 1 #reduceFor:)#(122 1 #reduceFor:)#(122 3 #reduceFor:)#(123 1 #reduceFor:)#(123 2 #reduceFor:)#(123 3 #reduceFor:)#(124 1 #reduceFor:)#(124 3 #reduceFor:)#(125 1 #reduceFor:)#(125 3 #reduceFor:)#(126 1 #reduceFor:)#(126 2 #reduceFor:)#(126 2 #reduceFor:)#(126 3 #reduceFor:)#(127 1 #reduceFor:)#(127 3 #reduceFor:)#(127 4 #reduceFor:)#(127 3 #reduceFor:)#(127 4 #reduceFor:)#(127 4 #reduceFor:)#(127 3 #reduceFor:)#(128 1 #reduceFor:)#(128 3 #reduceFor:)#(129 1 #reduceFor:)#(129 3 #reduceFor:)#(130 1 #reduceFor:)#(130 2 #reduceFor:)#(131 1 #reduceFor:)#(131 3 #reduceFor:)#(133 2 #reduceFor:)#(133 2 #reduceFor:)#(133 1 #reduceFor:)#(134 1 #reduceFor:)#(134 1 #reduceFor:)#(134 2 #reduceFor:)#(135 3 #reduceFor:)#(135 2 #reduceFor:)#(135 3 #reduceFor:)#(135 3 #reduceFor:)#(135 4 #reduceFor:)#(135 2 #reduceFor:)#(135 3 #reduceFor:)#(135 3 #reduceFor:)#(135 4 #reduceFor:)#(136 1 #reduceFor:)#(136 3 #reduceFor:)#(137 3 #reduceFor:)#(137 4 #reduceFor:)#(137 3 #reduceFor:)#(138 2 #reduceFor:)#(138 3 #reduceFor:)#(138 3 #reduceFor:)#(138 4 #reduceFor:)#(139 1 #reduceFor:)#(139 2 #reduceFor:)#(140 5 #reduceFor:)#(140 7 #reduceFor:)#(140 5 #reduceFor:)#(141 5 #reduceFor:)#(141 7 #reduceFor:)#(141 6 #reduceFor:)#(141 7 #reduceFor:)#(142 3 #reduceFor:)#(142 2 #reduceFor:)#(142 2 #reduceFor:)#(142 2 #reduceFor:)#(142 3 #reduceFor:)#(143 1 #reduceFor:)#(143 1 #reduceFor:)#(143 1 #reduceFor:)#(143 1 #reduceFor:)#(143 1 #reduceFor:)#(143 1 #reduceFor:)#(144 1 #reduceFor:)#(144 2 #reduceFor:)#(145 1 #reduceFor:)#(145 2 #reduceFor:)#(146 4 #reduceFor:)#(146 3 #reduceFor:)#(146 3 #reduceFor:)#(146 2 #reduceFor:)#(149 1 #reduceFor:)#(149 2 #reduceFor:)#(150 1 #reduceFor:)#(150 3 #reduceFor:)#(150 4 #reduceFor:))! !!CParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:13'!transitionTable	^#(#(3 9 25 13 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 93 76 97 105 101 107 105 108 109 109 113 110 117 112 121 113 125 114 129 115 133 116 137 126 141 127 145 132 149 146 153 149)#(3 9 25 13 34 93 76 157 112 137 126 141 127)#(3 550 21 550 25 550 26 13 34 17 40 21 41 550 76 550 79 161 110 165 126 169 130)#(2 410 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 414 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 466 76 81)#(2 470 76 81)#(3 173 76 177 81)#(2 390 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 394 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 342 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 346 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 350 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 354 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 378 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 382 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 370 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 374 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 386 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 358 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 362 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 366 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 566 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(3 9 25 13 34 181 60 93 76 185 106 189 111 193 112 137 126 141 127)#(2 438 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 302 21 302 25 302 26 302 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 302 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 302 76 302 79 197 105 105 108 109 109 113 110 125 114 129 115 133 116 145 132)#(3 310 21 310 25 310 26 310 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 310 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 310 76 310 79 201 105 105 108 109 109 113 110 125 114 129 115 133 116 145 132)#(3 318 21 318 25 318 26 318 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 318 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 318 76 318 79 205 105 105 108 109 109 113 110 125 114 129 115 133 116 145 132)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 209 81 213 105 217 107 105 108 109 109 113 110 125 114 129 115 133 116 145 132 221 138 225 145)#(2 834 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(2 398 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 402 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(3 229 76 233 81)#(3 9 25 93 76 237 127)#(3 430 16 430 17 430 21 241 25 430 26 430 40 430 41 430 43 430 44 430 45 430 51 430 55 430 57 430 58 430 60 430 61 430 65 430 66 430 67 430 68 430 69 430 70 430 71 430 72 430 73 245 79 430 81 430 132)#(2 406 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 434 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 9 25 13 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 93 76 97 105 101 107 105 108 109 109 113 110 117 112 249 113 125 114 129 115 133 116 137 126 141 127 145 132 149 146 0 147)#(2 253 26)#(2 610 21 25 26 34 40 41 76 79)#(2 558 21 25 26 76 79)#(3 554 21 554 25 554 26 13 34 17 40 21 41 554 76 554 79 257 110 261 126)#(3 462 16 462 21 462 25 462 26 462 34 462 40 462 41 462 43 462 44 462 45 462 51 462 55 462 57 462 58 462 60 462 61 462 65 462 66 462 67 462 68 462 69 462 70 462 71 462 72 462 73 462 76 462 79 265 81 462 132)#(3 269 76 273 124 277 125)#(2 334 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(3 281 21 285 60)#(2 326 21 60)#(3 289 17 418 21 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 418 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 209 81 213 105 217 107 105 108 109 109 113 110 125 114 129 115 133 116 145 132 293 138 297 145)#(2 306 21 25 26 34 60 76 79)#(2 314 21 25 26 34 60 76 79)#(2 322 21 25 26 34 60 76 79)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 17 40 21 41 349 42 25 43 29 44 33 45 353 47 357 48 361 49 365 50 37 51 369 52 373 53 377 54 41 55 381 56 45 57 49 58 385 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 389 76 393 77 397 78 209 81 401 82 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 213 105 217 107 105 108 109 109 113 110 125 114 129 115 133 116 473 119 145 132 477 137 481 138 485 139 489 140 493 141 497 142 501 143 505 144 509 145)#(3 9 25 13 34 181 60 93 76 185 106 189 111 513 112 137 126 141 127)#(2 810 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132)#(2 830 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 209 81 213 105 517 107 105 108 109 109 113 110 125 114 129 115 133 116 145 132 521 138)#(3 450 16 450 21 450 25 450 26 450 34 450 40 450 41 450 43 450 44 450 45 450 51 450 55 450 57 450 58 450 60 450 61 450 65 450 66 450 67 450 68 450 69 450 70 450 71 450 72 450 73 450 76 450 79 525 81 450 132)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 529 109 533 110 125 114 129 115 133 116 537 118 541 120 545 121 145 132)#(3 426 16 426 17 426 21 241 25 426 26 426 40 426 41 426 43 426 44 426 45 426 51 426 55 426 57 426 58 426 60 426 61 426 65 426 66 426 67 426 68 426 69 426 70 426 71 426 72 426 73 245 79 426 81 426 132)#(3 549 26 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 553 76 557 105 105 108 109 109 113 110 125 114 129 115 133 116 561 128 565 129 569 131 145 132 573 133)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 581 80 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 593 104 473 119)#(2 838 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(2 570 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(2 614 21 25 26 34 40 41 76 79)#(2 562 21 25 26 76 79)#(3 269 76 597 124 277 125)#(3 601 17 542 21 542 82)#(3 605 21 609 82)#(2 534 21 82)#(3 9 25 13 34 93 76 613 111 513 112 137 126 141 127)#(2 338 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 617 81 405 84 409 85 621 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119 625 150)#(2 822 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 209 81 213 105 517 107 105 108 109 109 113 110 125 114 129 115 133 116 145 132 629 138)#(3 301 20 305 23 309 24 633 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 637 88 421 89)#(3 301 20 305 23 309 24 633 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 641 88 421 89)#(3 301 20 305 23 309 24 645 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 649 88 421 89)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 653 91 429 92 433 93 437 94 441 95 445 96 449 97 657 98 457 99 461 100 465 101 469 102 529 109 533 110 125 114 129 115 133 116 473 119 661 121 145 132)#(2 94 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 110 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 114 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 98 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 102 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 106 20 23 24 25 28 31 32 34 35 36 76 77 78)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 665 104 473 119)#(2 669 16)#(2 673 25)#(2 677 60)#(2 681 60)#(2 685 25)#(2 689 76)#(2 693 25)#(2 697 25)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 701 143)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 705 60 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 709 98 457 99 461 100 465 101 469 102 473 119)#(2 722 20 23 24 25 26 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 38 1 38 2 38 3 38 4 38 5 38 6 38 7 38 8 38 9 38 10 38 11 38 12 38 13 38 14 38 15 713 16 38 17 38 18 38 19 38 20 38 21 38 22 38 23 38 25 38 27 38 28 38 29 38 30 38 33 38 34 38 35 38 36 38 37 38 59 38 60 38 62 38 63 38 64 38 79)#(2 42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 46 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 706 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(3 70 1 70 2 70 3 70 4 70 5 70 6 70 7 70 8 70 9 70 10 70 11 70 12 70 13 70 14 70 15 70 16 70 17 70 18 70 19 717 20 70 21 721 22 725 23 729 25 70 26 733 27 70 28 70 29 70 30 70 33 70 34 70 35 70 36 70 37 70 59 70 60 70 62 70 63 70 64 737 79 70 80 70 82)#(2 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 214 16 21 26 60 80)#(3 118 1 118 2 118 3 118 4 118 5 118 6 118 7 118 8 118 9 741 10 745 11 749 12 753 13 118 14 118 15 118 16 757 17 118 18 761 19 118 21 118 26 118 28 118 29 118 30 118 33 118 34 118 35 118 36 765 37 769 59 118 60 773 62 777 63 781 64 118 80 118 82 785 103)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 789 90)#(2 134 1 2 3 4 5 6 7 8 9 14 15 16 18 21 26 28 29 30 33 34 35 36 60 80 82)#(3 150 1 150 2 150 3 150 4 150 5 150 6 150 7 150 8 150 9 150 14 150 15 150 16 150 18 150 21 150 26 150 28 793 29 797 30 150 33 801 34 150 35 150 36 150 60 150 80 150 82)#(3 162 1 162 2 162 3 162 4 162 5 162 6 162 7 162 8 162 9 162 14 162 15 162 16 162 18 162 21 162 26 162 28 162 33 805 35 809 36 162 60 162 80 162 82)#(3 174 1 174 2 174 3 174 4 174 5 174 6 174 7 174 8 174 9 813 14 174 15 174 16 174 18 174 21 174 26 174 28 817 33 174 60 174 80 174 82)#(3 194 1 194 2 194 3 194 4 194 5 821 6 825 7 829 8 194 9 194 15 194 16 833 18 194 21 194 26 194 28 194 60 194 80 194 82)#(3 206 1 206 2 837 3 841 4 206 5 206 9 206 15 206 16 206 21 206 26 206 28 206 60 206 80 206 82)#(3 486 1 486 2 486 5 486 9 486 15 486 16 486 21 486 26 845 28 486 60 486 80 486 82)#(3 849 21 853 60)#(3 857 2 230 5 230 9 230 15 230 16 230 21 230 26 230 60 230 80 230 82)#(3 861 5 238 9 238 15 238 16 238 21 238 26 238 60 238 80 238 82)#(3 865 9 869 15 246 16 246 21 246 26 246 60 246 80 246 82)#(2 62 16 21 26 60 80 82)#(3 873 1 222 2 222 5 222 9 222 15 222 16 222 21 222 26 222 60 222 80 222 82)#(2 778 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 782 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 786 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 790 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 794 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 798 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 802 20 23 24 25 28 31 32 34 35 36 38 39 42 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 877 82 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 881 143)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 17 40 21 41 349 42 25 43 29 44 33 45 353 47 357 48 361 49 365 50 37 51 369 52 373 53 377 54 41 55 381 56 45 57 49 58 385 60 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 389 76 393 77 397 78 209 81 885 82 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 213 105 517 107 105 108 109 109 113 110 125 114 129 115 133 116 473 119 145 132 477 137 481 138 485 139 489 140 493 141 497 142 501 143 889 144)#(3 289 17 418 21 418 60)#(2 814 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132)#(2 826 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 529 109 533 110 125 114 129 115 133 116 893 118 541 120 545 121 145 132)#(3 502 16 502 25 502 26 502 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 502 76 502 79 529 109 533 110 125 114 129 115 133 116 897 121 145 132)#(3 510 16 510 25 510 26 510 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 510 76 510 79 529 109 533 110 125 114 129 115 133 116 901 121 145 132)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 905 82 529 109 533 110 125 114 129 115 133 116 909 120 545 121 145 132)#(2 478 40 41 43 44 45 51 55 66 67 68 69 70 72 73 82 132)#(3 913 16 9 25 13 34 93 76 917 112 921 122 925 123 137 126 141 127)#(2 590 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(2 602 21 26)#(3 634 21 929 25 634 26 13 34 93 76 933 79 937 112 941 126 141 127 945 134 949 135)#(2 953 26)#(3 957 21 961 26)#(3 965 21 594 26)#(2 618 21 26)#(2 38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 578 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(2 118 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(2 298 16 21 60 80 82)#(2 969 80)#(3 605 21 973 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 977 104 473 119)#(3 269 76 981 125)#(2 454 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 330 21 60)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 617 81 405 84 409 85 621 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119 985 136 989 150)#(2 842 21 60 82)#(2 422 21 60)#(2 818 25 34 40 41 43 44 45 51 55 57 58 61 65 66 67 68 69 70 71 72 73 76 132 147)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 657 98 457 99 461 100 465 101 469 102 473 119)#(2 78 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(2 74 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 993 91 429 92 433 93 437 94 441 95 445 96 449 97 657 98 457 99 461 100 465 101 469 102 529 109 533 110 125 114 129 115 133 116 473 119 661 121 145 132)#(2 86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(2 997 26)#(3 849 21 1001 26)#(3 1005 25 126 26 13 34 933 79 1009 126 1013 134 949 135)#(2 1017 16)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1021 143)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1025 98 457 99 461 100 465 101 469 102 473 119)#(2 762 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 766 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 385 60 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 1029 139)#(2 1033 60)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1037 98 457 99 461 100 465 101 469 102 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1041 98 457 99 461 100 465 101 469 102 473 119)#(2 1045 53)#(2 770 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 849 21 1049 60)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1053 143)#(2 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 1057 76)#(2 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(3 301 20 305 23 309 24 313 25 1061 26 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 1065 86 1069 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119)#(2 1073 76)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1077 98 457 99 461 100 465 101 469 102 473 119)#(2 266 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 270 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 258 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 262 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 254 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 274 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 278 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 294 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 282 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 286 20 23 24 25 28 31 32 34 35 36 76 77 78)#(2 290 20 23 24 25 28 31 32 34 35 36 76 77 78)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 1081 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119)#(2 82 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 1085 90)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 1089 90)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 1093 90)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 1097 92)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 1101 92)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 1105 93)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 1109 93)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 1113 94)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 1117 94)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 1121 94)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 1125 94)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 1129 95)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 1133 95)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 1137 96)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 1141 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119)#(2 726 20 23 24 25 26 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1145 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1149 99 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 1153 100 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1157 98 457 99 461 100 465 101 469 102 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 1161 97)#(2 710 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(2 806 20 23 24 25 28 31 32 34 35 36 38 39 42 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 714 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 1165 82 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 881 143)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 61 66 65 67 69 68 73 69 77 70 85 72 89 73 1169 82 529 109 533 110 125 114 129 115 133 116 909 120 545 121 145 132)#(2 498 16 25 26 34 76 79)#(2 506 16 25 26 34 76 79)#(2 446 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 482 40 41 43 44 45 51 55 66 67 68 69 70 72 73 82 132)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 1173 104 473 119)#(3 1177 16 522 21 522 60)#(3 1181 21 1185 60)#(2 514 21 60)#(3 929 25 1189 26 13 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 93 76 933 79 557 105 105 108 109 109 113 110 157 112 125 114 129 115 133 116 941 126 141 127 1193 128 569 131 145 132 573 133 1197 134 949 135)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 1201 80 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 1205 104 473 119)#(2 626 21 26)#(3 638 21 929 25 638 26 93 76 933 79 237 127 1209 135)#(2 630 21 26)#(3 642 21 1213 25 642 26 1217 79)#(2 582 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(2 1221 76)#(2 586 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(3 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 1225 74 557 105 105 108 109 109 113 110 125 114 129 115 133 116 145 132 1229 133)#(2 574 16 17 21 25 26 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 79 81 132)#(2 458 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 546 21 82)#(2 538 21 82)#(3 1233 21 1237 82)#(2 686 21 82)#(2 1241 26)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 1245 90)#(2 50 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(3 1005 25 1189 26 13 34 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 933 79 557 105 105 108 109 109 113 110 125 114 129 115 133 116 1009 126 1193 128 569 131 145 132 573 133 1197 134 949 135)#(3 1005 25 638 26 933 79 1209 135)#(2 130 26)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1249 143)#(2 702 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 849 21 1253 26)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 385 60 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 1257 139)#(2 758 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 849 21 1261 26)#(3 849 21 1265 26)#(2 1269 25)#(2 774 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 694 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(3 1273 21 1277 26)#(2 54 21 26)#(2 22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(3 849 21 1281 80)#(2 66 16 21 26 60 80 82)#(2 142 1 2 3 4 5 6 7 8 9 14 15 16 18 21 26 28 29 30 33 34 35 36 60 80 82)#(2 146 1 2 3 4 5 6 7 8 9 14 15 16 18 21 26 28 29 30 33 34 35 36 60 80 82)#(2 138 1 2 3 4 5 6 7 8 9 14 15 16 18 21 26 28 29 30 33 34 35 36 60 80 82)#(3 154 1 154 2 154 3 154 4 154 5 154 6 154 7 154 8 154 9 154 14 154 15 154 16 154 18 154 21 154 26 154 28 793 29 797 30 154 33 801 34 154 35 154 36 154 60 154 80 154 82)#(3 158 1 158 2 158 3 158 4 158 5 158 6 158 7 158 8 158 9 158 14 158 15 158 16 158 18 158 21 158 26 158 28 793 29 797 30 158 33 801 34 158 35 158 36 158 60 158 80 158 82)#(3 170 1 170 2 170 3 170 4 170 5 170 6 170 7 170 8 170 9 170 14 170 15 170 16 170 18 170 21 170 26 170 28 170 33 805 35 809 36 170 60 170 80 170 82)#(3 166 1 166 2 166 3 166 4 166 5 166 6 166 7 166 8 166 9 166 14 166 15 166 16 166 18 166 21 166 26 166 28 166 33 805 35 809 36 166 60 166 80 166 82)#(3 182 1 182 2 182 3 182 4 182 5 182 6 182 7 182 8 182 9 813 14 182 15 182 16 182 18 182 21 182 26 182 28 817 33 182 60 182 80 182 82)#(3 186 1 186 2 186 3 186 4 186 5 186 6 186 7 186 8 186 9 813 14 186 15 186 16 186 18 186 21 186 26 186 28 817 33 186 60 186 80 186 82)#(3 190 1 190 2 190 3 190 4 190 5 190 6 190 7 190 8 190 9 813 14 190 15 190 16 190 18 190 21 190 26 190 28 817 33 190 60 190 80 190 82)#(3 178 1 178 2 178 3 178 4 178 5 178 6 178 7 178 8 178 9 813 14 178 15 178 16 178 18 178 21 178 26 178 28 817 33 178 60 178 80 178 82)#(3 198 1 198 2 198 3 198 4 198 5 821 6 825 7 829 8 198 9 198 15 198 16 833 18 198 21 198 26 198 28 198 60 198 80 198 82)#(3 202 1 202 2 202 3 202 4 202 5 821 6 825 7 829 8 202 9 202 15 202 16 833 18 202 21 202 26 202 28 202 60 202 80 202 82)#(3 210 1 210 2 837 3 841 4 210 5 210 9 210 15 210 16 210 21 210 26 210 28 210 60 210 80 210 82)#(2 218 16 21 26 60 80)#(3 873 1 226 2 226 5 226 9 226 15 226 16 226 21 226 26 226 60 226 80 226 82)#(3 857 2 234 5 234 9 234 15 234 16 234 21 234 26 234 60 234 80 234 82)#(3 861 5 242 9 242 15 242 16 242 21 242 26 242 60 242 80 242 82)#(3 1285 16 849 21)#(3 490 1 490 2 490 5 490 9 490 15 490 16 490 21 490 26 845 28 490 60 490 80 490 82)#(2 718 20 23 24 25 28 31 32 34 35 36 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 60 61 65 66 67 68 69 70 71 72 73 76 77 78 81 82 132 147)#(2 442 16 21 25 26 34 40 41 43 44 45 51 55 57 58 60 61 65 66 67 68 69 70 71 72 73 76 79 132)#(2 526 21 60)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 1289 104 473 119)#(3 913 16 9 25 13 34 93 76 917 112 1293 123 137 126 141 127)#(2 494 40 41 43 44 45 51 55 66 67 68 69 70 72 73 82 132)#(2 670 21 25 26 79)#(2 1297 26)#(2 1301 26)#(2 654 21 25 26 79)#(2 1305 80)#(3 646 21 1213 25 646 26 1217 79)#(3 1309 26 17 40 21 41 25 43 29 44 33 45 37 51 41 55 45 57 49 58 53 61 57 65 61 66 65 67 69 68 73 69 77 70 81 71 85 72 89 73 557 105 105 108 109 109 113 110 125 114 129 115 133 116 1313 128 569 131 145 132 573 133)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 1317 80 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 589 102 1321 104 473 119)#(2 606 21 26)#(2 598 26)#(2 622 21 26)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 617 81 1325 82 405 84 409 85 621 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119 1329 150)#(2 846 21 60 82)#(2 90 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(2 122 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 26 28 29 30 33 34 35 36 37 59 60 62 63 64 80 82)#(2 698 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1333 143)#(3 301 20 305 23 309 24 313 25 1337 26 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1341 98 457 99 461 100 465 101 469 102 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1345 143)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1349 143)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 1353 98 457 99 461 100 465 101 469 102 473 119)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 1357 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 469 102 473 119)#(2 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(2 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 33 34 35 36 37 59 60 62 63 64 79 80 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 577 76 393 77 397 78 405 84 409 85 585 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 457 99 461 100 465 101 1361 102 473 119)#(2 530 21 60)#(2 518 21 60)#(2 674 21 25 26 79)#(2 650 21 25 26 79)#(2 658 21 25 26 79)#(2 678 21 25 26 79)#(2 1365 26)#(2 662 21 25 26 79)#(2 1369 80)#(2 850 21 60 82)#(2 690 21 82)#(3 730 20 730 23 730 24 730 25 730 28 730 31 730 32 730 34 730 35 730 36 730 38 730 39 730 42 1373 46 730 47 730 48 730 49 730 50 730 52 730 53 730 54 730 56 730 60 730 76 730 77 730 78 730 81 730 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1377 143)#(3 849 21 1381 26)#(2 738 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 742 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 849 21 1385 26)#(2 58 21 26)#(2 250 16 21 26 60 80 82)#(2 682 21 25 26 79)#(2 666 21 25 26 79)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1389 143)#(2 750 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(3 301 20 305 23 309 24 313 25 317 28 321 31 325 32 329 34 333 35 337 36 341 38 345 39 349 42 353 47 357 48 361 49 365 50 369 52 373 53 377 54 381 56 385 60 389 76 393 77 397 78 209 81 405 84 409 85 413 87 417 88 421 89 425 90 429 92 433 93 437 94 441 95 445 96 449 97 453 98 457 99 461 100 465 101 469 102 473 119 477 137 481 138 485 139 489 140 493 141 497 142 1393 143)#(2 1397 60)#(2 734 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 754 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82)#(2 746 20 23 24 25 28 31 32 34 35 36 38 39 42 46 47 48 49 50 52 53 54 56 60 76 77 78 81 82))! !!JavaParser methodsFor: 'generated-tables' stamp: 'jws 10/23/2016 05:59'!reduceTable	^#(#(103 1 #reduceFor:)#(103 1 #reduceFor:)#(104 1 #reduceFor:)#(104 1 #reduceFor:)#(105 1 #reduceFor:)#(105 1 #reduceFor:)#(106 1 #reduceFor:)#(106 1 #reduceFor:)#(107 1 #reduceFor:)#(107 1 #reduceFor:)#(107 1 #reduceFor:)#(107 1 #reduceFor:)#(107 1 #reduceFor:)#(108 1 #reduceFor:)#(108 1 #reduceFor:)#(109 1 #reduceFor:)#(110 2 #reduceFor:)#(110 2 #reduceFor:)#(111 1 #reduceFor:)#(111 1 #reduceFor:)#(112 1 #reduceFor:)#(113 1 #reduceFor:)#(114 2 #reduceFor:)#(114 3 #reduceFor:)#(115 1 #reduceFor:)#(116 3 #reduceFor:)#(117 1 #reduceFor:)#(118 1 #reduceFor:)#(118 0 #reduceFor:)#(119 1 #reduceFor:)#(119 0 #reduceFor:)#(120 1 #reduceFor:)#(120 0 #reduceFor:)#(121 3 #reduceFor:)#(122 1 #reduceFor:)#(122 2 #reduceFor:)#(123 1 #reduceFor:)#(123 2 #reduceFor:)#(124 1 #reduceFor:)#(124 1 #reduceFor:)#(125 1 #reduceFor:)#(125 1 #reduceFor:)#(125 1 #reduceFor:)#(126 3 #reduceFor:)#(127 5 #reduceFor:)#(128 6 #reduceFor:)#(129 5 #reduceFor:)#(130 1 #reduceFor:)#(131 0 #reduceFor:)#(131 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(132 1 #reduceFor:)#(133 0 #reduceFor:)#(133 1 #reduceFor:)#(134 0 #reduceFor:)#(134 1 #reduceFor:)#(135 3 #reduceFor:)#(136 2 #reduceFor:)#(137 1 #reduceFor:)#(137 3 #reduceFor:)#(138 2 #reduceFor:)#(139 0 #reduceFor:)#(139 1 #reduceFor:)#(140 1 #reduceFor:)#(140 2 #reduceFor:)#(141 1 #reduceFor:)#(141 1 #reduceFor:)#(141 1 #reduceFor:)#(141 1 #reduceFor:)#(142 1 #reduceFor:)#(142 1 #reduceFor:)#(142 6 #reduceFor:)#(142 1 #reduceFor:)#(142 1 #reduceFor:)#(143 2 #reduceFor:)#(144 4 #reduceFor:)#(145 3 #reduceFor:)#(146 4 #reduceFor:)#(147 2 #reduceFor:)#(148 1 #reduceFor:)#(148 3 #reduceFor:)#(149 1 #reduceFor:)#(149 3 #reduceFor:)#(150 1 #reduceFor:)#(150 3 #reduceFor:)#(151 1 #reduceFor:)#(151 1 #reduceFor:)#(152 1 #reduceFor:)#(153 4 #reduceFor:)#(153 3 #reduceFor:)#(153 3 #reduceFor:)#(153 2 #reduceFor:)#(154 4 #reduceFor:)#(154 4 #reduceFor:)#(155 1 #reduceFor:)#(155 1 #reduceFor:)#(156 4 #reduceFor:)#(156 3 #reduceFor:)#(157 0 #reduceFor:)#(157 1 #reduceFor:)#(158 0 #reduceFor:)#(158 1 #reduceFor:)#(159 1 #reduceFor:)#(159 3 #reduceFor:)#(160 2 #reduceFor:)#(160 3 #reduceFor:)#(161 2 #reduceFor:)#(162 1 #reduceFor:)#(162 3 #reduceFor:)#(163 4 #reduceFor:)#(164 4 #reduceFor:)#(164 3 #reduceFor:)#(164 3 #reduceFor:)#(164 2 #reduceFor:)#(165 5 #reduceFor:)#(165 5 #reduceFor:)#(165 7 #reduceFor:)#(165 7 #reduceFor:)#(166 1 #reduceFor:)#(166 2 #reduceFor:)#(167 0 #reduceFor:)#(167 1 #reduceFor:)#(168 1 #reduceFor:)#(168 1 #reduceFor:)#(169 0 #reduceFor:)#(169 1 #reduceFor:)#(170 3 #reduceFor:)#(171 2 #reduceFor:)#(171 3 #reduceFor:)#(172 0 #reduceFor:)#(172 1 #reduceFor:)#(173 1 #reduceFor:)#(173 2 #reduceFor:)#(174 1 #reduceFor:)#(174 1 #reduceFor:)#(174 1 #reduceFor:)#(174 1 #reduceFor:)#(175 1 #reduceFor:)#(176 2 #reduceFor:)#(177 1 #reduceFor:)#(177 3 #reduceFor:)#(178 0 #reduceFor:)#(178 1 #reduceFor:)#(179 1 #reduceFor:)#(179 1 #reduceFor:)#(179 1 #reduceFor:)#(179 1 #reduceFor:)#(180 2 #reduceFor:)#(181 1 #reduceFor:)#(181 1 #reduceFor:)#(181 1 #reduceFor:)#(181 1 #reduceFor:)#(181 1 #reduceFor:)#(181 1 #reduceFor:)#(182 2 #reduceFor:)#(182 3 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(183 1 #reduceFor:)#(184 3 #reduceFor:)#(185 5 #reduceFor:)#(186 7 #reduceFor:)#(187 5 #reduceFor:)#(188 9 #reduceFor:)#(189 3 #reduceFor:)#(190 7 #reduceFor:)#(191 5 #reduceFor:)#(192 9 #reduceFor:)#(193 1 #reduceFor:)#(193 1 #reduceFor:)#(193 1 #reduceFor:)#(193 1 #reduceFor:)#(193 1 #reduceFor:)#(194 1 #reduceFor:)#(195 2 #reduceFor:)#(196 5 #reduceFor:)#(197 7 #reduceFor:)#(198 3 #reduceFor:)#(199 3 #reduceFor:)#(200 3 #reduceFor:)#(201 5 #reduceFor:)#(202 3 #reduceFor:)#(203 3 #reduceFor:)#(203 4 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(204 1 #reduceFor:)#(205 3 #reduceFor:)#(206 2 #reduceFor:)#(207 2 #reduceFor:)#(208 2 #reduceFor:)#(209 2 #reduceFor:)#(210 4 #reduceFor:)#(210 6 #reduceFor:)#(210 6 #reduceFor:)#(210 8 #reduceFor:)#(211 5 #reduceFor:)#(211 6 #reduceFor:)#(211 7 #reduceFor:)#(211 8 #reduceFor:)#(212 4 #reduceFor:)#(212 3 #reduceFor:)#(212 3 #reduceFor:)#(212 2 #reduceFor:)#(213 1 #reduceFor:)#(213 2 #reduceFor:)#(214 1 #reduceFor:)#(214 2 #reduceFor:)#(215 2 #reduceFor:)#(216 3 #reduceFor:)#(216 2 #reduceFor:)#(217 1 #reduceFor:)#(218 0 #reduceFor:)#(218 1 #reduceFor:)#(219 0 #reduceFor:)#(219 1 #reduceFor:)#(220 0 #reduceFor:)#(220 1 #reduceFor:)#(221 1 #reduceFor:)#(221 1 #reduceFor:)#(222 1 #reduceFor:)#(222 3 #reduceFor:)#(223 1 #reduceFor:)#(224 0 #reduceFor:)#(224 1 #reduceFor:)#(225 1 #reduceFor:)#(225 2 #reduceFor:)#(226 0 #reduceFor:)#(226 1 #reduceFor:)#(227 2 #reduceFor:)#(228 5 #reduceFor:)#(229 1 #reduceFor:)#(229 1 #reduceFor:)#(229 3 #reduceFor:)#(229 1 #reduceFor:)#(229 1 #reduceFor:)#(229 1 #reduceFor:)#(229 1 #reduceFor:)#(229 3 #reduceFor:)#(229 3 #reduceFor:)#(229 3 #reduceFor:)#(229 3 #reduceFor:)#(229 3 #reduceFor:)#(230 4 #reduceFor:)#(230 4 #reduceFor:)#(230 4 #reduceFor:)#(230 4 #reduceFor:)#(231 3 #reduceFor:)#(231 3 #reduceFor:)#(231 5 #reduceFor:)#(232 4 #reduceFor:)#(232 4 #reduceFor:)#(233 1 #reduceFor:)#(233 3 #reduceFor:)#(234 1 #reduceFor:)#(234 2 #reduceFor:)#(235 0 #reduceFor:)#(235 1 #reduceFor:)#(236 3 #reduceFor:)#(237 1 #reduceFor:)#(237 1 #reduceFor:)#(237 1 #reduceFor:)#(237 1 #reduceFor:)#(238 1 #reduceFor:)#(238 1 #reduceFor:)#(238 2 #reduceFor:)#(238 2 #reduceFor:)#(238 1 #reduceFor:)#(239 1 #reduceFor:)#(239 2 #reduceFor:)#(239 2 #reduceFor:)#(239 1 #reduceFor:)#(240 5 #reduceFor:)#(240 4 #reduceFor:)#(240 5 #reduceFor:)#(241 1 #reduceFor:)#(241 3 #reduceFor:)#(241 3 #reduceFor:)#(241 3 #reduceFor:)#(242 1 #reduceFor:)#(242 3 #reduceFor:)#(242 3 #reduceFor:)#(243 1 #reduceFor:)#(243 3 #reduceFor:)#(243 3 #reduceFor:)#(243 3 #reduceFor:)#(244 1 #reduceFor:)#(244 3 #reduceFor:)#(244 3 #reduceFor:)#(244 3 #reduceFor:)#(244 3 #reduceFor:)#(244 3 #reduceFor:)#(245 1 #reduceFor:)#(245 3 #reduceFor:)#(245 3 #reduceFor:)#(246 1 #reduceFor:)#(246 3 #reduceFor:)#(247 1 #reduceFor:)#(247 3 #reduceFor:)#(248 1 #reduceFor:)#(248 3 #reduceFor:)#(249 1 #reduceFor:)#(249 3 #reduceFor:)#(250 1 #reduceFor:)#(250 3 #reduceFor:)#(251 1 #reduceFor:)#(251 5 #reduceFor:)#(252 1 #reduceFor:)#(252 1 #reduceFor:)#(253 1 #reduceFor:)#(253 1 #reduceFor:)#(253 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(254 1 #reduceFor:)#(257 1 #reduceFor:)#(257 1 #reduceFor:)#(257 1 #reduceFor:)#(257 1 #reduceFor:)#(257 1 #reduceFor:)#(257 1 #reduceFor:)#(258 3 #reduceFor:)#(259 1 #reduceFor:)#(259 2 #reduceFor:))! !!JavaParser methodsFor: 'generated-tables' stamp: 'jws 10/23/2016 05:59'!transitionTable	^#(#(3 118 7 118 8 118 12 118 16 118 18 9 29 118 32 118 36 118 37 118 38 118 39 118 40 118 43 118 44 118 45 118 46 13 118 17 121 21 130 118 255 25 258)#(3 29 99 33 111 37 115 41 116)#(3 126 7 126 8 126 12 126 16 126 18 126 32 126 36 126 37 126 38 126 39 126 40 126 43 45 44 126 45 126 46 49 119 53 122 57 124 61 126 65 127 126 255)#(2 114 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 0 255)#(2 194 255)#(2 102 1 2 3 4 5 6 10 13 15 19 21 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90 99)#(3 69 28 73 32)#(2 78 1 2 3 4 5 6 10 13 15 19 21 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90 99)#(2 82 1 2 3 4 5 6 10 13 15 19 21 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90 99)#(3 29 99 77 111 37 115 41 116)#(3 81 7 198 8 85 12 198 16 89 18 93 32 97 36 101 37 105 38 109 39 113 40 117 43 121 45 125 46 129 120 133 123 137 125 141 128 145 129 149 131 153 132 134 255 157 259)#(3 122 7 122 8 122 12 122 16 122 18 122 32 122 36 122 37 122 38 122 39 122 40 122 43 45 44 122 45 122 46 161 124 61 126 65 127 122 255)#(2 142 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 158 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 162 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 165 99)#(2 138 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(3 169 28 173 32)#(2 246 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 242 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 238 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 174 7 8 12 16 18 32 36 37 38 39 40 43 45 46 255)#(2 226 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 230 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 222 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 218 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 234 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 206 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 214 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 210 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 1410 255)#(3 81 7 198 8 85 12 198 16 89 18 93 32 97 36 101 37 105 38 109 39 113 40 117 43 121 45 125 46 177 125 141 128 145 129 149 131 153 132 130 255 157 259)#(2 150 7 8 12 16 18 32 36 37 38 39 40 43 45 46 255)#(2 166 7 8 12 16 18 32 36 37 38 39 40 43 45 46 255)#(2 170 7 8 12 16 18 32 36 37 38 39 40 43 45 46 255)#(3 181 8 185 16)#(2 1414 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(3 81 7 202 8 202 9 85 12 202 16 89 18 202 24 202 25 202 26 202 27 202 30 202 31 202 33 202 34 97 36 101 37 105 38 109 39 113 40 117 43 121 45 125 46 202 99 189 132)#(2 146 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 106 1 2 3 4 5 6 10 13 15 19 21 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90 99)#(3 193 42 165 99)#(2 178 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(2 154 7 8 12 16 18 32 36 37 38 39 40 43 45 46 255)#(2 197 99)#(2 201 99)#(2 1418 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 205 32)#(3 250 3 250 10 209 11 213 133 217 136)#(3 538 3 221 11 225 169 229 171)#(2 182 7 8 12 16 18 32 36 37 38 39 40 43 44 45 46 255)#(3 29 99 233 109 237 111 241 112 37 115 41 116)#(3 258 3 245 10 249 134 253 138)#(2 254 3 10)#(3 29 99 257 109 237 111 261 113 37 115 41 116)#(3 265 3 269 170)#(3 542 3 273 4)#(2 86 3 4 10 32)#(3 66 3 66 4 66 5 66 10 66 21 69 28 66 32)#(2 270 3 10)#(3 29 99 257 109 237 111 277 113 37 115 41 116 281 137)#(3 285 3 289 135)#(2 262 3)#(2 90 3 4)#(2 550 3 4)#(3 558 1 81 7 198 8 198 9 85 12 198 16 89 18 198 24 198 25 198 26 198 27 198 30 198 31 198 33 198 34 97 36 101 37 105 38 109 39 113 40 117 43 121 45 125 46 198 99 293 128 297 129 301 131 153 132 305 146 309 154 313 172 317 173 321 174 325 175 329 176 157 259)#(2 190 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99 255)#(3 29 99 257 109 237 111 333 113 37 115 41 116)#(2 274 3 4)#(3 282 3 337 4)#(3 286 1 341 3 81 7 198 8 198 9 85 12 198 16 89 18 198 24 198 25 198 26 198 27 198 30 198 31 345 32 198 33 198 34 97 36 101 37 105 38 349 39 113 40 117 43 121 45 125 46 198 99 353 129 357 131 153 132 361 139 365 140 369 141 373 142 377 143 381 144 385 145 389 146 393 147 397 154 157 259)#(2 186 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99 255)#(2 582 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 586 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(3 181 8 401 9 185 16 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 437 103 441 104 445 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116)#(2 590 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 473 32)#(2 477 1)#(3 562 1 81 7 198 8 198 9 85 12 198 16 89 18 198 24 198 25 198 26 198 27 198 30 198 31 198 33 198 34 97 36 101 37 105 38 109 39 113 40 117 43 121 45 125 46 198 99 293 128 297 129 301 131 153 132 305 146 309 154 481 174 325 175 329 176 157 259)#(2 566 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 574 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 578 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 554 3 4)#(3 29 99 257 109 237 111 485 113 37 115 41 116)#(3 606 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 625 166 629 168 633 178 637 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 334 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 341 3 218 7 218 8 218 9 218 12 218 16 218 18 218 24 218 25 218 26 218 27 218 30 218 31 218 33 218 34 218 36 218 37 218 38 218 39 218 40 218 43 218 45 218 46 218 99 777 145)#(2 330 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 781 8 401 9 185 16 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 437 103 441 104 445 105 449 106 453 107 457 108 461 109 465 110 469 111 785 115 41 116 789 163)#(2 793 1)#(3 290 1 341 3 81 7 198 8 198 9 85 12 198 16 89 18 198 24 198 25 198 26 198 27 198 30 198 31 345 32 198 33 198 34 97 36 101 37 105 38 349 39 113 40 117 43 121 45 125 46 198 99 353 129 357 131 153 132 797 141 373 142 377 143 381 144 385 145 389 146 393 147 397 154 157 259)#(2 294 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 302 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 306 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 310 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 314 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 318 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 322 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 341 3 801 32 805 145 809 155)#(3 813 99 817 156)#(2 58 5 19 28 99)#(2 62 5 19 28 99)#(2 54 5 19 28 99)#(2 50 5 19 28 99)#(2 10 5 19 28 99)#(2 38 5 19 28 99)#(2 46 5 19 28 99)#(2 42 5 19 28 99)#(3 821 5 22 99 825 114)#(2 26 99)#(3 829 99 833 148 837 149 841 150 845 156)#(2 6 5 19 28 99)#(2 30 5 19 28 99)#(2 34 5 19 28 99)#(2 14 1 4 6 15 19 32 48 49 50 51 52 53 54 55 56 57 59 65 71 99)#(2 18 1 4 6 15 19 32 48 49 50 51 52 53 54 55 56 57 59 65 71 99)#(3 66 1 66 4 821 5 66 6 66 15 66 19 69 28 66 32 66 48 66 49 66 50 66 51 66 52 66 53 66 54 66 55 66 56 66 57 66 59 66 65 66 71 66 99 849 114)#(2 594 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 546 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99 255)#(2 570 1 7 8 9 12 16 18 24 25 26 27 30 31 33 34 36 37 38 39 40 43 45 46 99)#(2 278 3 4)#(2 853 28)#(2 857 21)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 893 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 989 28)#(2 1018 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 766 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 993 21)#(3 226 7 226 8 226 12 226 16 226 18 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 226 36 226 37 226 38 226 39 226 40 226 43 226 45 226 46 29 99 437 103 441 104 997 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116)#(3 234 7 234 8 234 12 234 16 234 18 1001 21 234 36 234 37 234 38 234 39 234 40 234 43 234 45 234 46)#(2 1005 21)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1009 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 946 32 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1013 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 1017 219 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 1021 103 449 106 453 107 457 108 1025 109 237 111 1029 112 37 115 41 116)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 1033 40 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1037 181 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 1041 21)#(3 341 3 1045 145)#(3 982 32 1049 99 1053 224)#(3 982 32 1049 99 1057 224)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1073 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1077 238 933 239 937 240 773 257)#(2 1386 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1390 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1394 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1398 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1402 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1406 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 102 2 102 5 102 13 1081 15 102 21 102 28 102 60 102 61 102 62 102 63 102 64 102 66 102 67 102 68 102 69 102 70 102 82 102 87 102 99)#(3 821 5 1085 28 22 99 825 114)#(3 1089 99 1093 148 837 149 841 150)#(3 1097 28 18 99)#(3 1326 2 1101 5 1326 13 1105 21 1109 28 1326 60 1326 61 1326 62 1326 63 1326 64 1326 66 1326 67 1326 68 1326 69 1326 70 1130 82 1130 87 66 99 849 114)#(2 622 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 626 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 666 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 610 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 629 168 1113 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(3 1126 1 1126 4 1126 6 1126 15 1126 19 1117 28 1126 32 1126 42 1126 48 1126 49 1126 50 1126 51 1126 52 1126 53 1126 54 1126 55 1126 56 1126 57 1126 59 1126 65 1126 71 1126 82 1126 83 1126 84 1126 85 1126 86 1126 87 1126 88 1126 89 1126 90)#(2 1121 1)#(2 514 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 614 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 618 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1125 32)#(2 634 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 638 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 642 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 646 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 650 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 654 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 670 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 674 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 678 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 682 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 686 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 690 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 694 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 698 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 702 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 706 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1129 32)#(2 810 4 19 32)#(2 814 4 19 32)#(2 818 4 19 32)#(3 822 4 822 19 822 32 1134 82 1134 87)#(3 826 4 826 19 826 32 1138 82 1138 87)#(3 830 4 1034 5 830 19 1034 28 830 32 1034 82 1034 87)#(3 834 4 1026 5 834 19 1026 28 834 32 1026 82 1026 87)#(3 530 1 530 4 1133 5 530 6 530 15 530 19 530 28 530 32 530 42 530 48 530 49 530 50 530 51 530 52 530 53 530 54 530 55 530 56 530 57 530 59 530 65 530 71 530 82 530 83 530 84 530 85 530 86 530 87 530 88 530 89 530 90)#(2 534 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 1030 1 1330 2 1030 4 1030 5 1030 6 1330 13 1030 15 1030 19 1030 28 1030 32 1030 42 1030 48 1030 49 1030 50 1030 51 1030 52 1030 53 1030 54 1030 55 1030 56 1030 57 1030 59 1330 60 1330 61 1330 62 1330 63 1330 64 1030 65 1330 66 1330 67 1330 68 1330 69 1330 70 1030 71 1030 82 1030 83 1030 84 1030 85 1030 86 1030 87 1030 88 1030 89 1030 90)#(3 1038 1 1334 2 1038 4 1038 5 1038 6 1334 13 1038 15 1038 19 1038 28 1038 32 1038 42 1038 48 1038 49 1038 50 1038 51 1038 52 1038 53 1038 54 1038 55 1038 56 1038 57 1038 59 1334 60 1334 61 1334 62 1334 63 1334 64 1038 65 1334 66 1334 67 1334 68 1334 69 1334 70 1038 71 1038 82 1038 83 1038 84 1038 85 1038 86 1038 87 1038 88 1038 89 1038 90)#(3 1137 82 1141 87)#(3 1145 2 1149 13 1153 60 1157 61 1161 62 1165 63 1169 64 1173 66 1177 67 1181 68 1185 69 1189 70 1193 254)#(2 1014 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 338 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 1197 99)#(3 78 5 1201 21 78 28 78 99)#(3 434 3 1205 20 1209 157 1213 161)#(2 266 1 3 4 5 6 7 8 9 12 15 16 17 18 19 21 22 23 24 25 26 27 28 30 31 32 33 34 35 36 37 38 39 40 41 42 43 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 65 71 73 74 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 93 94 95 96 97 98 99 255)#(2 298 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 422 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 418 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 354 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 1217 21)#(3 434 3 1221 5 1205 20 434 32 1225 157 1213 161)#(2 1229 6)#(3 70 1 70 4 1233 5 70 6 70 15 70 19 70 28 70 32 70 48 70 49 70 50 70 51 70 52 70 53 70 54 70 55 70 56 70 57 70 59 70 65 70 71 70 99)#(3 374 2 374 4 374 5 1217 21 374 32)#(3 1237 4 1241 32)#(2 358 4 32)#(3 1245 2 366 4 1249 5 366 32)#(3 434 3 1221 5 1205 20 434 32 1253 157 1213 161)#(3 74 1 74 4 1233 5 74 6 74 15 74 19 74 28 74 32 74 48 74 49 74 50 74 51 74 52 74 53 74 54 74 55 74 56 74 57 74 59 74 65 74 71 74 99)#(2 1257 8)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1261 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 1265 103 449 106 453 107 457 108 885 110 1269 111 37 115 41 116 1273 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1277 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1281 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1285 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1289 238 933 239 937 240 773 257)#(3 821 5 1085 28 825 114)#(2 1097 28)#(3 1130 1 1326 2 1130 4 1101 5 1130 6 1326 13 1130 15 1130 19 1105 21 1109 28 1130 32 1130 42 1130 48 1130 49 1130 50 1130 51 1130 52 1130 53 1130 54 1130 55 1130 56 1130 57 1130 59 1326 60 1326 61 1326 62 1326 63 1326 64 1130 65 1326 66 1326 67 1326 68 1326 69 1326 70 1130 71 1130 82 1130 83 1130 84 1130 85 1130 86 1130 87 1130 88 1130 89 1130 90 849 114)#(2 1293 19)#(2 1322 1 4 6 15 19 32)#(2 1142 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1146 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1134 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1138 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1034 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1026 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 1162 1 1162 4 1162 6 1162 15 1162 19 1162 32 1162 42 1162 48 1162 49 1162 50 1162 51 1162 52 1162 53 1162 54 1162 55 1162 56 1162 57 1162 59 1162 65 1162 71 1137 82 1162 83 1162 84 1162 85 1162 86 1141 87 1162 88 1162 89 1162 90)#(2 1190 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1158 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1174 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(3 1206 1 1206 4 1206 6 1206 15 1206 19 1206 32 1297 42 1206 48 1206 49 1206 50 1206 51 1206 52 1206 53 1206 54 1206 55 1206 56 1206 57 1206 59 1206 65 1206 71 1206 83 1206 84 1301 85 1206 86 1305 88 1206 89 1206 90)#(3 1218 1 1218 4 1218 6 1218 15 1218 19 1218 32 1218 48 1218 49 1218 50 1218 51 1218 52 1218 53 1218 54 1218 55 1218 56 1218 57 1218 59 1218 65 1218 71 1218 83 1218 84 1218 86 1309 89 1313 90)#(3 1234 1 1234 4 1234 6 1234 15 1234 19 1234 32 1234 48 1234 49 1234 50 1234 51 1234 52 1234 53 1234 54 1234 55 1234 56 1234 57 1234 59 1234 65 1234 71 1317 83 1321 84 1325 86)#(3 1258 1 1258 4 1258 6 1258 15 1258 19 1258 32 1258 48 1258 49 1258 50 1258 51 1258 52 1258 53 1329 54 1333 55 1258 56 1258 57 1337 59 1341 65 1345 71)#(3 1270 1 1270 4 1270 6 1270 15 1270 19 1270 32 1270 48 1270 49 1270 50 1349 51 1270 52 1270 53 1270 56 1353 57)#(3 1278 1 1278 4 1278 6 1278 15 1278 19 1278 32 1278 48 1278 49 1357 50 1278 52 1278 53 1278 56)#(3 1286 1 1286 4 1286 6 1286 15 1286 19 1286 32 1361 48 1286 49 1286 52 1286 53 1286 56)#(3 1294 1 1294 4 1294 6 1294 15 1294 19 1294 32 1365 49 1294 52 1294 53 1294 56)#(3 1302 1 1302 4 1302 6 1302 15 1302 19 1302 32 1369 52 1302 53 1302 56)#(3 1310 1 1310 4 1310 6 1310 15 1310 19 1310 32 1373 53 1377 56)#(2 1318 1 4 6 15 19 32)#(2 390 1 4 6 15 19 32)#(2 1381 99)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1385 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 1089 99 1389 148 837 149 841 150)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1393 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1397 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 1401 32)#(2 950 32)#(2 1405 32)#(3 1409 5 1413 114 1417 234 1421 236)#(3 1409 5 86 21 1425 114 1429 234 1421 236)#(2 1433 21)#(2 1001 21)#(2 1437 58)#(3 489 9 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 938 32 429 33 433 34 1441 36 537 76 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 29 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 629 168 1445 182 1449 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 1453 218 1457 221 1461 222 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 1465 72 998 75 1469 225 1473 226 1477 228)#(2 986 32)#(2 1481 32)#(2 1485 32)#(3 1130 1 1130 4 1101 5 1130 6 1130 15 1130 19 1105 21 1109 28 1130 32 1130 42 1130 48 1130 49 1130 50 1130 51 1130 52 1130 53 1130 54 1130 55 1130 56 1130 57 1130 59 1130 65 1130 71 1130 82 1130 83 1130 84 1130 85 1130 86 1130 87 1130 88 1130 89 1130 90 849 114)#(2 1030 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1038 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 842 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 846 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 1033 40 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1489 181 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 1493 8)#(2 374 2 4 5 19 32)#(3 1237 4 658 32)#(2 1497 8)#(3 1229 6 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1501 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 1509 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 1517 8 1521 22 1525 23 165 99)#(2 518 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 1529 76 1533 99)#(2 346 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 72 73 74 75 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 630 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 770 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1537 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 850 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 854 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1338 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1382 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1370 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1374 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1366 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1362 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1378 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1346 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1350 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1342 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1358 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(2 1354 9 21 22 23 24 25 26 27 30 31 33 34 76 82 87 89 90 91 92 93 94 95 96 97 98 99)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 1541 252 769 253 773 257)#(3 250 3 250 10 209 11 1545 133 217 136)#(3 442 19 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 1549 36 29 99 437 103 441 104 1553 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116 1557 158 1561 159 1565 160)#(3 29 99 233 109 237 111 1569 112 37 115 41 116 1573 162)#(3 1577 3 1581 164)#(2 438 3 32)#(3 442 19 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 1549 36 29 99 437 103 441 104 1553 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116 1585 158 1561 159 1565 160)#(2 1589 6)#(2 414 3 32)#(2 94 1 3 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90 99)#(2 1593 6)#(3 1089 99 1597 149 841 150)#(2 350 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 1601 3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1605 151 1609 152 1613 153 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 1617 6)#(2 410 3 32)#(2 1046 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1621 19)#(3 821 5 1114 19 1085 28 1625 114 1629 235)#(3 1326 2 1101 5 1326 13 1130 19 1105 21 1109 28 1130 42 1130 48 1130 49 1130 50 1130 51 1130 52 1130 53 1130 54 1130 55 1130 56 1130 57 1130 59 1326 60 1326 61 1326 62 1326 63 1326 64 1130 65 1326 66 1326 67 1326 68 1326 69 1326 70 1130 71 1130 82 1130 83 1130 84 1130 85 1130 86 1130 87 1130 88 1130 89 1130 90 1633 114)#(2 1637 19)#(2 1150 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1154 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1170 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1166 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1022 5 28 82 87)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1641 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1645 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1649 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 1653 241 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 1657 241 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 1661 242 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 1665 242 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 1669 242 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 1673 243 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 1677 243 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 1681 243 773 257)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 1685 103 1689 104 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 1693 243 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 1697 244 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 1701 244 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 1705 245 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 1709 246 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 1713 247 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 1717 248 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 1721 249 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1725 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 1082 1 1082 2 1082 4 1082 5 1082 6 1082 13 1082 15 1082 19 1729 21 1082 28 1082 32 1082 42 1082 48 1082 49 1082 50 1082 51 1082 52 1082 53 1082 54 1082 55 1082 56 1082 57 1082 59 1082 60 1082 61 1082 62 1082 63 1082 64 1082 65 1082 66 1082 67 1082 68 1082 69 1082 70 1082 71 1082 82 1082 83 1082 84 1082 85 1082 86 1082 87 1082 88 1082 89 1082 90)#(2 1733 19)#(3 1237 4 662 32)#(2 1737 19)#(2 1741 19)#(2 798 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 790 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 1229 6 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1745 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 1601 3 1233 5 1749 153)#(3 1114 1 1114 4 1409 5 1114 6 1114 15 1114 19 1114 28 1114 32 1114 42 1114 48 1114 49 1114 50 1114 51 1114 52 1114 53 1114 54 1114 55 1114 56 1114 57 1114 59 1114 65 1114 71 1114 82 1114 83 1114 84 1114 85 1114 86 1114 87 1114 88 1114 89 1114 90 1753 114 1757 235 1761 236)#(2 1106 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 1601 3 1233 5 1765 153)#(3 1114 1 1114 4 1409 5 1114 6 1114 15 1114 19 1114 28 1114 32 1114 42 1114 48 1114 49 1114 50 1114 51 1114 52 1114 53 1114 54 1114 55 1114 56 1114 57 1114 59 1114 65 1114 71 1114 82 1114 83 1114 84 1114 85 1114 86 1114 87 1114 88 1114 89 1114 90 1753 114 1769 235 1761 236)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 1773 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 1777 21)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 437 103 441 104 997 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116)#(2 966 32)#(2 970 4 19 32)#(2 1781 32)#(2 942 32)#(3 1785 4 962 32)#(2 1789 21)#(3 802 1 802 3 802 7 802 8 802 9 802 12 802 14 802 16 802 17 802 18 802 21 802 22 802 23 802 24 802 25 802 26 802 27 802 30 802 31 802 32 802 33 802 34 802 35 802 36 802 37 802 38 802 39 802 40 802 41 802 43 802 45 802 46 802 47 802 58 1465 72 802 73 802 74 1002 75 802 76 802 77 802 78 802 79 802 80 802 81 802 82 802 87 802 93 802 94 802 95 802 96 802 97 802 98 802 99 1793 228)#(3 1797 75 1801 227)#(2 990 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 72 73 74 75 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 786 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 782 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 710 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1042 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1050 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1805 6)#(2 1098 4 19)#(2 1809 19)#(3 1813 4 526 19)#(2 1054 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1817 28)#(2 1058 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1821 99)#(3 1078 1 1078 2 1078 4 1078 5 1078 6 1078 13 1078 15 1078 19 1825 21 1078 28 1078 32 1078 42 1078 48 1078 49 1078 50 1078 51 1078 52 1078 53 1078 54 1078 55 1078 56 1078 57 1078 59 1078 60 1078 61 1078 62 1078 63 1078 64 1078 65 1078 66 1078 67 1078 68 1078 69 1078 70 1078 71 1078 82 1078 83 1078 84 1078 85 1078 86 1078 87 1078 88 1078 89 1078 90)#(2 1829 6)#(2 838 1 4 6 15 19 32)#(3 258 3 245 10 1833 134 253 138)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 29 99 437 103 441 104 1837 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116)#(3 1089 99 1841 150)#(2 1845 19)#(3 1849 4 446 19)#(2 450 4 19)#(2 470 3 4 32)#(3 466 3 1853 4 466 32)#(3 1857 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 1861 22 1865 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 1869 165 1873 166 1877 168 637 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 342 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 1881 19)#(2 430 3 5 20 32)#(2 98 1 3 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90 99)#(2 362 4 32)#(3 1885 1 1601 3 1889 4 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1893 151 1609 152 1613 153 629 168 1897 177 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 370 4 32)#(2 382 1 4 32)#(2 386 1 4 32)#(2 378 2 4 5 19 32)#(3 1901 3 1905 212)#(3 1233 5 1118 19 70 28)#(2 1909 19)#(3 1233 5 1913 19 74 28)#(3 1022 1 1022 4 1022 5 1022 6 489 9 1022 15 1022 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 1022 28 421 30 425 31 1022 32 429 33 433 34 1022 42 1022 48 1022 49 1022 50 1022 51 1022 52 1022 53 1022 54 1022 55 1022 56 1022 57 1022 59 1022 65 1022 71 537 76 1022 82 1022 83 1022 84 1022 85 1022 86 1022 87 1022 88 1022 89 1022 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 1917 239 937 240 773 257)#(2 1194 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1202 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1198 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(3 1210 1 1210 4 1210 6 1210 15 1210 19 1210 32 1297 42 1210 48 1210 49 1210 50 1210 51 1210 52 1210 53 1210 54 1210 55 1210 56 1210 57 1210 59 1210 65 1210 71 1210 83 1210 84 1301 85 1210 86 1305 88 1210 89 1210 90)#(3 1214 1 1214 4 1214 6 1214 15 1214 19 1214 32 1297 42 1214 48 1214 49 1214 50 1214 51 1214 52 1214 53 1214 54 1214 55 1214 56 1214 57 1214 59 1214 65 1214 71 1214 83 1214 84 1301 85 1214 86 1305 88 1214 89 1214 90)#(3 1222 1 1222 4 1222 6 1222 15 1222 19 1222 32 1222 48 1222 49 1222 50 1222 51 1222 52 1222 53 1222 54 1222 55 1222 56 1222 57 1222 59 1222 65 1222 71 1222 83 1222 84 1222 86 1309 89 1313 90)#(3 1226 1 1226 4 1226 6 1226 15 1226 19 1226 32 1226 48 1226 49 1226 50 1226 51 1226 52 1226 53 1226 54 1226 55 1226 56 1226 57 1226 59 1226 65 1226 71 1226 83 1226 84 1226 86 1309 89 1313 90)#(3 1230 1 1230 4 1230 6 1230 15 1230 19 1230 32 1230 48 1230 49 1230 50 1230 51 1230 52 1230 53 1230 54 1230 55 1230 56 1230 57 1230 59 1230 65 1230 71 1230 83 1230 84 1230 86 1309 89 1313 90)#(3 1246 1 1246 4 1246 6 1246 15 1246 19 1246 32 1246 48 1246 49 1246 50 1246 51 1246 52 1246 53 1246 54 1246 55 1246 56 1246 57 1246 59 1246 65 1246 71 1317 83 1321 84 1325 86)#(3 1250 1 1250 4 1250 6 1250 15 1250 19 1250 32 1250 48 1250 49 1250 50 1250 51 1250 52 1250 53 1250 54 1250 55 1250 56 1250 57 1250 59 1250 65 1250 71 1317 83 1321 84 1325 86)#(3 1242 1 1242 4 1242 6 1242 15 1242 19 1242 32 1242 48 1242 49 1242 50 1242 51 1242 52 1242 53 1242 54 1242 55 1242 56 1242 57 1242 59 1242 65 1242 71 1317 83 1321 84 1325 86)#(3 821 5 825 114)#(2 1254 1 4 6 15 19 32 48 49 50 51 52 53 54 55 56 57 59 65 71)#(3 1238 1 1238 4 1238 6 1238 15 1238 19 1238 32 1238 48 1238 49 1238 50 1238 51 1238 52 1238 53 1238 54 1238 55 1238 56 1238 57 1238 59 1238 65 1238 71 1317 83 1321 84 1325 86)#(3 1266 1 1266 4 1266 6 1266 15 1266 19 1266 32 1266 48 1266 49 1266 50 1266 51 1266 52 1266 53 1329 54 1333 55 1266 56 1266 57 1337 59 1341 65 1345 71)#(3 1262 1 1262 4 1262 6 1262 15 1262 19 1262 32 1262 48 1262 49 1262 50 1262 51 1262 52 1262 53 1329 54 1333 55 1262 56 1262 57 1337 59 1341 65 1345 71)#(3 1274 1 1274 4 1274 6 1274 15 1274 19 1274 32 1274 48 1274 49 1274 50 1349 51 1274 52 1274 53 1274 56 1353 57)#(3 1282 1 1282 4 1282 6 1282 15 1282 19 1282 32 1282 48 1282 49 1357 50 1282 52 1282 53 1282 56)#(3 1290 1 1290 4 1290 6 1290 15 1290 19 1290 32 1361 48 1290 49 1290 52 1290 53 1290 56)#(3 1298 1 1298 4 1298 6 1298 15 1298 19 1298 32 1365 49 1298 52 1298 53 1298 56)#(3 1306 1 1306 4 1306 6 1306 15 1306 19 1306 32 1369 52 1306 53 1306 56)#(2 1921 15)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 1925 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1945 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 1969 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 341 3 1973 145)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 1033 40 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1977 181 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 1981 6)#(2 1070 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 1118 1 1118 4 1233 5 1118 6 1118 15 1118 19 1118 28 1118 32 1118 42 1118 48 1118 49 1118 50 1118 51 1118 52 1118 53 1118 54 1118 55 1118 56 1118 57 1118 59 1118 65 1118 71 1118 82 1118 83 1118 84 1118 85 1118 86 1118 87 1118 88 1118 89 1118 90)#(2 1062 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1110 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1074 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1066 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 1985 19)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1989 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 946 32 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1013 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 1993 219 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 629 168 1997 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 1549 36 29 99 437 103 441 104 1553 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116 2001 160)#(2 994 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 72 73 74 75 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 341 3 2005 145)#(2 806 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1090 1 2 4 5 6 13 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90)#(2 858 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 2009 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 2013 99)#(2 2017 21)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2021 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 1094 1 2 4 5 6 13 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 60 61 62 63 64 65 66 67 68 69 70 71 82 83 84 85 86 87 88 89 90)#(3 285 3 2025 135)#(3 1089 99 2029 150)#(3 458 4 1249 5 458 19)#(2 478 3 20)#(3 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 1549 36 29 99 437 103 441 104 1553 105 449 106 453 107 457 108 461 109 465 110 469 111 37 115 41 116 2033 160)#(3 29 99 233 109 237 111 2037 112 37 115 41 116)#(2 494 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 2041 21 989 28)#(3 1018 5 2045 21 1018 28 1018 82 1018 87)#(3 2049 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 2053 166 629 168 637 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(3 2057 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 629 168 1113 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(3 2061 28 1126 82 1126 87)#(2 426 3 5 20 32)#(2 406 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 2065 1)#(2 598 1 4)#(3 2069 1 2073 4)#(3 2077 1 2081 41 2085 47 2089 213 2093 214 2097 215 2101 216)#(2 774 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 2105 238 933 239 937 240 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 2109 239 937 240 773 257)#(2 1182 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 1061 111 37 115 41 116 629 168 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 1065 231 1069 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 2113 251 773 257)#(2 2117 19)#(2 2121 21)#(2 2125 21)#(2 2129 21)#(3 102 2 102 5 102 13 2133 15 102 21 102 28 102 60 102 61 102 62 102 63 102 64 102 66 102 67 102 68 102 69 102 70 102 82 102 87)#(2 714 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 634 1 634 3 634 7 634 8 634 9 634 12 746 14 634 16 634 17 634 18 634 21 634 22 634 23 634 24 634 25 634 26 634 27 634 30 634 31 634 32 634 33 634 34 634 35 634 36 634 37 634 38 634 39 634 40 634 41 634 43 634 45 634 46 634 47 634 58 634 73 634 74 634 76 634 77 634 78 634 79 634 80 634 81 634 82 634 87 634 93 634 94 634 95 634 96 634 97 634 98 634 99)#(2 750 14)#(2 754 14)#(2 758 14)#(2 762 14)#(2 2137 14)#(2 794 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 722 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1122 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 874 1 285 3 874 4 874 5 874 6 874 15 874 19 874 28 874 32 874 42 874 48 874 49 874 50 874 51 874 52 874 53 874 54 874 55 874 56 874 57 874 59 874 65 874 71 874 82 874 83 874 84 874 85 874 86 874 87 874 88 874 89 874 90 2141 135)#(2 2145 19)#(2 2149 32)#(2 974 4 19 32)#(2 2153 19)#(2 1006 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1102 4 19)#(3 1086 1 1086 2 1086 4 1086 5 1086 6 1086 13 1086 15 1086 19 2157 21 1086 28 1086 32 1086 42 1086 48 1086 49 1086 50 1086 51 1086 52 1086 53 1086 54 1086 55 1086 56 1086 57 1086 59 1086 60 1086 61 1086 62 1086 63 1086 64 1086 65 1086 66 1086 67 1086 68 1086 69 1086 70 1086 71 1086 82 1086 83 1086 84 1086 85 1086 86 1086 87 1086 88 1086 89 1086 90)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2161 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 2165 19)#(2 326 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 462 4 1249 5 462 19)#(2 454 4 19)#(2 474 3 4 32)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2169 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2173 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 486 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 2177 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 117 43 121 45 125 46 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 629 168 1113 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 490 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(3 2181 22 2185 23 1529 76 1533 99)#(2 402 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 398 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 2189 1 1601 3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 2193 151 1609 152 1613 153 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 902 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 2197 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 2201 217 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 2205 15)#(3 2209 1 2081 41 2085 47 2213 214 2217 215 2101 216)#(3 2221 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 2081 41 117 43 121 45 125 46 2085 47 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 2225 166 629 168 637 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 2229 216 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 906 1 41 47)#(2 914 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 1178 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1186 1 4 6 15 19 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 83 84 85 86 88 89 90)#(2 1314 1 4 6 15 19 32)#(2 866 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 2233 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 2237 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 938 32 429 33 433 34 1441 36 537 76 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 29 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 629 168 1445 182 1449 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 2241 218 1457 221 1461 222 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1489 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 2245 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 1033 40 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 2249 181 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 878 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 2253 32)#(3 489 9 954 19 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 629 168 1449 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 2257 220 2261 222 2265 223 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 341 3 2269 145)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2273 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 2277 19)#(2 862 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 2281 19)#(2 2285 19)#(2 482 1 3 7 8 9 12 16 18 24 25 26 27 30 31 32 33 34 36 37 38 39 40 43 45 46 99)#(2 2289 21)#(2 2293 21)#(2 394 1 4 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 602 1 4)#(2 934 15)#(2 2297 15)#(2 930 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 894 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 2301 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 2081 41 117 43 121 45 125 46 2085 47 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 2225 166 629 168 637 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 2229 216 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 910 1 41 47)#(2 898 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 922 1 341 3 81 7 198 8 489 9 85 12 198 16 493 17 89 18 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 517 36 101 37 105 38 109 39 521 40 922 41 117 43 121 45 125 46 922 47 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 597 103 441 104 601 105 449 106 453 107 457 108 461 109 605 110 609 111 37 115 41 116 613 128 617 129 149 131 153 132 621 145 629 168 1113 179 641 180 645 181 649 182 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257 157 259)#(2 918 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 2305 19)#(2 2309 19)#(2 2313 32)#(2 730 14)#(2 718 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 778 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 2317 19)#(3 1785 4 978 19)#(2 958 19)#(2 1010 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 72 73 74 75 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 2321 19)#(3 882 1 285 3 882 4 882 5 882 6 882 15 882 19 882 28 882 32 882 42 882 48 882 49 882 50 882 51 882 52 882 53 882 54 882 55 882 56 882 57 882 59 882 65 882 71 882 82 882 83 882 84 882 85 882 86 882 87 882 88 882 89 882 90 2325 135)#(2 2329 32)#(2 2333 32)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2337 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 489 9 522 19 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1505 152 2341 167 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 749 229 753 230 757 231 761 232 1513 233 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(2 926 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 890 1 3 7 8 9 12 14 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1945 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 2345 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 1977 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 2349 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 489 9 861 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 946 32 429 33 433 34 537 76 561 82 565 87 865 89 869 90 873 91 877 92 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 1013 152 629 168 897 205 901 206 905 207 909 208 913 209 917 210 921 211 2353 219 749 229 753 230 757 231 761 232 925 237 929 238 933 239 937 240 941 241 945 242 949 243 953 244 957 245 961 246 965 247 969 248 973 249 977 250 981 251 985 252 769 253 773 257)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 513 35 1033 40 525 58 529 73 533 74 537 76 541 77 545 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 593 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 2357 181 653 183 657 184 661 185 665 186 669 187 673 188 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 870 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 886 1 4 5 6 15 19 28 32 42 48 49 50 51 52 53 54 55 56 57 59 65 71 82 83 84 85 86 87 88 89 90)#(2 502 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 43 45 46 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 498 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 43 45 46 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 2361 19)#(2 2365 19)#(2 2369 14)#(2 738 14)#(2 2373 32)#(2 726 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 41 43 45 46 47 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 2377 32)#(2 2381 32)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 2249 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 2385 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(3 489 9 954 19 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 429 33 433 34 537 76 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 29 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 629 168 1449 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 2389 220 2261 222 2265 223 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 510 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 43 45 46 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 506 1 3 7 8 9 12 16 17 18 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 38 39 40 43 45 46 58 73 74 76 77 78 79 80 81 82 87 93 94 95 96 97 98 99)#(2 734 14)#(2 2393 19)#(3 341 3 489 9 493 17 497 21 501 22 505 23 405 24 409 25 413 26 417 27 421 30 425 31 509 32 429 33 433 34 1929 35 1033 40 1933 58 529 73 533 74 537 76 541 77 1937 78 549 79 553 80 557 81 561 82 565 87 569 93 573 94 577 95 581 96 585 97 589 98 1941 99 881 103 449 106 453 107 457 108 885 110 889 111 37 115 41 116 621 145 629 168 2357 181 1949 183 657 184 661 185 665 186 669 187 673 188 1953 189 1957 190 1961 191 1965 192 2397 193 677 194 681 195 685 196 689 197 693 198 697 199 701 200 705 201 709 202 713 203 717 204 721 205 725 206 729 207 733 208 737 209 741 210 745 211 749 229 753 230 757 231 761 232 765 237 769 253 773 257)#(2 742 14))! !!SmaCCGrammarParser methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCGrammarParser methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	super initialize.	grammar := SmaCCGrammar new! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForFile1: nodes 	^ grammar		addEmptySymbol;		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForIdMethodLine1: nodes 	(nodes at: 2) do: [:each | grammar makeTokenIdMethodFor: each].	^ nil! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForIdTokens1: nodes 	^ OrderedCollection with: (nodes at: 1) value! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForIdTokens2: nodes 	^ (nodes at: 1)		add: (nodes at: 2) value;		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForLeftLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				leftPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^ nil! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForNonAssociativeLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				nonAssociativePrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^ nil! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForParserRule1: nodes 	^ nodes at: 1! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForParserRule2: nodes 	^ self verifyCodeToken: (nodes at: 2) for: (nodes at: 1)! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForParserRules1: nodes 	^ (nodes at: 1)		add: (nodes at: 3);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForProductionRule1: nodes 	| symbol |	symbol := grammar nonTerminalSymbolNamed: (nodes at: 1) value.	(nodes at: 3) do: [:each | symbol addProduction: each].	^ symbol! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRightLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				rightPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^ nil! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRule1: nodes 	grammar setStartSymbolIfNone: (nodes at: 1).	^ nil! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerm1: nodes 	^ SmaCCRHS new! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerm2: nodes 	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerm3: nodes 	^ (nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerm4: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerm5: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerms1: nodes 	^ OrderedCollection with: (nodes at: 1)! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSimpleTerms2: nodes 	^ (nodes at: 1)		add: (nodes at: 3);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForStartingTokens1: nodes 	^ grammar 		addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 1) value)! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForStartingTokens2: nodes 	^ grammar 		addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 2) value)! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm1: nodes 	^ grammar keywordTerminalNamed: (nodes at: 1) value! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm2: nodes 	^ grammar terminalSymbolNamed: (nodes at: 1) value		ifAbsent: 			[currentToken := nodes at: 1.			self reportErrorMessage: 'Token not specified']! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm3: nodes 	^ grammar nonTerminalSymbolNamed: (nodes at: 1) value! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm4: nodes 	^ SmaCCSymbol error! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm5: nodes 	^ grammar makeGroupFor: (nodes at: 2)! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm6: nodes 	^ grammar makeRepeatSymbolFor: (grammar makeGroupFor: (nodes at: 2))! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerm7: nodes 	^ grammar makeOptionalSymbolFor: (grammar makeGroupFor: (nodes at: 2))! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms1: nodes 	^ SmaCCRHS new! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms2: nodes 	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms3: nodes 	^ (nodes at: 1)		add: (nodes at: 2);		nameLastItem: ((nodes at: 3) value copyFrom: 2					to: (nodes at: 3) value size - 1);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms4: nodes 	^ (nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms5: nodes 	^ (nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms6: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms7: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms8: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		yourself! !!SmaCCGrammarParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForTerms9: nodes 	^ (nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself! !!SmaCCGrammarParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:12'!reduceTable	^#(#(26 3 #reduceActionForIdMethodLine1:)#(27 3 #reduceFor:)#(28 1 #reduceFor:)#(28 2 #reduceFor:)#(29 1 #reduceActionForIdTokens1:)#(29 2 #reduceActionForIdTokens2:)#(30 1 #reduceActionForStartingTokens1:)#(30 2 #reduceActionForStartingTokens2:)#(31 3 #reduceActionForNonAssociativeLine1:)#(32 1 #reduceActionForTerm1:)#(32 1 #reduceActionForTerm2:)#(32 1 #reduceActionForTerm3:)#(32 1 #reduceActionForTerm4:)#(32 3 #reduceActionForTerm5:)#(32 3 #reduceActionForTerm6:)#(32 3 #reduceActionForTerm7:)#(33 1 #reduceFor:)#(34 4 #reduceActionForProductionRule1:)#(35 3 #reduceActionForParserRules1:)#(35 1 #reduceFor:)#(36 1 #reduceActionForParserRule1:)#(36 2 #reduceActionForParserRule2:)#(37 0 #reduceActionForTerms1:)#(37 2 #reduceActionForTerms2:)#(37 3 #reduceActionForTerms3:)#(37 3 #reduceActionForTerms4:)#(37 4 #reduceActionForTerms5:)#(37 3 #reduceActionForTerms6:)#(37 4 #reduceActionForTerms7:)#(37 3 #reduceActionForTerms8:)#(37 4 #reduceActionForTerms9:)#(38 3 #reduceActionForRightLine1:)#(39 1 #reduceActionForRule1:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(40 1 #reduceActionForFile1:)#(41 1 #reduceActionForSimpleTerms1:)#(41 3 #reduceActionForSimpleTerms2:)#(42 0 #reduceActionForSimpleTerm1:)#(42 2 #reduceActionForSimpleTerm2:)#(42 3 #reduceActionForSimpleTerm3:)#(42 3 #reduceActionForSimpleTerm4:)#(42 3 #reduceActionForSimpleTerm5:)#(45 1 #reduceFor:)#(45 2 #reduceFor:)#(46 3 #reduceActionForLeftLine1:))! !!SmaCCGrammarParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:12'!transitionTable	^#(#(3 9 1 13 3 17 4 21 6 25 8 29 20 33 26 37 27 41 31 45 34 49 38 53 39 57 40 61 45 65 46)#(3 69 20 73 30)#(3 77 11 81 13 85 15 89 17 93 19 97 20 101 21 105 28 109 32)#(3 113 19 117 29)#(3 77 11 81 13 85 15 89 17 93 19 97 20 101 21 121 28 109 32)#(3 77 11 81 13 85 15 89 17 93 19 97 20 101 21 125 28 109 32)#(2 129 25)#(2 150 1 3 4 6 8 20 43)#(2 154 1 3 4 6 8 20 43)#(2 146 1 3 4 6 8 20 43)#(2 134 1 3 4 6 8 20 43)#(2 142 1 3 4 6 8 20 43)#(2 190 1 3 4 6 8 20 43)#(2 0 43)#(3 9 1 13 3 17 4 21 6 25 8 29 20 33 26 37 27 41 31 45 34 49 38 133 39 158 43 65 46)#(2 138 1 3 4 6 8 20 43)#(2 30 7 20)#(3 137 7 141 20)#(3 170 2 170 9 170 11 170 13 170 15 170 17 170 19 170 20 170 21 145 41 149 42)#(3 170 9 170 11 170 12 170 13 170 15 170 17 170 19 170 20 170 21 153 41 149 42)#(2 54 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(3 170 9 170 11 170 13 170 14 170 15 170 17 170 19 170 20 170 21 157 41 149 42)#(2 46 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(2 50 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(2 42 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(3 161 7 77 11 81 13 85 15 89 17 93 19 97 20 101 21 165 32)#(2 14 7 11 13 15 17 19 20 21)#(2 22 7 19)#(3 169 7 173 19)#(3 177 7 77 11 81 13 85 15 89 17 93 19 97 20 101 21 165 32)#(3 181 7 77 11 81 13 85 15 89 17 93 19 97 20 101 21 165 32)#(3 94 7 94 9 94 11 94 13 94 15 94 17 94 19 94 20 94 21 94 23 185 35 189 36 193 37)#(2 194 1 3 4 6 8 20 43)#(2 10 1 3 4 6 8 20 43)#(2 34 7 20)#(3 197 2 201 9)#(3 162 2 162 9 77 11 162 12 81 13 162 14 85 15 89 17 93 19 97 20 101 21 205 32)#(3 201 9 209 12)#(3 201 9 213 14)#(2 38 1 3 4 6 8 20 43)#(2 18 7 11 13 15 17 19 20 21)#(2 6 1 3 4 6 8 20 43)#(2 26 7 19)#(2 198 1 3 4 6 8 20 43)#(2 130 1 3 4 6 8 20 43)#(3 217 7 221 9)#(2 82 7 9)#(3 86 7 86 9 77 11 81 13 85 15 89 17 93 19 97 20 101 21 225 23 229 32)#(2 66 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(3 170 2 170 9 170 11 170 12 170 13 170 14 170 15 170 17 170 19 170 20 170 21 233 42)#(3 174 2 237 5 174 9 241 10 174 11 174 12 174 13 174 14 174 15 245 16 174 17 174 19 174 20 174 21)#(2 62 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(2 58 2 5 7 9 10 11 12 13 14 15 16 17 19 20 21 23 24)#(2 74 1 3 4 6 8 20 43)#(3 94 7 94 9 94 11 94 13 94 15 94 17 94 19 94 20 94 21 94 23 249 36 193 37)#(2 90 7 9)#(3 253 5 98 7 98 9 257 10 98 11 98 13 98 15 261 16 98 17 98 19 98 20 98 21 98 23 265 24)#(3 166 2 166 9 77 11 166 12 81 13 166 14 85 15 89 17 93 19 97 20 101 21 205 32)#(2 178 2 9 11 12 13 14 15 17 19 20 21)#(2 182 2 9 11 12 13 14 15 17 19 20 21)#(2 186 2 9 11 12 13 14 15 17 19 20 21)#(2 78 7 9)#(3 106 7 106 9 106 11 106 13 106 15 106 17 106 19 106 20 106 21 106 23 269 24)#(3 114 7 114 9 114 11 114 13 114 15 114 17 114 19 114 20 114 21 114 23 273 24)#(3 122 7 122 9 122 11 122 13 122 15 122 17 122 19 122 20 122 21 122 23 277 24)#(2 102 7 9 11 13 15 17 19 20 21 23)#(2 110 7 9 11 13 15 17 19 20 21 23)#(2 118 7 9 11 13 15 17 19 20 21 23)#(2 126 7 9 11 13 15 17 19 20 21 23))! !!SmaCCGrammarParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!verifyCodeToken: codeToken for: aSmaCCRHS 	| code |	code := codeToken value copyFrom: 2 to: codeToken value size - 1.	RBParser parseExpression: code		onError: 			[:string :position | 			currentToken := nil.			scanner position: codeToken startPosition + position.			self reportErrorMessage: string].	aSmaCCRHS reduceAction: code.	^aSmaCCRHS! !!SmaCCParser class methodsFor: 'private' stamp: ' 6/1/07 20:34'!defaultStartingState	^1! !!SmaCCParser class methodsFor: 'private' stamp: ' 6/1/07 20:34'!scannerClass	^self subclassResponsibility! !!SmaCCParser class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aStream 	| parser scanner |	scanner := self scannerClass on: aStream.	parser := self new.	parser scanner: scanner.	^parser! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse: aString 	^self parse: aString startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parse: aString onError: aBlock 	^[self parse: aString] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse: aString startingAt: anInteger 	^self parseStream: (ReadStream on: aString) startingAt: anInteger! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parse: aString startingAt: anInteger onError: aBlock 	^[self parse: aString startingAt: anInteger] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parseStream: aStream 	^self parseStream: aStream startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parseStream: aStream onError: aBlock 	^[self parseStream: aStream] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parseStream: aStream startingAt: anInteger 	| parser |	parser := self on: aStream.	parser setStartingState: anInteger.	^parser parse! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parseStream: aStream startingAt: anInteger onError: aBlock 	^[self parseStream: aStream startingAt: anInteger] 		on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!CParser class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:13'!parserDefinitionComment	"%id <TypeName> <IDENTIFIER> <CONSTANT> ;translationUnit	: external_declaration	| translationUnit external_declaration	;primary_expression	: <IDENTIFIER>	| <CONSTANT>	| <STRING_LITERAL>	| ""("" expression "")""	;postfix_expression	: primary_expression	| postfix_expression <LEFT_BLOCK> expression <RIGHT_BLOCK>	| postfix_expression ""("" "")""	| postfix_expression ""("" argument_expression_list "")""	| postfix_expression ""."" <IDENTIFIER>	| postfix_expression ""->"" <IDENTIFIER>	| postfix_expression ""++""	| postfix_expression ""--""	;argument_expression_list	: assignment_expression	| argument_expression_list "","" assignment_expression	;unary_expression	: postfix_expression	| ""++"" unary_expression	| ""--"" unary_expression	| unary_operator cast_expression	| ""sizeof"" unary_expression	| ""sizeof"" ""("" type_name "")""	;unary_operator	: ""&""	| ""*""	| ""+""	| ""-""	| ""~""	| ""!!""	;cast_expression	: unary_expression	| ""("" type_name "")"" cast_expression	;multiplicative_expression	: cast_expression	| multiplicative_expression ""*"" cast_expression	| multiplicative_expression ""/"" cast_expression	| multiplicative_expression ""%"" cast_expression	;additive_expression	: multiplicative_expression	| additive_expression ""+"" multiplicative_expression	| additive_expression ""-"" multiplicative_expression	;shift_expression	: additive_expression	| shift_expression ""<<"" additive_expression	| shift_expression "">>"" additive_expression	;relational_expression	: shift_expression	| relational_expression ""<"" shift_expression	| relational_expression "">"" shift_expression	| relational_expression ""<="" shift_expression	| relational_expression "">="" shift_expression	;equality_expression	: relational_expression	| equality_expression ""=="" relational_expression	| equality_expression ""!!="" relational_expression	;and_expression	: equality_expression	| and_expression ""&"" equality_expression	;exclusive_or_expression	: and_expression	| exclusive_or_expression ""^"" and_expression	;inclusive_or_expression	: exclusive_or_expression	| inclusive_or_expression ""|"" exclusive_or_expression	;logical_and_expression	: inclusive_or_expression	| logical_and_expression ""&&"" inclusive_or_expression	;logical_or_expression	: logical_and_expression	| logical_or_expression ""||"" logical_and_expression	;conditional_expression	: logical_or_expression	| logical_or_expression ""?"" expression "":"" conditional_expression	;assignment_expression	: conditional_expression	| unary_expression assignment_operator assignment_expression	;assignment_operator	: ""=""	| ""*=""	| ""/=""	| ""%=""	| ""+=""	| ""-=""	| ""<<=""	| "">>=""	| ""&=""	| ""^=""	| ""|=""	;expression	: assignment_expression	| expression "","" assignment_expression	;constant_expression	: conditional_expression	;declaration	: declaration_specifiers "";""	| declaration_specifiers init_declarator_list "";""	;declaration_specifiers	: storage_class_specifier	| storage_class_specifier declaration_specifiers	| type_specifier	| type_specifier declaration_specifiers	| type_qualifier	| type_qualifier declaration_specifiers	;init_declarator_list	: init_declarator	| init_declarator_list "","" init_declarator	;init_declarator	: declarator	| declarator ""="" initializer	;storage_class_specifier	: ""typedef""	| ""extern""	| ""static""	| ""auto""	| ""register""	;type_specifier	: ""void""	| ""char""	| ""short""	| ""int""	| ""long""	| ""float""	| ""double""	| ""signed""	| ""unsigned""	| struct_or_union_specifier	| enum_specifier	| <TypeName>	;struct_or_union_specifier	: struct_or_union <IDENTIFIER> <LEFT_BRACE> struct_declaration_list <RIGHT_BRACE> {self addTypeName: '2' value. self reduceFor: nodes}	| struct_or_union <LEFT_BRACE> struct_declaration_list <RIGHT_BRACE>	| struct_or_union <IDENTIFIER> {self addTypeName: '2' value. self reduceFor: nodes}	;struct_or_union	: ""struct""	| ""union""	;struct_declaration_list	: struct_declaration	| struct_declaration_list struct_declaration	;struct_declaration	: specifier_qualifier_list struct_declarator_list "";""	;specifier_qualifier_list	: type_specifier specifier_qualifier_list	| type_specifier	| type_qualifier specifier_qualifier_list	| type_qualifier	;struct_declarator_list	: struct_declarator	| struct_declarator_list "","" struct_declarator	;struct_declarator	: declarator	| "":"" constant_expression	| declarator "":"" constant_expression	;enum_specifier	: ""enum"" <LEFT_BRACE> enumerator_list <RIGHT_BRACE>	| ""enum"" <IDENTIFIER> <LEFT_BRACE> enumerator_list <RIGHT_BRACE>  {self addTypeName: '2' value. self reduceFor: nodes}	| ""enum"" <IDENTIFIER>  {self addTypeName: '2' value. self reduceFor: nodes}	;enumerator_list	: enumerator	| enumerator_list "","" enumerator	;enumerator	: <IDENTIFIER>	| <IDENTIFIER> ""="" constant_expression	;type_qualifier	: ""const""	| ""volatile""	;declarator	: pointer direct_declarator	| direct_declarator	;direct_declarator	: <IDENTIFIER>	| ""("" declarator "")""	| direct_declarator <LEFT_BLOCK> constant_expression <RIGHT_BLOCK>	| direct_declarator <LEFT_BLOCK> <RIGHT_BLOCK>	| direct_declarator ""("" parameter_type_list "")""	| direct_declarator ""("" identifier_list "")""	| direct_declarator ""("" "")""	;pointer	: ""*""	| ""*"" type_qualifier_list	| ""*"" pointer	| ""*"" type_qualifier_list pointer	;type_qualifier_list	: type_qualifier	| type_qualifier_list type_qualifier	;parameter_type_list	: parameter_list	| parameter_list "","" <ELLIPSIS>	;parameter_list	: parameter_declaration	| parameter_list "","" parameter_declaration	;parameter_declaration	: declaration_specifiers declarator	| declaration_specifiers abstract_declarator	| declaration_specifiers	;identifier_list	: <IDENTIFIER>	| identifier_list "","" <IDENTIFIER>	;type_name	: specifier_qualifier_list	| specifier_qualifier_list abstract_declarator	;abstract_declarator	: pointer	| direct_abstract_declarator	| pointer direct_abstract_declarator	;direct_abstract_declarator	: ""("" abstract_declarator "")""	| <LEFT_BLOCK> <RIGHT_BLOCK>	| <LEFT_BLOCK> constant_expression <RIGHT_BLOCK>	| direct_abstract_declarator <LEFT_BLOCK> <RIGHT_BLOCK>	| direct_abstract_declarator <LEFT_BLOCK> constant_expression <RIGHT_BLOCK>	| ""("" "")""	| ""("" parameter_type_list "")""	| direct_abstract_declarator ""("" "")""	| direct_abstract_declarator ""("" parameter_type_list "")""	;initializer	: assignment_expression	| <LEFT_BRACE> initializer_list <RIGHT_BRACE>	| <LEFT_BRACE> initializer_list "","" <RIGHT_BRACE>	;initializer_list	: initializer	| initializer_list "","" initializer	;statement	: labeled_statement	| compound_statement	| expression_statement	| selection_statement	| iteration_statement	| jump_statement	;labeled_statement	: <IDENTIFIER> "":"" statement	| ""case"" constant_expression "":"" statement	| ""default"" "":"" statement	;compound_statement	: <LEFT_BRACE> <RIGHT_BRACE>	| <LEFT_BRACE> statement_list <RIGHT_BRACE>	| <LEFT_BRACE> declaration_list <RIGHT_BRACE>	| <LEFT_BRACE> declaration_list statement_list <RIGHT_BRACE>	;declaration_list	: declaration	| declaration_list declaration	;statement_list	: statement	| statement_list statement	;expression_statement	: "";""	| expression "";""	;selection_statement	: ""if"" ""("" expression "")"" statement	| ""if"" ""("" expression "")"" statement ""else"" statement	| ""switch"" ""("" expression "")"" statement	;iteration_statement	: ""while"" ""("" expression "")"" statement	| ""do"" statement ""while"" ""("" expression "")"" "";""	| ""for"" ""("" expression_statement expression_statement "")"" statement	| ""for"" ""("" expression_statement expression_statement expression "")"" statement	;jump_statement	: ""goto"" <IDENTIFIER> "";""	| ""continue"" "";""	| ""break"" "";""	| ""return"" "";""	| ""return"" expression "";""	;external_declaration	: function_definition	| declaration	;function_definition	: declaration_specifiers declarator declaration_list compound_statement	| declaration_specifiers declarator compound_statement	| declarator declaration_list compound_statement	| declarator compound_statement	;"! !!CParser class methodsFor: 'generated-accessing' stamp: 'lr 1/22/2007 13:13'!scannerClass	^CScanner! !!CParser class methodsFor: 'generated-starting states' stamp: 'lr 1/22/2007 13:13'!startingStateFortranslationUnit	^1! !!JavaParser class methodsFor: 'generated-comments' stamp: 'jws 10/23/2016 05:59'!parserDefinitionComment	"goal :	compilation_unit	;# 19.3) Lexical Structure.literal :	<INTEGER_LITERAL>	|	<FLOATING_POINT_LITERAL>	|	<BOOLEAN_LITERAL>#	| 	""true""#	| 	""false""	|	<CHARACTER_LITERAL>	|	<STRING_LITERAL>	|	<NULL_LITERAL>	;# 19.4) Types, Values, and Variablestype	:	primitive_type	|	reference_type	;primitive_type :		numeric_type	|	""boolean""	;numeric_type:	integral_type	|	floating_point_type	;integral_type : 		""byte"" 	|	""short"" 	|	""int"" 	|	""long"" 	|	""char"" 	;floating_point_type : 		""float"" 	|	""double""	;reference_type :		class_or_interface_type	|	array_type	;class_or_interface_type : name;class_type :	class_or_interface_type;interface_type : class_or_interface_type;		array_type :	primitive_type dims	|	name dims	;# 19.5) Namesname	:	simple_name	|	qualified_name	;simple_name :	<IDENTIFIER>	;qualified_name :		name ""."" <IDENTIFIER>	;# 19.6) ""package""scompilation_unit :		package_declaration_opt 		import_declarations_opt		type_declarations_opt		;package_declaration_opt : package_declaration | ;import_declarations_opt : import_declarations | ;type_declarations_opt   : type_declarations   | ;import_declarations : 		import_declaration	|	import_declarations import_declaration	;type_declarations : 		type_declaration	|	type_declarations type_declaration	;package_declaration : 		""package"" name "";""	;import_declaration : 		single_type_import_declaration	|	type_import_on_demand_declaration	;single_type_import_declaration : 		""import"" name "";""	;type_import_on_demand_declaration :		""import"" name ""."" ""*"" "";""	;type_declaration :		class_declaration	|	interface_declaration	|	"";""	;# 19.7) Productions used only in the LALR(1) grammarmodifiers_opt:	|	modifiers	;modifiers : 	modifier	|	modifiers modifier	;modifier :	""public"" | ""protected"" | ""private""	|	""static""	|	""abstract"" | ""final"" | ""native"" | ""synchronized"" | ""transient"" | ""volatile""	|	""strictfp"" # note that semantic analysis must check that the	                 # context of the modifier allows strictfp.	;# 19.8) Classes# 19.8.1) Class Declaration:class_declaration : 	modifiers_opt ""class"" <IDENTIFIER> super_opt interfaces_opt class_body	;super :	""extends"" class_type	;super_opt :		|	super	;interfaces :	""implements"" interface_type_list	;interfaces_opt:	|	interfaces 	;interface_type_list : 		interface_type	|	interface_type_list "","" interface_type	;class_body :	""{"" class_body_declarations_opt ""}"" 	;class_body_declarations_opt : 	|	class_body_declarations ;class_body_declarations : 		class_body_declaration	|	class_body_declarations class_body_declaration	;class_body_declaration :		class_member_declaration	|	static_initializer	|	constructor_declaration	|	block	;class_member_declaration :		field_declaration	|	method_declaration	# repeat the prod for 'class_declaration' here: 	|	modifiers_opt ""class"" <IDENTIFIER> super_opt interfaces_opt class_body	|	interface_declaration	|	"";""	;# 19.8.2) Field Declarationsfield_declaration : 		modifiers_opt type variable_declarators "";""	;variable_declarators :		variable_declarator	|	variable_declarators "","" variable_declarator	;variable_declarator :		variable_declarator_id	|	variable_declarator_id ""="" variable_initializer	;variable_declarator_id :		<IDENTIFIER>	|	variable_declarator_id ""["" ""]""	;variable_initializer :		expression	|	array_initializer	;# 19.8.3) Method Declarationsmethod_declaration :		method_header method_body	;method_header :		modifiers_opt type method_declarator throws_opt	|	modifiers_opt ""void"" method_declarator throws_opt	;method_declarator :		<IDENTIFIER> ""("" formal_parameter_list_opt "")""	|	method_declarator ""["" ""]"" # deprecated	# be careful; the above production also allows 'void foo() []'	;formal_parameter_list_opt :	|	formal_parameter_list	;formal_parameter_list :		formal_parameter	|	formal_parameter_list "","" formal_parameter	;formal_parameter :		type variable_declarator_id	|	""final"" type variable_declarator_id	;throws_opt :		|	throws	;throws :	""throws"" class_type_list	;class_type_list :		class_type	|	class_type_list "","" class_type	;method_body :	block	|	"";""	;# 19.8.4) Static Initializersstatic_initializer :		""static"" block	;# 19.8.5) Constructor Declarationsconstructor_declaration :		modifiers_opt constructor_declarator throws_opt 			constructor_body	;constructor_declarator :		simple_name ""("" formal_parameter_list_opt "")""	;constructor_body :		""{"" explicit_constructor_invocation			block_statements ""}""	|	""{"" explicit_constructor_invocation ""}""	|	""{"" block_statements ""}""	|	""{"" ""}""	;explicit_constructor_invocation :		""this"" ""("" argument_list_opt "")"" "";""	|	""super"" ""("" argument_list_opt "")"" "";""	|	primary ""."" ""this"" ""("" argument_list_opt "")"" "";""	|	primary ""."" ""super"" ""("" argument_list_opt "")"" "";""	;# 19.9) Interfaces# 19.9.1) Interface Declarationsinterface_declaration :		modifiers_opt ""interface"" <IDENTIFIER> extends_interfaces_opt 			interface_body	;extends_interfaces_opt :	|	extends_interfaces	;extends_interfaces :		""extends"" interface_type	|	extends_interfaces "","" interface_type	;interface_body :		""{"" interface_member_declarations_opt ""}""	;interface_member_declarations_opt :	|	interface_member_declarations	;interface_member_declarations :		interface_member_declaration	|	interface_member_declarations interface_member_declaration	;interface_member_declaration :		constant_declaration	|	abstract_method_declaration	|	class_declaration	|	interface_declaration	;constant_declaration :		field_declaration	# need to semantically check that modifiers of field declaration	# include only PUBLIC, ""static"", or ""final"".  Other modifiers are	# disallowed.	;abstract_method_declaration :		method_header "";""	;# 19.10) Arraysarray_initializer :		""{"" variable_initializers "","" ""}""	|	""{"" variable_initializers ""}""	|	""{"" "","" ""}""	|	""{"" ""}""	;variable_initializers :		variable_initializer	|	variable_initializers "","" variable_initializer	;# 19.11) Blocks and Statementsblock :	""{"" block_statements_opt ""}""	;block_statements_opt :	|	block_statements	;block_statements :		block_statement	|	block_statements block_statement	;block_statement :		local_variable_declaration_statement	|	statement	|	class_declaration	|	interface_declaration	;local_variable_declaration_statement :		local_variable_declaration "";""	;local_variable_declaration :		type variable_declarators	|	""final"" type variable_declarators	;statement :	statement_without_trailing_substatement	|	labeled_statement	|	if_then_statement	|	if_then_else_statement	|	while_statement	|	for_statement	;statement_no_short_if :		statement_without_trailing_substatement	|	labeled_statement_no_short_if	|	if_then_else_statement_no_short_if	|	while_statement_no_short_if	|	for_statement_no_short_if	;statement_without_trailing_substatement :		block	|	empty_statement	|	expression_statement	|	switch_statement	|	do_statement	|	break_statement	|	continue_statement	|	return_statement	|	synchronized_statement	|	throw_statement	|	try_statement	;empty_statement :		"";""	;labeled_statement :		<IDENTIFIER> "":"" statement	;labeled_statement_no_short_if :		<IDENTIFIER> "":"" statement_no_short_if	;expression_statement :		statement_expression "";""	;statement_expression :		assignment	|	preincrement_expression	|	predecrement_expression	|	postincrement_expression	|	postdecrement_expression	|	method_invocation	|	class_instance_creation_expression	;if_then_statement :		""if"" ""("" expression "")"" statement	;if_then_else_statement :		""if"" ""("" expression "")"" statement_no_short_if 			""else"" statement	;if_then_else_statement_no_short_if :		""if"" ""("" expression "")"" statement_no_short_if			""else"" statement_no_short_if	;switch_statement :		""switch"" ""("" expression "")"" switch_block	;switch_block :		""{"" switch_block_statement_groups switch_labels ""}""	|	""{"" switch_block_statement_groups ""}""	|	""{"" switch_labels ""}""	|	""{"" ""}""	;switch_block_statement_groups :		switch_block_statement_group	|	switch_block_statement_groups switch_block_statement_group	;switch_block_statement_group :		switch_labels block_statements	;switch_labels :		switch_label	|	switch_labels switch_label	;switch_label :		""case"" constant_expression "":""	|	""default"" "":""	;while_statement :		""while"" ""("" expression "")"" statement	;while_statement_no_short_if :		""while"" ""("" expression "")"" statement_no_short_if	;do_statement :		""do"" statement ""while"" ""("" expression "")"" "";""	;for_statement :		""for"" ""("" for_init_opt "";"" expression_opt "";""			for_update_opt "")"" statement	;for_statement_no_short_if :		""for"" ""("" for_init_opt "";"" expression_opt "";""			for_update_opt "")"" statement_no_short_if	;for_init_opt :	|	for_init	;for_init :	statement_expression_list	|	local_variable_declaration	;for_update_opt :	|	for_update	;for_update :	statement_expression_list	;statement_expression_list :		statement_expression	|	statement_expression_list "","" statement_expression	;identifier_opt : 	|	<IDENTIFIER>	;break_statement :		""break"" identifier_opt "";""	;continue_statement :		""continue"" identifier_opt "";""	;return_statement :		""return"" expression_opt "";""	;throw_statement :		""throw"" expression "";""	;synchronized_statement :		""synchronized"" ""("" expression "")"" block	;try_statement :		""try"" block catches	|	""try"" block catches_opt finally	;catches_opt :	|	catches	;catches :	catch_clause	|	catches catch_clause	;catch_clause :		""catch"" ""("" formal_parameter "")"" block	;finally :	""finally"" block	;# 19.12) Expressionsprimary :	primary_no_new_array	|	array_creation_expression	;primary_no_new_array :		literal	|	""this""	|	""("" expression "")""	|	class_instance_creation_expression	|	field_access	|	method_invocation	|	array_access	|	primitive_type ""."" ""class""	|	""void"" ""."" ""class""	|	array_type ""."" ""class""	|	name ""."" ""class""	|	name ""."" ""this""	;class_instance_creation_expression :		""new"" class_type ""("" argument_list_opt "")""	|	""new"" class_type ""("" argument_list_opt "")"" class_body	|	primary ""."" ""new"" <IDENTIFIER>			""("" argument_list_opt "")""	|	primary ""."" ""new"" <IDENTIFIER>			""("" argument_list_opt "")"" class_body	;argument_list_opt :	|	argument_list	;argument_list :		expression	|	argument_list "","" expression	;array_creation_expression :		""new"" primitive_type dim_exprs dims_opt	|	""new"" class_or_interface_type dim_exprs dims_opt	|	""new"" primitive_type dims array_initializer	|	""new"" class_or_interface_type dims array_initializer	;dim_exprs :	dim_expr	|	dim_exprs dim_expr	;dim_expr :	""["" expression ""]""	;dims_opt :	|	dims	;dims :	""["" ""]""	|	dims ""["" ""]""	;field_access :		primary ""."" <IDENTIFIER>	|	""super"" ""."" <IDENTIFIER>	|	name ""."" ""super"" ""."" <IDENTIFIER>	;method_invocation :		name ""("" argument_list_opt "")""	|	primary ""."" <IDENTIFIER> ""("" argument_list_opt "")""	|	""super"" ""."" <IDENTIFIER> ""("" argument_list_opt "")""	|	name ""."" ""super"" ""."" <IDENTIFIER> ""("" argument_list_opt "")""	;array_access :		name ""["" expression ""]""	|	primary_no_new_array ""["" expression ""]""	;postfix_expression :		primary	|	name	|	postincrement_expression	|	postdecrement_expression	;postincrement_expression :		postfix_expression ""++""	;postdecrement_expression :		postfix_expression ""--""	;unary_expression :		preincrement_expression	|	predecrement_expression	|	""+"" unary_expression	|	""-"" unary_expression	|	unary_expression_not_plus_minus	;preincrement_expression :		""++"" unary_expression	;predecrement_expression :		""--"" unary_expression	;unary_expression_not_plus_minus :		postfix_expression	|	""~"" unary_expression	|	""!!"" unary_expression	|	cast_expression	;cast_expression :		""("" primitive_type dims_opt "")"" unary_expression	|	""("" expression "")"" unary_expression_not_plus_minus	|	""("" name dims "")"" unary_expression_not_plus_minus	;multiplicative_expression :		unary_expression	|	multiplicative_expression ""*"" unary_expression	|	multiplicative_expression ""/"" unary_expression	|	multiplicative_expression ""%"" unary_expression	;additive_expression :		multiplicative_expression	|	additive_expression ""+"" multiplicative_expression	|	additive_expression ""-"" multiplicative_expression	;shift_expression :		additive_expression	|	shift_expression ""<<"" additive_expression	|	shift_expression "">>"" additive_expression	|	shift_expression "">>>"" additive_expression	;relational_expression :		shift_expression	|	relational_expression ""<"" shift_expression	|	relational_expression "">"" shift_expression	|	relational_expression ""<="" shift_expression	|	relational_expression "">="" shift_expression	|	relational_expression ""instanceof"" reference_type	;equality_expression :		relational_expression	|	equality_expression ""=="" relational_expression	|	equality_expression ""!!="" relational_expression	;and_expression :		equality_expression	|	and_expression ""&"" equality_expression	;exclusive_or_expression :		and_expression	|	exclusive_or_expression ""^"" and_expression	;inclusive_or_expression :		exclusive_or_expression	|	inclusive_or_expression ""|"" exclusive_or_expression	;conditional_and_expression :		inclusive_or_expression	|	conditional_and_expression ""&&"" inclusive_or_expression	;conditional_or_expression :		conditional_and_expression	|	conditional_or_expression ""||"" conditional_and_expression	;conditional_expression :		conditional_or_expression	|	conditional_or_expression ""?"" expression 			"":"" conditional_expression	;assignment_expression :		conditional_expression	|	assignment	;assignment :	left_hand_side assignment_operator assignment_expression	;left_hand_side :		name	|	field_access	|	array_access	;assignment_operator :		""=""	|	""*=""	|	""/=""	|	""%=""	|	""+=""	|	""-=""	|	""<<=""	|	"">>=""	|	"">>>=""	|	""&=""	|	""^=""	|	""|=""	;expression_opt :	|	expression	;expression :	assignment_expression	;constant_expression :		expression	;"! !!JavaParser class methodsFor: 'generated-accessing' stamp: 'jws 10/23/2016 05:59'!scannerClass	^JavaScanner! !!JavaParser class methodsFor: 'generated-starting states' stamp: 'jws 10/23/2016 05:59'!startingStateForgoal	^1! !!SmaCCGrammarParser class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:12'!parserDefinitionComment	"File:	Parser {grammar addEmptySymbol; yourself};Parser:	Rule	| Parser Rule ;Rule : ProductionRule {grammar setStartSymbolIfNone: '1'. nil}	| LeftLine 	| RightLine 	| NonAssociativeLine	| IdMethodLine	| StartLine ;LeftLine:	""%left"" TokenList 'tokens' "";"" { tokens do: [:each | grammar leftPrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };RightLine:	""%right"" TokenList 'tokens' "";"" { tokens do: [:each | grammar rightPrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };NonAssociativeLine: ""%nonassoc"" TokenList 'tokens' "";"" { tokens do: [:each | grammar nonAssociativePrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };IdMethodLine: ""%id"" IdTokens 'tokens' "";"" {tokens do: [:each | grammar makeTokenIdMethodFor: each]. nil};StartLine: ""%start"" StartingTokens "";"";IdTokens: <tokenname> {OrderedCollection with: '1' value}	| IdTokens <tokenname> {'1' add: '2' value; yourself};TokenList:	Term	| TokenList Term	;StartingTokens: <symbolname> 'symbol' {grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)}	| StartingTokens <symbolname> 'symbol' {grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)};ProductionRule: <symbolname> <production> ParserRules "";"" {| symbol | symbol := grammar nonTerminalSymbolNamed: '1' value. '3' do: [:each | symbol addProduction: each]. symbol};ParserRules:	ParserRules ""|"" ParserRule {'1' add: '3'; yourself}	| ParserRule	 ;ParserRule : Terms 'rhs' {rhs}	| Terms 'rhs' <code> 'code' {self verifyCodeToken: code for: rhs} ;Terms :	{SmaCCRHS new}	| Terms 'rhs' Term 'term'	{rhs add: term; yourself}		| Terms 'rhs' Term 'term' <variablename> 'variableNameToken'	{rhs add: term; nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}		| Terms 'rhs' Term 'term' ""?"" {rhs add: (grammar makeOptionalSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""?"" <variablename> 'variableNameToken' {rhs add: (grammar makeOptionalSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}		| Terms 'rhs' Term 'term' ""*"" {rhs add: (grammar makeRepeatSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""*"" <variablename> 'variableNameToken' {rhs add: (grammar makeRepeatSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}			| Terms 'rhs' Term 'term' ""+"" {rhs add: (grammar makeRepeatMultipleSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""+"" <variablename> 'variableNameToken' {rhs add: (grammar makeRepeatMultipleSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}	;Term:	<keyword> {grammar keywordTerminalNamed: '1' value}	| <tokenname> {grammar terminalSymbolNamed: '1' value ifAbsent: [currentToken := '1'. self reportErrorMessage: 'Token not specified']}	| <symbolname> {grammar nonTerminalSymbolNamed: '1' value}	| ""error"" {SmaCCSymbol error}	| ""("" SimpleTerms "")"" {grammar makeGroupFor: '2'}	| ""<%"" SimpleTerms ""%>"" {grammar makeRepeatSymbolFor: (grammar makeGroupFor: '2')}	| ""["" SimpleTerms ""]"" {grammar makeOptionalSymbolFor: (grammar makeGroupFor: '2')};SimpleTerms :	SimpleTerm {OrderedCollection with: '1'}	| SimpleTerms 'terms' ""|"" SimpleTerm 'term' {terms add: term; yourself};SimpleTerm :	{ SmaCCRHS new }	| SimpleTerm 'rhs' Term 'term' {rhs add: term; yourself} 	| SimpleTerm 'rhs' Term 'term' ""?"" {rhs add: (grammar makeOptionalSymbolFor: term); yourself}	| SimpleTerm 'rhs' Term 'term' ""*"" {rhs add: (grammar makeRepeatSymbolFor: term); yourself}	| SimpleTerm 'rhs' Term 'term' ""+"" {rhs add: (grammar makeRepeatMultipleSymbolFor: term); yourself}	;"! !!SmaCCGrammarParser class methodsFor: 'generated-accessing' stamp: 'lr 1/22/2007 13:12'!scannerClass	^SmaCCGrammarScanner! !!SmaCCGrammarParser class methodsFor: 'generated-starting states' stamp: 'lr 1/22/2007 13:12'!startingStateForFile	^1! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/20/2003 15:51'!acceptParserCode: aStringOrAText notifying: aRequestor | scannerText |scannerText := self scannerCodeHolder contentsMorph text.	^ [SmaCCGrammarCompiler new buildScanner: scannerText andParser: aStringOrAText.	true]		on: SmaCCParserError		do: [:ex | 			self tabList selectTabNamed: 'Parser'.			self				displayError: ex description				at: ex tag position				notifying: aRequestor.			ex return: false]! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/20/2003 15:22'!acceptScannerCode: aStringOrAText notifying: aRequestor 	SmaCCScannerParser		parse: aStringOrAText		onError: [:aString :position | 			| morph | 			self tabList selectTabNamed: 'Scanner'.			self				displayError: aString				at: position				notifying: aRequestor.			^ false].	^ true! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/18/2003 19:54'!acceptTestCode: aStringOrAText notifying: aRequestor 	| class |	class := self parserClass.	class isNil		ifTrue: [PopUpMenu inform: 'No parser defined'.			^ false].^self parse! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 2/15/2003 12:55'!choose: aString from: aCollection 	| choice |	choice := (PopUpMenu labelArray: aCollection)				startUpWithCaption: aString withCRs.	choice > 0		ifTrue: [^ aCollection at: choice].	^ nil ! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 2/15/2003 12:55'!compileLALR1		self compile: #LALR1! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 1/18/2003 14:41'!compileLR1	self compile: #LR1! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'lr 1/8/2007 22:54'!findParserClass	| className class text |	self scannerClassString isEmpty		ifTrue: [^ PopUpMenu inform: 'Undefined scanner class'].	className := self choose: 'What class do you want to use?' from: (SmaCCParser allSubclasses					collect: [:c | c name]) asSortedCollection.	className notNil		ifTrue: [parserClassMorph hResizing: #rigid.			parserClassMorph newContents: '';				 newContents: className.			parserClassMorph changed: #updateWindowLabel.			class := Smalltalk at: className asSymbol.			(class class includesSelector: #parserDefinitionComment)				ifTrue: [true "(PopUpMenu confirm: 'Do you wish to load the parser definition?')"						ifTrue: [text := self										removeCommentedPartOf: (class class sourceCodeAt: #parserDefinitionComment).							self parserText: text]]]! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'lr 1/8/2007 22:55'!findScannerClass	| className class text |	className := self choose: 'What class do you want to use?' from: (SmaCCScanner allSubclasses					collect: [:c | c name]) asSortedCollection.	className notNil		ifTrue: [scannerClassMorph newContents: '';				 newContents: className.			scannerClassMorph changed: #updateWindowLabel.			class := Smalltalk at: className asSymbol.			(class class includesSelector: #scannerDefinitionComment)				ifTrue: [true "(PopUpMenu confirm: 'Do you wish to load the scanner definition?')"						ifTrue: [text := self										removeCommentedPartOf: (class class sourceCodeAt: #scannerDefinitionComment).							self scannerText: text]]]! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/18/2003 20:03'!parse	self		parseAndEvaluate: [:each | 			PopUpMenu inform: 'Parses without errors'.			^true]. ^false! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/20/2003 16:13'!parseAndEvaluate: aBlock 	| class |	self testCodeHolder acceptContents: self testText.	self testCodeHolder changed: #contents.	class := self parserClass.	class isNil		ifTrue: [PopUpMenu inform: 'No parser defined'.			^ false]		ifFalse: [Cursor wait showWhile: [aBlock				value: (class						parse: self testText						onError: [:aString :position | 							self								displayError: aString								at: position								notifying: self testCodeHolder contentsMorph.							self testCodeHolder hasUnacceptedEdits: true.							^ false])]].	^ true! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'md 4/3/2003 14:03'!parseAndExplore	^self			parseAndEvaluate: [:each | each explore]! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/18/2003 20:01'!parseAndInspect	^self			parseAndEvaluate: [:each | each inspect]! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 1/22/2003 15:25'!toggleGenerateDefinitionComments	generateDefinitionComments:=self generateDefinitionComments not! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 1/22/2003 15:28'!toggleGenerateItemSetComments	generateItemSetComments:=self generateItemSetComments not! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 1/22/2003 15:28'!toggleGenerateSymbolComments	generateSymbolComments:=self generateSymbolComments not! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'mga 1/22/2003 15:25'!toggleIgnoreCase	ignoreCase:= self ignoreCase not! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'apl 2/20/2003 18:14'!update: anObjectOrASymbol 	(anObjectOrASymbol isKindOf: Symbol)		ifTrue: [(self respondsTo: anObjectOrASymbol)				ifTrue: [self perform: anObjectOrASymbol]].	super update: anObjectOrASymbol! !!SmaCCParserGenerator methodsFor: 'actions' stamp: 'lr 1/8/2007 22:58'!updateWindowLabel	| scannerLabel parserLabel |	scannerLabel := self scannerClassString isEmpty ifFalse: [self scannerClassString] ifTrue: ['Undefined'].	parserLabel := self parserClassString isEmpty ifFalse: [self parserClassString] ifTrue: ['Undefined'].	^ self mainWindow setLabel: self defaultWindowLabelPrefix , ': ' ,  scannerLabel , '/' , parserLabel! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:22'!addButtonsToTestPage: aTestPage 	| aParserButton aParserInspectButton aParserExploreButton |	aParserButton := PluggableButtonMorph				on: self				getState: nil				action: #parse.	aParserButton hResizing: #spaceFill;		 vResizing: #shrinkWrap;		 		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 label: 'Parse'.	aParserInspectButton := PluggableButtonMorph				on: self				getState: nil				action: #parseAndInspect.	aParserInspectButton hResizing: #spaceFill;		 vResizing: #shrinkWrap;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 label: 'Parse and inspect'.	aParserExploreButton := PluggableButtonMorph				on: self				getState: nil				action: #parseAndExplore.	aParserExploreButton hResizing: #spaceFill;		 vResizing: #shrinkWrap;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 label: 'Parse and explore'.	aTestPage		addMorph: aParserButton		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 0.33 @ 1)				offsets: (0 @ (1 - 25) corner: 0 @ 0));			addMorph: aParserInspectButton		fullFrame: (LayoutFrame				fractions: (0.33 @ 1 corner: 0.66 @ 1)				offsets: (0 @ (1 - 25) corner: 0 @ 0));		addMorph: aParserExploreButton		fullFrame: (LayoutFrame				fractions: (0.66 @ 1 corner: 1 @ 1)				offsets: (0 @ (1 - 25) corner: 0 @ 0))! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'mga 2/15/2003 12:54'!addCheckBoxesToCompilePage: aCompilePage	#(#(#toggleIgnoreCase #ignoreCase 'Ignore Case') #(#toggleGenerateDefinitionComments #generateDefinitionComments 'Generate definition comments') #(#toggleGenerateSymbolComments #generateSymbolComments 'Generate symbol comments') #(#toggleGenerateItemSetComments #generateItemSetComments 'Generate item set comments') )		withIndexDo: [:each :anIndex | 			| aButton | 			aButton := UpdatingThreePhaseButtonMorph checkBox.			aButton target: self;				 actionSelector: each first;				 arguments: #();				 getSelector: each second;				 position: 10 @ 40 + (anIndex * (0 @ 20)).			aCompilePage addMorph: (each last asMorph position: 30 @ 40 + (anIndex * (0 @ 20));					 yourself);				 addMorph: aButton]! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:22'!addClassSelectorsToCompilePage: aCompilePage 	| aScannerLabel aParserLabel |	aScannerLabel := 'Scanner class:' asMorph position: 10 @ 10.	aParserLabel := 'Parser class:' asMorph position: 10 @ 30.	findScannerClassButton := PluggableButtonMorph				on: self				getState: nil				action: #findScannerClass.	findScannerClassButton label: ' ... ';		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 position: 410 @ 6.	findParserClassButton := PluggableButtonMorph				on: self				getState: nil				action: #findParserClass.	findParserClassButton label: ' ... ';		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 position: 410 @ 26.	scannerClassMorph := TextMorph new newContents: '';				 borderWidth: 0;				 extent: 300 @ 70;				 position: 100 @ 8.	scannerClassMorph		on: #keyStroke		send: #updateWindowLabel		to: self.	scannerClassMorph addDependent: self.	parserClassMorph := TextMorph new newContents: '';				 borderWidth: 0;				 extent: 300 @ 70;				 position: 100 @ 28.	parserClassMorph		on: #keyStroke		send: #updateWindowLabel		to: self.	parserClassMorph addDependent: self.	{aScannerLabel. aParserLabel. scannerClassMorph. parserClassMorph. findScannerClassButton. findParserClassButton}		do: [:e | aCompilePage addMorph: e]! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:21'!addCompileButtonsToCompilePage: aCompilePage 	| aLALRButton aLR1Button | 	aLALRButton := PluggableButtonMorph				on: self				getState: nil				action: #compileLALR1.	aLALRButton label: 'Compile LALR(1)';		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 position: 10 @ 140.	aCompilePage addMorph: aLALRButton.	aLR1Button := PluggableButtonMorph				on: self				getState: nil				action: #compileLR1.	aLR1Button label: 'Compile LR(1)';		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor lighter;		 position: 150 @ 140.	aCompilePage addMorph: aLR1Button! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'apl 2/20/2003 16:23'!addMessageBoxToCompilePage: aCompilePage 	aCompilePage addMorph: ('Messages:' asMorph position: 10 @ 180;			 yourself).	self conflictTextMorph: (PluggableTextMorph				on: self				text: #conflicts				accept: nil				readSelection: nil				menu: nil).	aCompilePage		addMorph: (self conflictTextMorph)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (10 @ 200 corner: -10 @ -10))! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:02'!addTextToTestPage: aTestPage 	| aTestText |	testCodeHolder := SmaCCCodeHolder owner: self ownerAcceptSelector: #acceptTestCode:notifying:.	aTestText := testCodeHolder contentsMorph.	aTestText setNameTo: 'Test';		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 color: Color transparent;		borderWidth: 0.	aTestPage		addMorph: aTestText		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ -25))! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'apl 2/18/2003 13:39'!createCompilePage	| aCompilePage |	aCompilePage := (Morph new)				layoutPolicy: ProportionalLayout new;				hResizing: #spaceFill;				vResizing: #spaceFill;				setNameTo: 'Compile';				color: Color transparent.	self tabList addTabFor: aCompilePage font: TextStyle defaultFont.	self		addClassSelectorsToCompilePage: aCompilePage;		addCompileButtonsToCompilePage: aCompilePage;		addCheckBoxesToCompilePage: aCompilePage;		addMessageBoxToCompilePage: aCompilePage! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:18'!createParserPage	| aParserPage |	parserCodeHolder := SmaCCCodeHolder owner: self				ownerAcceptSelector: #acceptParserCode:notifying:.	aParserPage := parserCodeHolder contentsMorph.	aParserPage		setNameTo: 'Parser';		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 0.	self tabList addTabFor: aParserPage font: TextStyle defaultFont! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:18'!createScannerPage	| aScannerPage |	scannerCodeHolder := SmaCCCodeHolder owner: self				ownerAcceptSelector: #acceptScannerCode:notifying:.	aScannerPage := scannerCodeHolder contentsMorph.	aScannerPage		setNameTo: 'Scanner';		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 0.	self tabList addTabFor: aScannerPage font: TextStyle defaultFont! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'jws 10/24/2016 08:29'!createTabbedPalette	self tabList: TabbedPalette new.	self tabList color: Color gray veryMuchLighter.	self tabList tabsMorph color: self defaultBackgroundColor.	self tabList tabsMorph highlightColor: Color black regularColor: Color veryDarkGray.	self tabList tabsMorph hResizing: #spaceFill.	self mainWindow addMorph: self tabList frame: (0 @ 0 corner: 1 @ 1)! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:01'!createTestPage	| aTestPage |	aTestPage := (Morph new)				hResizing: #spaceFill;				vResizing: #spaceFill;				setNameTo: 'Test';				layoutPolicy: ProportionalLayout new;				color: Color transparent;				yourself.	self tabList addTabFor: aTestPage font: TextStyle defaultFont.	self addTextToTestPage: aTestPage.	self addButtonsToTestPage: aTestPage! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 23:18'!createTutorialPage	| aPage |	tutorialTextHolder := SmaCCCodeHolder owner: self ownerAcceptSelector: nil.	aPage := tutorialTextHolder contentsMorph.	tutorialTextHolder acceptContents: self tutorialText.	tutorialTextHolder changed: #contents.	aPage setNameTo: 'Tutorial';		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 borderWidth: 0.	self tabList addTabFor: aPage font: TextStyle defaultFont! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'apl 2/18/2003 13:40'!delete	self breakDependents.	self tabList pages do: [:e | e breakDependents].	^super delete! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'jws 10/23/2016 05:52'!initialize	mainWindow := (SystemWindow labelled: self defaultWindowLabelPrefix)				model: self.	self createTabbedPalette.	self createScannerPage.	self createParserPage.	self createCompilePage.	self createTestPage.	self createTutorialPage.	self updateWindowLabel! !!SmaCCParserGenerator methodsFor: 'initialize-release' stamp: 'apl 2/18/2003 13:40'!openInWorld	self mainWindow openInWorld.	self tabList selectTabNamed: 'Compile'! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'jws 10/30/2016 22:50'!compile: aSymbol 	| grammar stream oldIgnoreCase oldCharacterSize parserCompiler |	(self scannerClassString isEmpty			or: [self parserClassString isEmpty])		ifTrue: [^ PopUpMenu inform: 'Both classes are not specified'].	Cursor read		showWhile: [self verifySyntax				ifFalse: [^ self]].	Cursor wait		showWhile: [oldIgnoreCase := SmaCCGrammar ignoreCase.			oldCharacterSize := SmaCCGrammar maximumCharacterValue.			[SmaCCGrammar ignoreCase: self ignoreCase;				 maximumCharacterValue: 255.			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler buildScanner: self scannerText andParser: self parserText;				 scannerClass: self scannerClassString;				 parserClass: self parserClassString.			grammar := parserCompiler grammar.			grammar type: aSymbol.			stream := WriteStream on: Text new.			[parserCompiler createChanges.			self generateDefinitionComments				ifTrue: [parserCompiler compileDefinitionComments].			self generateSymbolComments				ifTrue: [parserCompiler compileSymbolComment].			self generateItemSetComments				ifTrue: [parserCompiler compileItemSetsComment].			parserCompiler compileChanges]				on: SmaCCCompilationNotification				do: [:ex | 					(ShowPrecedenceConflicts							or: [('*precedence*' match: ex messageText) not])						ifTrue: [stream nextPutAll: '-------------------------\' withCRs asText , ex messageText asText allBold;								 cr;								 cr;								 nextPutAll: ex description;								 cr;								 nextPutAll: ex tag; cr;								 cr.].					ex pass].			self conflicts: stream contents.			self testText string withBlanksTrimmed notEmpty ifTrue: [self testCodeHolder hasUnacceptedEdits: true]]				ensure: [SmaCCGrammar ignoreCase: oldIgnoreCase;						 maximumCharacterValue: oldCharacterSize]]! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'jws 10/23/2016 05:53'!defaultBackgroundColor	^ Color gray lighter lighter! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'apl 2/20/2003 18:20'!defaultWindowLabelPrefix	^ 'SmaCCParserGenerator'! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'apl 2/18/2003 20:22'!displayError: aString at: position notifying: aRequestor 	aRequestor selectFrom: position to: position - 1.	aRequestor		replaceSelectionWith: (Text string: aString , '->' attribute: TextEmphasis bold).	aRequestor		setSelection: (position to: position + aString size + 1)! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'mga 1/18/2003 14:42'!removeCommentedPartOf: aString 	| inStream outStream |	inStream := ReadStream on: aString.	outStream := WriteStream on: String new.	inStream upTo: $".	[inStream atEnd]		whileFalse: [(inStream peekFor: $")				ifTrue: [outStream nextPut: $"].			outStream				nextPutAll: (inStream upTo: $")].	^ outStream contents! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'apl 2/20/2003 16:35'!verifyParser	| parserCode |	parserCode := self parserCodeHolder contentsMorph text.	parserCode string withBlanksTrimmed isEmpty		ifTrue: [PopUpMenu inform: 'Empty Parser code'.			self tabList selectTabNamed: 'Parser'.			^ false].	self parserCodeHolder hasUnacceptedEdits		ifTrue: [(self acceptParserCode: parserCode notifying: self parserCodeHolder contentsMorph)				ifTrue: [self parserCodeHolder acceptContents: parserCode.					self parserCodeHolder changed: #contents]				ifFalse: [^ false]].	^ true! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'apl 2/20/2003 16:36'!verifyScanner	| scannerText |	scannerText := self scannerCodeHolder contentsMorph text.	scannerText string withBlanksTrimmed isEmpty		ifTrue: [PopUpMenu inform: 'Empty Scanner code'.			self tabList selectTabNamed: 'Scanner'.			^ false].	self scannerCodeHolder hasUnacceptedEdits		ifTrue: [(self acceptScannerCode: scannerText notifying: self scannerCodeHolder contentsMorph)				ifTrue: [self scannerCodeHolder acceptContents: scannerText.					self scannerCodeHolder changed: #contents.					^ true].			^ false].	^ true! !!SmaCCParserGenerator methodsFor: 'private' stamp: 'apl 2/18/2003 10:37'!verifySyntax	self verifyScanner		ifFalse: [^ false].	self verifyParser ifFalse: [^false].	^ true! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/20/2003 16:22'!conflictTextMorph	^conflictTextMorph! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/20/2003 16:22'!conflictTextMorph: anObject	conflictTextMorph := anObject! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 16:00'!conflicts	conflicts isNil ifTrue: [conflicts:=String new].	^conflicts! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/20/2003 16:35'!conflicts: aString 	conflicts := aString.	self changed: #conflicts! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 15:27'!generateDefinitionComments	generateDefinitionComments isNil ifTrue: [generateDefinitionComments:=true].	^generateDefinitionComments! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 15:27'!generateItemSetComments	generateItemSetComments isNil ifTrue: [generateItemSetComments:=false].	^generateItemSetComments! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 15:27'!generateSymbolComments	generateSymbolComments isNil ifTrue: [generateSymbolComments:=false].	^generateSymbolComments! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 15:26'!ignoreCase	ignoreCase isNil ifTrue: [ignoreCase:=false].	^ignoreCase! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 2/15/2003 12:58'!mainWindow		^mainWindow! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/23/2003 09:47'!paneColorToUse	^Color blue muchLighter! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 11:47'!parserClass	| classname |	classname := self parserClassString asSymbol.	^classname notEmpty ifTrue: [Smalltalk at: classname]! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 12:21'!parserClassString	^parserClassMorph contents string! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 10:43'!parserCodeHolder	^parserCodeHolder! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 10:43'!parserCodeHolder: anObject	parserCodeHolder := anObject! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 10:53'!parserText	^ self parserCodeHolder contents! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 11:25'!parserText: text 	self parserCodeHolder contents: text.	self parserCodeHolder contentsMorph setText: text.! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 12:20'!scannerClassString	^scannerClassMorph contents string! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/17/2003 15:22'!scannerCodeHolder	^scannerCodeHolder! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/17/2003 15:22'!scannerCodeHolder: anObject	scannerCodeHolder := anObject! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/19/2003 09:55'!scannerText	^ self scannerCodeHolder contents! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 11:43'!scannerText: text 	self scannerCodeHolder contents: text.	self scannerCodeHolder contentsMorph setText: text! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/22/2003 16:32'!tabList	^tabList! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 13:40'!tabList: anObject	tabList := anObject! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 11:39'!testCodeHolder	^testCodeHolder! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 11:39'!testCodeHolder: anObject	testCodeHolder := anObject! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'apl 2/18/2003 19:36'!testText	^ self testCodeHolder contentsMorph text! !!SmaCCParserGenerator methodsFor: 'accessing' stamp: 'mga 1/23/2003 11:15'!tutorialText	^self class comment! !!SmaCCParserGenerator class methodsFor: 'flaps' stamp: 'mga 2/15/2003 13:01'!flapButton	| tuple |	tuple := {self name asSymbol. #prototypicalToolWindow. 'SmaCC parser generator'. 'UI of squeak SmaCC'}.	^ IconicButton new		initializeWithThumbnail: (PartsBin thumbnailForQuad: tuple)		withLabel: tuple third		andSend: tuple second		to: (Smalltalk at: tuple first)! !!SmaCCParserGenerator class methodsFor: 'flaps' stamp: 'mga 2/15/2003 13:02'!openFlapButton		^self flapButton openInWorld! !!SmaCCParserGenerator class methodsFor: 'class initialization' stamp: 'mga 2/8/2004 22:22'!initialize	ShowPrecedenceConflicts:=false.	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: [		TheWorldMenu unregisterOpenCommand: 'SmaCC'.		TheWorldMenu registerOpenCommand: {'SmaCC Generator'. {self. #open}}].	self open! !!SmaCCParserGenerator class methodsFor: 'class initialization' stamp: 'mga 2/15/2003 13:03'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec		classSymbol: self name asSymbol		wording: self name asSymbol		brightColor: #lightBlue		pastelColor: #paleBlue		helpMessage: 'Squeak port UI of SmaCC'! !!SmaCCParserGenerator class methodsFor: 'instance creation' stamp: 'mga 2/15/2003 13:05'!new		^super new initialize! !!SmaCCParserGenerator class methodsFor: 'instance creation' stamp: 'mga 2/15/2003 13:02'!open		^self new openInWorld! !!SmaCCParserGenerator class methodsFor: 'instance creation' stamp: 'mga 2/15/2003 13:02'!prototypicalToolWindow		"Answer an example of myself seen in a tool window, for the 	benefit of 	parts-launching tools"	| aWindow |	aWindow := self new mainWindow.	aWindow applyModelExtent.	^ aWindow! !!SmaCCRHS methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!= aSmaCCRHS 	^self class = aSmaCCRHS class and: [collection = aSmaCCRHS collection]! !!SmaCCRHS methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!hash	^self class hash bitXor: (collection hash bitShift: 14)! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!add: aSmaCCSymbol 	collection add: aSmaCCSymbol! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!at: anInteger 	^collection at: anInteger! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!do: aBlock	collection do: aBlock! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!firstTerminals	| items |	collection isEmpty ifTrue: [^Set with: SmaCCSymbol empty].	items := Set new.	1 to: collection size		do: 			[:index | 			items addAll: (collection at: index) firstTerminals.			(items includes: SmaCCSymbol empty) 				ifTrue: [index < collection size ifTrue: [items remove: SmaCCSymbol empty]]				ifFalse: [^items]].	^items! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!nameLastItem: aString 	variableNames at: aString put: collection size! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!reduceAction	^reduceAction! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!reduceAction: anObject	reduceAction := anObject! !!SmaCCRHS methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!size	^collection size! !!SmaCCRHS methodsFor: 'private' stamp: ' 6/1/07 21:19'!collection	^collection! !!SmaCCRHS methodsFor: 'private' stamp: ' 6/1/07 21:19'!defaultReduceAction	^#reduceFor:! !!SmaCCRHS methodsFor: 'reduction table' stamp: 'lr 1/7/2007 11:08'!compileSourceFor: aSmaCCSymbol in: aClass 	| action rewriter parseTree methodName |	action := self reduceAction.	action isNil ifTrue: [^self defaultReduceAction].	parseTree := RBParser parseExpression: action				onError: 					[:s :p | 					SmaCCCompilationNotification new						tag: aSmaCCSymbol name , ' : ' , self printString 								, '\\' withCRs , action;						signal: 'Invalid Smalltalk code in reduction rule'.					^self defaultReduceAction].	(parseTree isLiteral and: 			[parseTree value isSymbol and: 					[parseTree value numArgs <= 1 and: [aClass definesMethod: parseTree value]]]) 		ifTrue: [^parseTree value].	rewriter := self parseTreeRewriter.	rewriter executeTree: parseTree.	parseTree := rewriter tree.	methodName := ('reduceActionFor' , aSmaCCSymbol safeMethodName 				, (aSmaCCSymbol positionOf: self) printString , ':') 				asSymbol.	parseTree isSequence 		ifFalse: [parseTree := RBSequenceNode statements: (Array with: parseTree)].	parseTree := RBMethodNode 				selector: methodName				arguments: (Array with: (RBVariableNode named: 'nodes'))				body: parseTree.	parseTree addReturn.	aClass compile: parseTree formattedCode		classified: 'generated-reduction actions'.	^methodName! !!SmaCCRHS methodsFor: 'reduction table' stamp: 'jws 10/23/2016 05:54'!parseTreeRewriter	| rewriter |	rewriter := ParseTreeRewriter new.	1 to: self size		do: 			[:i | 			rewriter replace: i printString storeString				with: '(nodes at: ' , i printString , ')'].	variableNames keysAndValuesDo: 			[:key :value | 			rewriter replace: key with: '(nodes at: ' , value printString , ')'].	^rewriter! !!SmaCCRHS methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	collection := OrderedCollection new.	reduceAction := nil.	variableNames := Dictionary new! !!SmaCCRHS methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	^collection do: [:each | each printOn: aStream]		separatedBy: [aStream space]! !!SmaCCReduceAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!id	^2r10! !!SmaCCReduceAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!rhs	^rhs! !!SmaCCReduceAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!size	^rhs size! !!SmaCCReduceAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!symbol	^symbol! !!SmaCCReduceAction methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isReduce	^true! !!SmaCCReduceAction methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!symbol: aSmaCCSymbol rhs: aSmaCCRHS	rhs := aSmaCCRHS.	symbol := aSmaCCSymbol! !!SmaCCReduceAction class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!symbol: aSmaCCSymbol rhs: aSmaCCRHS 	^(self new)		symbol: aSmaCCSymbol rhs: aSmaCCRHS;		yourself! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!, aSmaCCRegularExpressionNode 	^SmaCCSequenceRENode 		nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addState: aSymbol	states add: aSymbol! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addStates: aCollection 	states addAll: aCollection! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!position	^position! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!position: anInteger	position := anInteger! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatches	| matches |	matches := OrderedCollection new.	self possibleMatchesDo: [:each | matches add: each].	^matches! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock 	| stream |	stream := WriteStream with: String new.	self possibleMatchesDo: [aBlock value: stream contents] on: stream! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesSize	^self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!repeat	^SmaCCRepeatingRENode component: self! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!repeatFor: minimum to: maximum 	^SmaCCRepeatingRENode 		component: self		minimum: minimum		maximum: maximum! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!repeatForAtLeast: minimum 	^SmaCCRepeatingRENode component: self minimum: minimum! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!states	^states! !!SmaCCRegularExpressionNode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!| aSmaCCRegularExpressionNode 	^SmaCCOrRENode 		nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)! !!SmaCCRegularExpressionNode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!action	^action! !!SmaCCRegularExpressionNode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!action: aString	action := aString! !!SmaCCRegularExpressionNode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	states := Set new! !!SmaCCRegularExpressionNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!addStateTransitionsTo: aSmaCCNode 	| endNode |	states isEmpty ifTrue: [^aSmaCCNode].	endNode := SmaCCNode new.	aSmaCCNode addEdgeTo: endNode onStates: states asSortedCollection asArray.	^endNode! !!SmaCCRegularExpressionNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!asNFAStartingWith: aSmaCCNode 	^self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream 	self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'converting' stamp: ' 6/1/07 21:19'!asDFA	| startNode |	startNode := SmaCCNode new.	self asNFAStartingWith: startNode.	^startNode asDFA! !!SmaCCRegularExpressionNode methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isKeywordLiteral	^self possibleMatchesSize < 50 and: 			[self possibleMatchesDo: [:each | each size > 1 ifTrue: [^true]].			false]! !!SmaCCRegularExpressionNode methodsFor: 'copying' stamp: ' 6/1/07 21:19'!postCopy	super postCopy.	states := Set new! !!SmaCCCharacterRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!asNFAStartingWith: aSmaCCNode 	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	startNode addEdgeTo: endNode onCharacters: characters.	^endNode! !!SmaCCCharacterRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!characters	^characters! !!SmaCCCharacterRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!matchingCharacters	^SmaCCGrammar ignoreCase 		ifTrue: [characters reject: [:each | each isLowercase]]		ifFalse: [characters]! !!SmaCCCharacterRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream 	self matchingCharacters do: 			[:each | 			aStream nextPut: each.			aBlock value.			aStream skip: -1]! !!SmaCCCharacterRENode methodsFor: 'testing' stamp: ' 6/1/07 21:19'!canMergeWith: aSmaCCRegularExpressionNode 	^self class = aSmaCCRegularExpressionNode class and: 			[characters notNil and: 					[aSmaCCRegularExpressionNode characters notNil 						and: [self action = aSmaCCRegularExpressionNode action]]]! !!SmaCCCharacterRENode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!characters: aString 	characters := aString! !!SmaCCCharacterRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesSize	^self matchingCharacters size! !!SmaCCCharacterRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!| aSmaCCRegularExpressionNode 	(self canMergeWith: aSmaCCRegularExpressionNode) 		ifFalse: [^super | aSmaCCRegularExpressionNode].	characters := String 				withAll: ((characters , aSmaCCRegularExpressionNode characters) asSet 						asSortedCollection: [:a :b | a asInteger < b asInteger]).	^self! !!SmaCCCharacterRENode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printCharacter: aCharacter on: aStream 	(aCharacter asInteger between: 32 and: 126) 		ifTrue: [^aStream nextPut: aCharacter].	aStream nextPutAll: '\x'.	aCharacter asInteger 		printOn: aStream		paddedWith: $0		to: 2		base: 16! !!SmaCCCharacterRENode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	| allCharacters |	characters size = 1 		ifTrue: [^self printCharacter: characters first on: aStream].	aStream nextPut: $[.	allCharacters := characters.	characters size > 128 		ifTrue: 			[aStream nextPut: $^.			allCharacters := ((0 to: SmaCCGrammar maximumCharacterValue) 						collect: [:each | Character value: each]) 							reject: [:each | characters includes: each]].	allCharacters do: [:each | self printCharacter: each on: aStream].	aStream nextPut: $]! !!SmaCCCharacterRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!characters: aString 	^(self new)		characters: (self sortedCharactersFor: aString);		yourself! !!SmaCCCharacterRENode class methodsFor: 'private' stamp: 'lr 1/6/2007 22:50'!sortedCharactersFor: aString 	| characters stream |	stream := WriteStream with: String new.	SmaCCGrammar ignoreCase 		ifTrue: 			[aString do: 					[:each | 					stream						nextPut: each asUppercase;						nextPut: each asLowercase]]		ifFalse: [stream nextPutAll: aString].	characters := stream contents 				asSortedCollection: [:a :b | a asInteger < b asInteger].	stream := WriteStream with: String new.	characters inject: nil		into: 			[:sum :each | 			sum = each ifFalse: [stream nextPut: each].			each].	^stream contents! !!SmaCCOrRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!asNFAStartingWith: aSmaCCNode 	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	nodes do: 			[:each | 			| componentStart |			componentStart := SmaCCNode new.			startNode addEdgeTo: componentStart.			(each asNFAStartingWith: componentStart) addEdgeTo: endNode].	^endNode! !!SmaCCOrRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream 	nodes do: 			[:each | 			| pos |			pos := aStream position.			each possibleMatchesDo: aBlock on: aStream.			aStream position: pos]! !!SmaCCOrRENode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!nodes: aCollection 	nodes := aCollection! !!SmaCCOrRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesSize	^nodes inject: 0 into: [:sum :each | sum + each possibleMatchesSize]! !!SmaCCOrRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!| aSmaCCRegularExpressionNode 	self action = aSmaCCRegularExpressionNode action 		ifFalse: [^super | aSmaCCRegularExpressionNode].	nodes add: aSmaCCRegularExpressionNode.	^self! !!SmaCCOrRENode methodsFor: 'copying' stamp: ' 6/1/07 21:19'!postCopy	super postCopy.	nodes := nodes copy! !!SmaCCOrRENode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	aStream nextPut: $(.	nodes do: [:each | each printOn: aStream]		separatedBy: [aStream nextPutAll: ' | '].	aStream nextPut: $)! !!SmaCCOrRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!nodes: aCollection 	^(self new)		nodes: aCollection;		yourself! !!SmaCCRejectAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!id	^2r11! !!SmaCCRejectAction class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!initialize	Reject := self basicNew! !!SmaCCRejectAction class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!releaseObjects	Reject := nil! !!SmaCCRejectAction class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!new	^Reject! !!SmaCCRepeatingRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!asNFAStartingWith: aSmaCCNode 	| endNode start |	start := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	minimumMatches timesRepeat: [start := node asNFAStartingWith: start].	start addEdgeTo: endNode.	maximumMatches < self class finiteInfinity 		ifTrue: 			[maximumMatches - minimumMatches timesRepeat: 					[start := node asNFAStartingWith: start.					start addEdgeTo: endNode]]		ifFalse: [(node asNFAStartingWith: start) addEdgeTo: start].	^endNode! !!SmaCCRepeatingRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream 	self 		possibleMatchesDo: aBlock		on: aStream		startingAt: 0! !!SmaCCRepeatingRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream startingAt: anInteger 	(anInteger between: minimumMatches and: maximumMatches) 		ifTrue: [aBlock value].	anInteger < maximumMatches 		ifTrue: 			[node possibleMatchesDo: 					[self 						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]! !!SmaCCRepeatingRENode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger 	node := aSmaCCRegularExpressionNode.	minimumMatches := minInteger.	maximumMatches := maxInteger! !!SmaCCRepeatingRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesSize	^node possibleMatchesSize * (maximumMatches - minimumMatches + 1)! !!SmaCCRepeatingRENode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	node printOn: aStream.	maximumMatches = (1 bitShift: 31) 		ifTrue: 			[minimumMatches = 0 ifTrue: [^aStream nextPut: $*].			minimumMatches = 1 ifTrue: [^aStream nextPut: $+].			^aStream				nextPut: ${;				nextPutAll: minimumMatches printString;				nextPutAll: ',}'].	aStream		nextPut: ${;		nextPutAll: minimumMatches printString;		nextPut: $,;		nextPutAll: maximumMatches printString;		nextPut: $}! !!SmaCCRepeatingRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!component: aSmaCCRegularExpressionNode 	^self component: aSmaCCRegularExpressionNode minimum: 0! !!SmaCCRepeatingRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!component: aSmaCCRegularExpressionNode minimum: anInteger 	^self 		component: aSmaCCRegularExpressionNode		minimum: anInteger		maximum: self finiteInfinity! !!SmaCCRepeatingRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger 	^(self new)		component: aSmaCCRegularExpressionNode			minimum: minInteger			maximum: maxInteger;		yourself! !!SmaCCRepeatingRENode class methodsFor: 'constants' stamp: ' 6/1/07 21:19'!finiteInfinity	"The number that we consider to be 'infinite'"	^2147483648! !!SmaCCScanner methodsFor: 'testing' stamp: ' 6/1/07 20:34'!atEnd	^stream atEnd! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!checkForKeyword: aString 	| stateMap action |	action := matchActions isSymbol 				ifTrue: [matchActions]				ifFalse: [matchActions first].	stateMap := self class keywordMap at: action ifAbsent: [nil].	stateMap isNil ifTrue: [^self].	matchActions := stateMap at: (self keywordFor: aString)				ifAbsent: [matchActions].	matchActions isInteger 		ifTrue: [matchActions := Array with: matchActions with: action]! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!checkForValidMatch	matchActions isNil ifTrue: [self scannerError]! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!createTokenFor: string 	| token |	token := self tokenClass 				value: string				start: start + 1				id: matchActions.	outputStream reset.	^token! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!eofTokenId	^Array with: self emptySymbolTokenId! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!recordAndReportMatch: aCollection 	^self		recordMatch: aCollection;		reportLastMatch! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!recordMatch: aCollection 	matchActions := aCollection.	matchEnd := stream position.	lastOutputStreamMatchPosition := outputStream position! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!reportLastMatch	"The scanner has found the end of a token and must report it"	| string token |	self checkForValidMatch.	self resetOutputToLastMatch.	stream position: matchEnd.	string := outputStream contents.	self checkForKeyword: string.	token := matchActions isSymbol 				ifTrue: [self perform: matchActions]				ifFalse: [self createTokenFor: string].	matchActions := nil.	^token! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!resetOutputToLastMatch	outputStream position: lastOutputStreamMatchPosition.	lastOutputStreamMatchPosition == 0 		ifTrue: 			[lastMatchWasEmpty ifTrue: [self scannerError].			lastMatchWasEmpty := true]		ifFalse: [lastMatchWasEmpty := false]! !!SmaCCScanner methodsFor: 'private' stamp: 'lr 1/7/2007 02:23'!resetScanner	start := stream position.	outputStream reset.	lastOutputStreamMatchPosition := 0! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!scannerError	| string |	(stream atEnd and: [start == stream position]) 		ifTrue: 			[string := ''.			matchActions := self eofTokenId]		ifFalse: 			[stream position: start.			string := String with: stream next.			matchActions := #(0)].	returnMatchBlock value: (self createTokenFor: string)! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!step	stream atEnd ifTrue: [^returnMatchBlock value: self reportLastMatch].	currentCharacter := stream next.	outputStream nextPut: currentCharacter! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!tokenClass	^SmaCCToken! !!SmaCCScanner methodsFor: 'default token handling' stamp: ' 6/1/07 20:34'!comment	"In case someone wants to record the comments"	^self whitespace! !!SmaCCScanner methodsFor: 'default token handling' stamp: ' 6/1/07 20:34'!whitespace	"By default, eat the whitespace"	self resetScanner.	^self scanForToken! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!contents	| writeStream token |	writeStream := WriteStream with: Array new.	[self atEnd] whileFalse: 			[token := self next.			token notNil ifTrue: [writeStream nextPut: token]].	^writeStream contents! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!emptySymbolTokenId	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTokenId	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumber	"This requires the stream to be a line number stream (see the #needsLineNumbers class method)."	^stream lineNumber! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!next	self resetScanner.	returnMatchBlock := [:match | ^match].	^self scanForToken! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^stream position! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position: anInteger	^stream position: anInteger! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!scanForToken	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!state	^state! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!state: aSymbol	state := aSymbol! !!SmaCCScanner methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!initialize	outputStream := WriteStream with: String new.	lastMatchWasEmpty := true.	state := #default! !!SmaCCScanner methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!on: aStream 	stream := aStream.	start := stream position! !!SmaCCScanner methodsFor: 'private-utility' stamp: ' 6/1/07 20:34'!keywordFor: aString 	"Subclasses can override this to ignore case"	^aString! !!CScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:13'!CONSTANTId	^77! !!CScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:13'!IDENTIFIERId	^76! !!CScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:13'!TypeNameId	^132! !!CScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:13'!emptySymbolTokenId	^147! !!CScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:13'!errorTokenId	^148! !!CScanner methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!IDENTIFIER	| name |	name := outputStream contents.	matchActions := (typeNames includes: name) 				ifTrue: [Array with: self TypeNameId]				ifFalse: [Array with: self IDENTIFIERId].	outputStream reset.	^SmaCCToken 		value: name		start: start		id: matchActions! !!CScanner methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!addTypeName: aString 	typeNames add: aString! !!CScanner methodsFor: 'default token handling' stamp: ' 6/1/07 21:19'!comment	| char |		[[(char := stream next) isNil or: [char == $*]] whileFalse.	stream atEnd ifTrue: [self scannerError].	stream peekFor: $/] 			whileFalse.	^self whitespace! !!CScanner methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	super initialize.	typeNames := Set new! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan1		[self recordMatch: #(77 ).	self step.	currentCharacter between: $0 and: $9] 			whileTrue.	(currentCharacter = $F or: 			[currentCharacter = $L 				or: [currentCharacter = $f or: [currentCharacter = $l]]]) 		ifTrue: [^ self recordAndReportMatch: #(77 )].	(currentCharacter = $E or: [currentCharacter = $e]) ifTrue: [^ self scan2].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan2	self step.	(currentCharacter between: $0 and: $9) ifTrue: [^ self scan5].	(currentCharacter = $+ or: [currentCharacter = $-]) 		ifTrue: 			[self step.			(currentCharacter between: $0 and: $9) ifTrue: [^ self scan5].			^ self reportLastMatch].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan3		[self recordMatch: #(77 ).	self step.	currentCharacter between: $0 and: $9] 			whileTrue.	(currentCharacter = $L or: 			[currentCharacter = $U 				or: [currentCharacter = $l or: [currentCharacter = $u]]]) 		ifTrue: [^ self recordAndReportMatch: #(77 )].	(currentCharacter = $E or: [currentCharacter = $e]) ifTrue: [^ self scan2].	currentCharacter = $. ifTrue: [^ self scan4].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan4	self step.	(currentCharacter between: $0 and: $9) ifTrue: [^ self scan1].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan5		[self recordMatch: #(77 ).	self step.	currentCharacter between: $0 and: $9] 			whileTrue.	(currentCharacter = $F or: 			[currentCharacter = $L 				or: [currentCharacter = $f or: [currentCharacter = $l]]]) 		ifTrue: [^ self recordAndReportMatch: #(77 )].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan6		[self step.	currentCharacter <= $!! 		or: [(currentCharacter between: $# and: $[) or: [currentCharacter >= $]]]] 			whileTrue.	currentCharacter = $" ifTrue: [^ self recordAndReportMatch: #(78 )].	currentCharacter = $\ 		ifTrue: 			[self step.			currentCharacter <= $ÿ ifTrue: [^ self scan6].			^ self reportLastMatch].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan7	self step.	(currentCharacter <= $!! 		or: [(currentCharacter between: $# and: $[) or: [currentCharacter >= $]]]) 			ifTrue: [^ self scan9].	currentCharacter = $\ ifTrue: [^ self scan8].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan8	self step.	currentCharacter <= $ÿ ifTrue: [^ self scan9].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scan9		[self step.	currentCharacter <= $!! or: 			[(currentCharacter between: $# and: $&) 				or: [(currentCharacter between: $( and: $[) or: [currentCharacter >= $]]]]] 			whileTrue.	currentCharacter = $' 		ifTrue: 			[			[self recordMatch: #(77 ).			self step.			(currentCharacter <= $!! or: 					[(currentCharacter between: $# and: $&) 						or: [(currentCharacter between: $( and: $[) or: [currentCharacter >= $]]]]) 				ifTrue: [^ self scan9].			currentCharacter = $'] 					whileTrue.			currentCharacter = $\ ifTrue: [^ self scan8].			^ self reportLastMatch].	currentCharacter = $\ ifTrue: [^ self scan8].	^ self reportLastMatch! !!CScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:13'!scanForToken	self step.	((currentCharacter between: $A and: $K) or: 			[(currentCharacter between: $M and: $Z) 				or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]) 		ifTrue: 			[			[self recordMatch: #IDENTIFIER.			self step.			(currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) 						or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 					whileTrue.			^ self reportLastMatch].	(currentCharacter between: $1 and: $9) ifTrue: [^ self scan3].	((currentCharacter between: Character tab and: Character cr) 		or: [currentCharacter = Character space]) 			ifTrue: 				[				[self recordMatch: #whitespace.				self step.				(currentCharacter between: Character tab and: Character cr) 					or: [currentCharacter = Character space]] 						whileTrue.				^ self reportLastMatch].	currentCharacter = $!! 		ifTrue: 			[self recordMatch: #(32 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(4 )].			^ self reportLastMatch].	currentCharacter = $" ifTrue: [^ self scan6].	currentCharacter = $% 		ifTrue: 			[self recordMatch: #(30 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(10 )].			currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(82 )].			^ self reportLastMatch].	currentCharacter = $& 		ifTrue: 			[self recordMatch: #(28 ).			self step.			currentCharacter = $& ifTrue: [^ self recordAndReportMatch: #(5 )].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(63 )].			^ self reportLastMatch].	currentCharacter = $' ifTrue: [^ self scan7].	currentCharacter = $( ifTrue: [^ self recordAndReportMatch: #(25 )].	currentCharacter = $) ifTrue: [^ self recordAndReportMatch: #(26 )].	currentCharacter = $* 		ifTrue: 			[self recordMatch: #(34 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(12 )].			^ self reportLastMatch].	currentCharacter = $+ 		ifTrue: 			[self recordMatch: #(35 ).			self step.			currentCharacter = $+ ifTrue: [^ self recordAndReportMatch: #(23 )].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(11 )].			^ self reportLastMatch].	currentCharacter = $, ifTrue: [^ self recordAndReportMatch: #(21 )].	currentCharacter = $- 		ifTrue: 			[self recordMatch: #(36 ).			self step.			currentCharacter = $- ifTrue: [^ self recordAndReportMatch: #(20 )].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(19 )].			currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(22 )].			^ self reportLastMatch].	currentCharacter = $. 		ifTrue: 			[self recordMatch: #(27 ).			self step.			(currentCharacter between: $0 and: $9) ifTrue: [^ self scan1].			currentCharacter = $. 				ifTrue: 					[self step.					currentCharacter = $. ifTrue: [^ self recordAndReportMatch: #(74 )].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $/ 		ifTrue: 			[self recordMatch: #(29 ).			self step.			currentCharacter = $* ifTrue: [^ self recordAndReportMatch: #comment].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(13 )].			^ self reportLastMatch].	currentCharacter = $0 		ifTrue: 			[self recordMatch: #(77 ).			self step.			(currentCharacter between: $0 and: $9) ifTrue: [^ self scan3].			(currentCharacter = $L or: 					[currentCharacter = $U 						or: [currentCharacter = $l or: [currentCharacter = $u]]]) 				ifTrue: [^ self recordAndReportMatch: #(77 )].			(currentCharacter = $E or: [currentCharacter = $e]) ifTrue: [^ self scan2].			(currentCharacter = $X or: [currentCharacter = $x]) 				ifTrue: 					[self step.					((currentCharacter between: $0 and: $9) or: 							[(currentCharacter between: $A and: $F) 								or: [currentCharacter between: $a and: $f]]) 						ifTrue: 							[							[self recordMatch: #(77 ).							self step.							(currentCharacter between: $0 and: $9) or: 									[(currentCharacter between: $A and: $F) 										or: [currentCharacter between: $a and: $f]]] 									whileTrue.							(currentCharacter = $L or: 									[currentCharacter = $U 										or: [currentCharacter = $l or: [currentCharacter = $u]]]) 								ifTrue: [^ self recordAndReportMatch: #(77 )].							^ self reportLastMatch].					^ self reportLastMatch].			currentCharacter = $. ifTrue: [^ self scan4].			^ self reportLastMatch].	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(16 ).			self step.			currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(80 )].			^ self reportLastMatch].	currentCharacter = $; ifTrue: [^ self recordAndReportMatch: #(60 )].	currentCharacter = $< 		ifTrue: 			[self recordMatch: #(18 ).			self step.			currentCharacter = $% ifTrue: [^ self recordAndReportMatch: #(81 )].			currentCharacter = $: ifTrue: [^ self recordAndReportMatch: #(79 )].			currentCharacter = $< 				ifTrue: 					[self recordMatch: #(33 ).					self step.					currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(37 )].					^ self reportLastMatch].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(7 )].			^ self reportLastMatch].	currentCharacter = $= 		ifTrue: 			[self recordMatch: #(17 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(3 )].			^ self reportLastMatch].	currentCharacter = $> 		ifTrue: 			[self recordMatch: #(6 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(8 )].			currentCharacter = $> 				ifTrue: 					[self recordMatch: #(14 ).					self step.					currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(62 )].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $? ifTrue: [^ self recordAndReportMatch: #(15 )].	currentCharacter = $L 		ifTrue: 			[self recordMatch: #IDENTIFIER.			self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) 						or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]) 				ifTrue: 					[					[self recordMatch: #IDENTIFIER.					self step.					(currentCharacter between: $0 and: $9) or: 							[(currentCharacter between: $A and: $Z) 								or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 							whileTrue.					^ self reportLastMatch].			currentCharacter = $" ifTrue: [^ self scan6].			currentCharacter = $' ifTrue: [^ self scan7].			^ self reportLastMatch].	currentCharacter = $[ ifTrue: [^ self recordAndReportMatch: #(79 )].	currentCharacter = $] ifTrue: [^ self recordAndReportMatch: #(80 )].	currentCharacter = $^ 		ifTrue: 			[self recordMatch: #(1 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(64 )].			^ self reportLastMatch].	currentCharacter = ${ ifTrue: [^ self recordAndReportMatch: #(81 )].	currentCharacter = $| 		ifTrue: 			[self recordMatch: #(2 ).			self step.			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(59 )].			currentCharacter = $| ifTrue: [^ self recordAndReportMatch: #(9 )].			^ self reportLastMatch].	currentCharacter = $} ifTrue: [^ self recordAndReportMatch: #(82 )].	currentCharacter = $~ ifTrue: [^ self recordAndReportMatch: #(31 )].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:59'!emptySymbolTokenId	^255! !!JavaScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:59'!errorTokenId	^256! !!JavaScanner methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!multipleLineComment	| char |		[[(char := stream next) isNil or: [char == $*]] whileFalse.	stream atEnd ifTrue: [self scannerError].	stream peekFor: $/] 			whileFalse.	^self whitespace! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan1	[ 	self step.	currentCharacter between: $0 and: $9 ] whileTrue.	(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])		ifTrue: [ ^ self recordAndReportMatch: #(94) ].	(currentCharacter = $E or: [ currentCharacter = $e ])		ifTrue: [ ^ self scan3 ].	currentCharacter = $.		ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan2	[ 	self recordMatch: #(94).	self step.	currentCharacter between: $0 and: $9 ] whileTrue.	(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])		ifTrue: [ ^ self recordAndReportMatch: #(94) ].	(currentCharacter = $E or: [ currentCharacter = $e ])		ifTrue: [ ^ self scan3 ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan3	self step.	(currentCharacter between: $0 and: $9)		ifTrue: [ ^ self scan4 ].	(currentCharacter = $+ or: [ currentCharacter = $- ])		ifTrue: [ 			self step.			(currentCharacter between: $0 and: $9)				ifTrue: [ ^ self scan4 ].			^ self reportLastMatch ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan4	[ 	self recordMatch: #(94).	self step.	currentCharacter between: $0 and: $9 ] whileTrue.	(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])		ifTrue: [ ^ self recordAndReportMatch: #(94) ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan5	[ 	self step.	currentCharacter <= $!! or: [ (currentCharacter between: $# and: $[) or: [ currentCharacter >= $] ] ] ] whileTrue.	currentCharacter = $"		ifTrue: [ ^ self recordAndReportMatch: #(97) ].	currentCharacter = $\		ifTrue: [ 			self step.			(currentCharacter = $"				or: [ 					currentCharacter = $'						or: [ 							(currentCharacter between: $0 and: $7)								or: [ 									currentCharacter = $\										or: [ 											currentCharacter = $b												or: [ currentCharacter = $f or: [ currentCharacter = $n or: [ currentCharacter = $r or: [ currentCharacter = $t ] ] ] ] ] ] ] ])				ifTrue: [ ^ self scan5 ].			^ self reportLastMatch ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan6	self step.	currentCharacter = $'		ifTrue: [ ^ self recordAndReportMatch: #(96) ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scan7	self step.	(currentCharacter between: $0 and: $7)		ifTrue: [ ^ self scan6 ].	currentCharacter = $'		ifTrue: [ ^ self recordAndReportMatch: #(96) ].	^ self reportLastMatch! !!JavaScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:59'!scanForToken	self step.	((currentCharacter between: $A and: $Z) or: [ currentCharacter = $_ or: [ currentCharacter between: $a and: $z ] ])		ifTrue: [ 			[ 			self recordMatch: #(99).			self step.			(currentCharacter between: $0 and: $9)				or: [ (currentCharacter between: $A and: $Z) or: [ currentCharacter = $_ or: [ currentCharacter between: $a and: $z ] ] ] ]				whileTrue.			^ self reportLastMatch ].	(currentCharacter between: $1 and: $9)		ifTrue: [ 			[ 			self recordMatch: #(93).			self step.			currentCharacter between: $0 and: $9 ] whileTrue.			(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(94) ].			(currentCharacter = $E or: [ currentCharacter = $e ])				ifTrue: [ ^ self scan3 ].			(currentCharacter = $L or: [ currentCharacter = $l ])				ifTrue: [ ^ self recordAndReportMatch: #(93) ].			currentCharacter = $.				ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	((currentCharacter between: Character tab and: Character cr) or: [ currentCharacter = Character space ])		ifTrue: [ 			[ 			self recordMatch: #whitespace.			self step.			(currentCharacter between: Character tab and: Character cr) or: [ currentCharacter = Character space ] ] whileTrue.			^ self reportLastMatch ].	currentCharacter = $!!		ifTrue: [ 			self recordMatch: #(91).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(51) ].			^ self reportLastMatch ].	currentCharacter = $"		ifTrue: [ ^ self scan5 ].	currentCharacter = $%		ifTrue: [ 			self recordMatch: #(85).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(67) ].			^ self reportLastMatch ].	currentCharacter = $&		ifTrue: [ 			self recordMatch: #(50).			self step.			currentCharacter = $&				ifTrue: [ ^ self recordAndReportMatch: #(52) ].			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(61) ].			^ self reportLastMatch ].	currentCharacter = $'		ifTrue: [ 			self step.			(currentCharacter <= $& or: [ (currentCharacter between: $( and: $[) or: [ currentCharacter >= $] ] ])				ifTrue: [ ^ self scan6 ].			currentCharacter = $\				ifTrue: [ 					self step.					(currentCharacter = $"						or: [ 							currentCharacter = $'								or: [ 									currentCharacter = $\										or: [ 											currentCharacter = $b												or: [ currentCharacter = $f or: [ currentCharacter = $n or: [ currentCharacter = $r or: [ currentCharacter = $t ] ] ] ] ] ] ])						ifTrue: [ ^ self scan6 ].					(currentCharacter between: $0 and: $3)						ifTrue: [ 							self step.							(currentCharacter between: $0 and: $7)								ifTrue: [ ^ self scan7 ].							currentCharacter = $'								ifTrue: [ ^ self recordAndReportMatch: #(96) ].							^ self reportLastMatch ].					(currentCharacter between: $4 and: $7)						ifTrue: [ ^ self scan7 ].					^ self reportLastMatch ].			^ self reportLastMatch ].	currentCharacter = $(		ifTrue: [ ^ self recordAndReportMatch: #(21) ].	currentCharacter = $)		ifTrue: [ ^ self recordAndReportMatch: #(19) ].	currentCharacter = $*		ifTrue: [ 			self recordMatch: #(42).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(68) ].			^ self reportLastMatch ].	currentCharacter = $+		ifTrue: [ 			self recordMatch: #(89).			self step.			currentCharacter = $+				ifTrue: [ ^ self recordAndReportMatch: #(82) ].			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(70) ].			^ self reportLastMatch ].	currentCharacter = $,		ifTrue: [ ^ self recordAndReportMatch: #(4) ].	currentCharacter = $-		ifTrue: [ 			self recordMatch: #(90).			self step.			currentCharacter = $-				ifTrue: [ ^ self recordAndReportMatch: #(87) ].			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(69) ].			^ self reportLastMatch ].	currentCharacter = $.		ifTrue: [ 			self recordMatch: #(28).			self step.			(currentCharacter between: $0 and: $9)				ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	currentCharacter = $/		ifTrue: [ 			self recordMatch: #(88).			self step.			currentCharacter = $*				ifTrue: [ ^ self recordAndReportMatch: #multipleLineComment ].			currentCharacter = $/				ifTrue: [ 					[ 					self step.					currentCharacter <= Character tab						or: [ 							(currentCharacter between: (Character value: 11) and: Character newPage)								or: [ currentCharacter >= (Character value: 14) ] ] ] whileTrue.					currentCharacter = Character lf						ifTrue: [ ^ self recordAndReportMatch: #comment ].					currentCharacter = Character cr						ifTrue: [ 							self recordMatch: #comment.							self step.							currentCharacter = Character lf								ifTrue: [ ^ self recordAndReportMatch: #comment ].							^ self reportLastMatch ].					^ self reportLastMatch ].			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(66) ].			^ self reportLastMatch ].	currentCharacter = $0		ifTrue: [ 			self recordMatch: #(93).			self step.			(currentCharacter between: $0 and: $7)				ifTrue: [ 					[ 					self recordMatch: #(93).					self step.					currentCharacter between: $0 and: $7 ] whileTrue.					(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])						ifTrue: [ ^ self recordAndReportMatch: #(94) ].					(currentCharacter between: $8 and: $9)						ifTrue: [ ^ self scan1 ].					(currentCharacter = $E or: [ currentCharacter = $e ])						ifTrue: [ ^ self scan3 ].					(currentCharacter = $L or: [ currentCharacter = $l ])						ifTrue: [ ^ self recordAndReportMatch: #(93) ].					currentCharacter = $.						ifTrue: [ ^ self scan2 ].					^ self reportLastMatch ].			(currentCharacter = $D or: [ currentCharacter = $F or: [ currentCharacter = $d or: [ currentCharacter = $f ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(94) ].			(currentCharacter between: $8 and: $9)				ifTrue: [ ^ self scan1 ].			(currentCharacter = $E or: [ currentCharacter = $e ])				ifTrue: [ ^ self scan3 ].			(currentCharacter = $L or: [ currentCharacter = $l ])				ifTrue: [ ^ self recordAndReportMatch: #(93) ].			(currentCharacter = $X or: [ currentCharacter = $x ])				ifTrue: [ 					self step.					((currentCharacter between: $0 and: $9)						or: [ (currentCharacter between: $A and: $F) or: [ currentCharacter between: $a and: $f ] ])						ifTrue: [ 							[ 							self recordMatch: #(93).							self step.							(currentCharacter between: $0 and: $9)								or: [ (currentCharacter between: $A and: $F) or: [ currentCharacter between: $a and: $f ] ] ] whileTrue.							(currentCharacter = $L or: [ currentCharacter = $l ])								ifTrue: [ ^ self recordAndReportMatch: #(93) ].							^ self reportLastMatch ].					^ self reportLastMatch ].			currentCharacter = $.				ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	currentCharacter = $:		ifTrue: [ ^ self recordAndReportMatch: #(15) ].	currentCharacter = $;		ifTrue: [ ^ self recordAndReportMatch: #(32) ].	currentCharacter = $<		ifTrue: [ 			self recordMatch: #(71).			self step.			currentCharacter = $<				ifTrue: [ 					self recordMatch: #(83).					self step.					currentCharacter = $=						ifTrue: [ ^ self recordAndReportMatch: #(63) ].					^ self reportLastMatch ].			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(54) ].			^ self reportLastMatch ].	currentCharacter = $=		ifTrue: [ 			self recordMatch: #(2).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(57) ].			^ self reportLastMatch ].	currentCharacter = $>		ifTrue: [ 			self recordMatch: #(59).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(55) ].			currentCharacter = $>				ifTrue: [ 					self recordMatch: #(84).					self step.					currentCharacter = $=						ifTrue: [ ^ self recordAndReportMatch: #(62) ].					currentCharacter = $>						ifTrue: [ 							self recordMatch: #(86).							self step.							currentCharacter = $=								ifTrue: [ ^ self recordAndReportMatch: #(60) ].							^ self reportLastMatch ].					^ self reportLastMatch ].			^ self reportLastMatch ].	currentCharacter = $?		ifTrue: [ ^ self recordAndReportMatch: #(56) ].	currentCharacter = $[		ifTrue: [ ^ self recordAndReportMatch: #(5) ].	currentCharacter = $]		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	currentCharacter = $^		ifTrue: [ 			self recordMatch: #(48).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(64) ].			^ self reportLastMatch ].	currentCharacter = ${		ifTrue: [ ^ self recordAndReportMatch: #(3) ].	currentCharacter = $|		ifTrue: [ 			self recordMatch: #(49).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(13) ].			currentCharacter = $|				ifTrue: [ ^ self recordAndReportMatch: #(53) ].			^ self reportLastMatch ].	currentCharacter = $}		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	currentCharacter = $~		ifTrue: [ ^ self recordAndReportMatch: #(92) ].	^ self reportLastMatch! !!SmaCCGrammarScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:12'!emptySymbolTokenId	^43! !!SmaCCGrammarScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:12'!errorTokenId	^44! !!SmaCCGrammarScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan1	self step.	currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(12 )].	currentCharacter = $i 		ifTrue: 			[self step.			currentCharacter = $d ifTrue: [^ self recordAndReportMatch: #(4 )].			^ self reportLastMatch].	currentCharacter = $l 		ifTrue: 			[self step.			currentCharacter = $e 				ifTrue: 					[self step.					currentCharacter = $f 						ifTrue: 							[self step.							currentCharacter = $t ifTrue: [^ self recordAndReportMatch: #(6 )].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $n 		ifTrue: 			[self step.			currentCharacter = $o 				ifTrue: 					[self step.					currentCharacter = $n 						ifTrue: 							[self step.							currentCharacter = $a 								ifTrue: 									[self step.									currentCharacter = $s 										ifTrue: 											[self step.											currentCharacter = $s 												ifTrue: 													[self step.													currentCharacter = $o 														ifTrue: 															[self step.															currentCharacter = $c ifTrue: [^ self recordAndReportMatch: #(3 )].															^ self reportLastMatch].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $r 		ifTrue: 			[self step.			currentCharacter = $i 				ifTrue: 					[self step.					currentCharacter = $g 						ifTrue: 							[self step.							currentCharacter = $h 								ifTrue: 									[self step.									currentCharacter = $t ifTrue: [^ self recordAndReportMatch: #(8 )].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $s 		ifTrue: 			[self step.			currentCharacter = $t 				ifTrue: 					[self step.					currentCharacter = $a 						ifTrue: 							[self step.							currentCharacter = $r 								ifTrue: 									[self step.									currentCharacter = $t ifTrue: [^ self recordAndReportMatch: #(1 )].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	^ self reportLastMatch! !!SmaCCGrammarScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan2		[self step.	currentCharacter ~= $"] whileTrue.	currentCharacter = $" 		ifTrue: 			[self recordMatch: #(21 ).			self step.			currentCharacter = $" ifTrue: [^ self scan2].			^ self reportLastMatch].	^ self reportLastMatch! !!SmaCCGrammarScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan3		[self step.	currentCharacter ~= $*] whileTrue.	currentCharacter = $* 		ifTrue: 			[			[self step.			(currentCharacter <= $) 				or: [(currentCharacter between: $+ and: $.) or: [currentCharacter >= $0]]) 					ifTrue: [^ self scan3].			currentCharacter = $*] 					whileTrue.			currentCharacter = $/ ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	^ self reportLastMatch! !!SmaCCGrammarScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scanForToken	self step.	((currentCharacter between: $A and: $Z) 		or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]) 			ifTrue: 				[				[self recordMatch: #(20 ).				self step.				(currentCharacter between: $0 and: $9) or: 						[(currentCharacter between: $A and: $Z) 							or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 						whileTrue.				^ self reportLastMatch].	((currentCharacter between: Character tab and: Character cr) 		or: [currentCharacter = Character space]) 			ifTrue: 				[				[self recordMatch: #whitespace.				self step.				(currentCharacter between: Character tab and: Character cr) 					or: [currentCharacter = Character space]] 						whileTrue.				^ self reportLastMatch].	currentCharacter = $" ifTrue: [^ self scan2].	currentCharacter = $# 		ifTrue: 			[			[self recordMatch: #comment.			self step.			currentCharacter <= Character tab or: 					[(currentCharacter between: (Character value: 11) and: Character newPage) 						or: [currentCharacter >= (Character value: 14)]]] 					whileTrue.			^ self reportLastMatch].	currentCharacter = $% ifTrue: [^ self scan1].	currentCharacter = $' 		ifTrue: 			[self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 								whileTrue.						currentCharacter = $' ifTrue: [^ self recordAndReportMatch: #(24 )].						^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $( ifTrue: [^ self recordAndReportMatch: #(17 )].	currentCharacter = $) ifTrue: [^ self recordAndReportMatch: #(14 )].	currentCharacter = $* ifTrue: [^ self recordAndReportMatch: #(10 )].	currentCharacter = $+ ifTrue: [^ self recordAndReportMatch: #(16 )].	currentCharacter = $/ 		ifTrue: 			[self step.			currentCharacter = $* ifTrue: [^ self scan3].			^ self reportLastMatch].	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(25 ).			self step.			currentCharacter = $: 				ifTrue: 					[self step.					currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(25 )].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $; ifTrue: [^ self recordAndReportMatch: #(7 )].	currentCharacter = $< 		ifTrue: 			[self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 								whileTrue.						currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(19 )].						^ self reportLastMatch].			currentCharacter = $% ifTrue: [^ self recordAndReportMatch: #(13 )].			^ self reportLastMatch].	currentCharacter = $? ifTrue: [^ self recordAndReportMatch: #(5 )].	currentCharacter = $[ ifTrue: [^ self recordAndReportMatch: #(11 )].	currentCharacter = $] ifTrue: [^ self recordAndReportMatch: #(2 )].	currentCharacter = ${ 		ifTrue: 			[self step.			currentCharacter ~= $} 				ifTrue: 					[					[self step.					currentCharacter ~= $}] whileTrue.					currentCharacter = $} ifTrue: [^ self recordAndReportMatch: #(23 )].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $| ifTrue: [^ self recordAndReportMatch: #(9 )].	^ self reportLastMatch! !!SmaCCScanner class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!frequencyTable	^#(1)! !!SmaCCScanner class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!keywordMap	keywordMap isNil ifTrue: [self initializeKeywordMap].	^keywordMap! !!SmaCCScanner class methodsFor: 'class initialization' stamp: ' 6/1/07 20:34'!initialize	self initializeKeywordMap! !!SmaCCScanner class methodsFor: 'class initialization' stamp: ' 6/1/07 20:34'!initializeKeywordMap	keywordMap := Dictionary new! !!SmaCCScanner class methodsFor: 'testing' stamp: ' 6/1/07 20:34'!needsLineNumbers	"Redefine to return true, if you need line number information"	^false! !!SmaCCScanner class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aStream 	^(self new)		on: (self needsLineNumbers 					ifTrue: [SmaCCLineNumberStream on: aStream]					ifFalse: [aStream]);		yourself! !!CScanner class methodsFor: 'generated-initialization' stamp: 'lr 1/22/2007 13:13'!initializeKeywordMap	keywordMap := Dictionary new.	#(		#(#IDENTIFIER 'auto' 65 )		#(#IDENTIFIER 'break' 48 )		#(#IDENTIFIER 'case' 38 )		#(#IDENTIFIER 'char' 73 )		#(#IDENTIFIER 'const' 40 )		#(#IDENTIFIER 'continue' 47 )		#(#IDENTIFIER 'default' 39 )		#(#IDENTIFIER 'do' 54 )		#(#IDENTIFIER 'double' 70 )		#(#IDENTIFIER 'else' 46 )		#(#IDENTIFIER 'enum' 45 )		#(#IDENTIFIER 'extern' 58 )		#(#IDENTIFIER 'float' 67 )		#(#IDENTIFIER 'for' 49 )		#(#IDENTIFIER 'goto' 50 )		#(#IDENTIFIER 'if' 42 )		#(#IDENTIFIER 'int' 69 )		#(#IDENTIFIER 'long' 66 )		#(#IDENTIFIER 'register' 71 )		#(#IDENTIFIER 'return' 56 )		#(#IDENTIFIER 'short' 68 )		#(#IDENTIFIER 'signed' 51 )		#(#IDENTIFIER 'sizeof' 24 )		#(#IDENTIFIER 'static' 61 )		#(#IDENTIFIER 'struct' 43 )		#(#IDENTIFIER 'switch' 52 )		#(#IDENTIFIER 'typedef' 57 )		#(#IDENTIFIER 'union' 44 )		#(#IDENTIFIER 'unsigned' 55 )		#(#IDENTIFIER 'void' 72 )		#(#IDENTIFIER 'volatile' 41 )		#(#IDENTIFIER 'while' 53 )	) do: 				[:each | 				(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)					put: each last].	^ keywordMap! !!CScanner class methodsFor: 'testing' stamp: ' 6/1/07 21:19'!needsLineNumbers	^true! !!CScanner class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:13'!scannerDefinitionComment	"<H>: [a-fA-F0-9]	;<IS>: [uUlL]	;<D>: [0-9]	;<E>: [Ee][\+\-]?<D>+	;<FS>: [fFlL]	;<ELLIPSIS> : \.\.\. ;<comment>: \/ \*	;<LETTER> : [a-zA-Z_] ;<DIGIT> : [0-9] ;<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;<CONSTANT>: (0[xX]<H>+<IS>?) | 				(<D>+<IS>?) | 				(<D>+<E><FS>?) | 				<D>*\.<D>+<E>?<FS>? | 				(L? \' ( (\\ .) | ([^\\\""]) )+ \')	;<STRING_LITERAL>: L? \"" ( (\\ .) | ([^\\\""]) )* \""	;<LEFT_BLOCK>: \[ | (\< \:)	;<RIGHT_BLOCK>: \] | (\: \>)	;<LEFT_BRACE>: \{ | (\< \%)	;<RIGHT_BRACE>: \} | (\% \>)	;<whitespace>: \s+	;"! !!JavaScanner class methodsFor: 'generated-initialization' stamp: 'jws 10/23/2016 05:59'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(99 'abstract' 38) #(99 'boolean' 30) #(99 'break' 81) #(99 'byte' 31) #(99 'case' 41) #(99 'catch' 72) #(99 'char' 26) #(99 'class' 8) #(99 'continue' 80) #(99 'default' 47) #(99 'do' 77) #(99 'double' 25) #(99 'else' 14) #(99 'extends' 11) #(99 'false' 95) #(99 'final' 36) #(99 'finally' 75) #(99 'float' 24) #(99 'for' 78) #(99 'if' 35) #(99 'implements' 10) #(99 'import' 44) #(99 'instanceof' 65) #(99 'int' 33) #(99 'interface' 16) #(99 'long' 27) #(99 'native' 37) #(99 'new' 76) #(99 'null' 98) #(99 'package' 29) #(99 'private' 45) #(99 'protected' 46) #(99 'public' 43) #(99 'return' 74) #(99 'short' 34) #(99 'static' 39) #(99 'strictfp' 7) #(99 'super' 22) #(99 'switch' 17) #(99 'synchronized' 40) #(99 'this' 23) #(99 'throw' 73) #(99 'throws' 20) #(99 'transient' 18) #(99 'true' 95) #(99 'try' 79) #(99 'void' 9) #(99 'volatile' 12) #(99 'while' 58))		do: [ :each | (keywordMap at: each first ifAbsentPut: [ Dictionary new ]) at: (each at: 2) put: each last ].	^ keywordMap! !!JavaScanner class methodsFor: 'generated-comments' stamp: 'jws 10/23/2016 05:59'!scannerDefinitionComment	"<DECIMAL_INTEGER>: 0 | [1-9] [0-9]*	;<HEX_INTEGER>: 0[xX][0-9a-fA-F]+	;<OCTAL_INTEGER>: 0[0-7]+	;<EXPONENT>: [eE] [\-\+]? [0-9]+ 	;<FLOAT_TYPE>: [fFdD]	;<ESCAPE_SEQUENCE>: \\ ([btnfr\""\'\\] | ([0-3] [0-7]{0,2} | [4-7][0-7]?))	;<INTEGER_LITERAL>: (<DECIMAL_INTEGER> | <HEX_INTEGER> | <OCTAL_INTEGER>) [lL]?	;<FLOATING_POINT_LITERAL>: [0-9]+ \. [0-9]* <EXPONENT>? <FLOAT_TYPE>? | \. [0-9]+ <EXPONENT>? <FLOAT_TYPE>? | [0-9]+ <EXPONENT> <FLOAT_TYPE>? | [0-9]+ <FLOAT_TYPE>	;<BOOLEAN_LITERAL>: true | false	;<CHARACTER_LITERAL>: \' ([^\\\'] | <ESCAPE_SEQUENCE> ) \'	;<STRING_LITERAL>: \"" ([^\\\""] | <ESCAPE_SEQUENCE> )* \""	;<NULL_LITERAL>: null	;<IDENTIFIER>: [a-zA-Z_] \w*	;<eol>: \r | \n | \r\n	;<whitespace>: \s+	;<comment>: \/\/ [^\r\n]* <eol>	;<multipleLineComment>: \/ \* 	;"! !!SmaCCGrammarScanner class methodsFor: 'generated-initialization' stamp: 'lr 1/22/2007 13:12'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(20 'error' 15 ) ) do: 				[:each | 				(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)					put: each last].	^ keywordMap! !!SmaCCGrammarScanner class methodsFor: 'testing' stamp: ' 6/1/07 21:19'!needsLineNumbers	^true! !!SmaCCGrammarScanner class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:12'!scannerDefinitionComment	"<name> : [a-zA-Z_] \w* ;<whitespace>	:	\s+ ;<tokenname>	:	\< <name> \> ;<symbolname>	:	<name>	 ;<keyword>	:	(\"" [^\""]* \"") + ;<comment>	:	(\# [^\r\n]*) | (\/\* [^\*]* \*+ ([^\/\*] [^\*]* \*+)* \/) ;<code>:	\{ [^\}]+ \} ;<variablename> :	\' <name> \' ;<production> : \: (\: \=)? ;"! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: 'lr 1/6/2007 21:42'!addActions	self symbols keysAndValuesDo: [:index :each | 		each regularExpression ifNotNilDo: [:eachRegex | eachRegex action: index ]]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!addSpecialSymbols	grammar tokens keysDo: 			[:each | 			(self scannerActionFor: each) notNil 				ifTrue: [grammar terminalSymbolNamed: each]]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileEmptySymbolTokenId	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'emptySymbolTokenId';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: SmaCCSymbol empty) printString.	self scannerClass compile: stream contents classified: #'generated-tokens'! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileErrorSymbolTokenId	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'errorTokenId';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: SmaCCSymbol error) printString.	self scannerClass compile: stream contents classified: #'generated-tokens'! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileIgnoreCaseMethod	SmaCCGrammar ignoreCase 		ifTrue: 			[scannerClass compile: 'keywordFor: aString 	^aString asUppercase'				classified: #'generated-scanner']! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileKeywordInitializerUsing: keywordMapDictionary selectorMap: selectorMapDictionary 	| stream dataStream |	keywordMapDictionary isEmpty ifTrue: [^self].	stream := WriteStream with: String new.	stream nextPutAll: 'initializeKeywordMap'.	stream nextPutAll: ' keywordMap :=  Dictionary new. '.	dataStream := WriteStream with: Array new.	keywordMapDictionary keysAndValuesDo: 			[:key :value | 			value keys asSortedCollection do: 					[:each | 					dataStream nextPut: (Array 								with: (selectorMapDictionary at: key ifAbsent: [key])								with: each								with: (selectorMapDictionary at: (value at: each) ifAbsent: [value at: each]))]].	stream		nextPutAll: '#(';		cr.	dataStream contents do: 			[:each | 			stream nextPutAll: '#('.			each do: [:item | item storeOn: stream] separatedBy: [stream nextPut: $ ].			stream nextPut: $)]		separatedBy: [stream cr].	stream nextPut: $).	stream 		nextPutAll: ' do: [:each | (keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2) put: each last]. ^keywordMap'.	scannerClass metaclass 		compile: (RBParser parseMethod: stream contents) formattedCode		classified: #'generated-initialization'! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileMethodsFor: regex withSelectors: selectorMap 	| keywordmap dfa |	dfa := regex asDFA.	keywordmap := self computeKeywordMapFor: dfa.	self compileKeywordInitializerUsing: keywordmap selectorMap: selectorMap.	dfa compileInto: scannerClass usingSelectorMap: selectorMap.	self compileEmptySymbolTokenId.	self compileErrorSymbolTokenId.	self compileIgnoreCaseMethod! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileScanner	| regex |	self addSpecialSymbols.	self addNormalSymbols.	self addActions.	self compileTokenIdMethods.	regex := self addSpecificREsWithoutActionsTo: self combinedGeneralRegexes.	self compileMethodsFor: regex withSelectors: self computeSelectorMap! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileScannerDefinitionComment	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'scannerDefinitionComment';		cr;		cr;		tab;		nextPut: $";		nextPutAll: (scannerDefinitionString copyReplaceAll: '"' with: '""');		nextPut: $".	self scannerClass metaclass compile: stream contents		classified: #'generated-comments'! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileTokenIdMethodFor: aTerminalSymbol 	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: aTerminalSymbol safeMethodName;		nextPutAll: 'Id';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: aTerminalSymbol) printString.	scannerClass compile: stream contents classified: #'generated-tokens'! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!compileTokenIdMethods	(self symbols select: [:each | each createIdMethod]) 		do: [:each | self compileTokenIdMethodFor: each]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: 'lr 1/6/2007 21:43'!computeSelectorMap	| selectorMap |	selectorMap := Dictionary new.	self symbols keysAndValuesDo: 			[:index :each | 			(self scannerActionFor: each name) 				ifNotNilDo: [:selector | selectorMap at: index put: selector]].	^selectorMap! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!filePositionSortBlock	^	[:a :b | 	| aRegex bRegex |	aRegex := a regularExpression.	bRegex := b regularExpression.	bRegex isNil or: 			[aRegex notNil 				and: [(aRegex position ifNil: [0]) < (bRegex position ifNil: [0])]]]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!regularExpressionsDo: aBlock 	self symbols do: [:each | each regularExpression ifNotNil: aBlock]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner' stamp: ' 6/1/07 21:19'!scannerActionFor: aString 	| selector |	aString size > 2 ifFalse: [^nil].	selector := (aString copyFrom: 2 to: aString size - 1) asSymbol.	^((scannerClass definesMethod: selector) 		and: [(Object canUnderstand: selector) not and: [selector numArgs = 0]]) 			ifTrue: [selector]			ifFalse: [nil]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!addActionsFrom: aRegularExpression to: aKeywordMap at: states 	^states do: 			[:state | 			state ~= aRegularExpression action 				ifTrue: 					[aRegularExpression possibleMatchesDo: 							[:string | 							(aKeywordMap at: state ifAbsentPut: [Dictionary new]) at: string								put: aRegularExpression action]]]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!addNormalSymbols	grammar 		symbols: (self symbols asSortedCollection: self filePositionSortBlock)! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!addSpecificREsWithoutActionsTo: aRegularExpression 	| dfa regex |	regex := aRegularExpression.	dfa := regex isNil ifTrue: [nil] ifFalse: [regex asDFA].	self specificRegularExpressionsDo: 			[:each | 			| actions |			actions := dfa isNil 						ifTrue: [nil]						ifFalse: [dfa actionForSpecificRegularExpression: each].			actions isNil 				ifTrue: [regex isNil ifTrue: [regex := each] ifFalse: [regex := regex | each]]].	^regex! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!combinedGeneralRegexes	| combinedRegex |	combinedRegex := nil.	self generalRegularExpressionsDo: 			[:each | 			combinedRegex := combinedRegex isNil 						ifTrue: [each]						ifFalse: [combinedRegex | each]].	^combinedRegex! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!computeKeywordMapFor: dfa 	| keywordmap |	keywordmap := Dictionary new.	self specificRegularExpressionsDo: 			[:each | 			| actions |			actions := dfa actionForSpecificRegularExpression: each.			actions isNil 				ifFalse: 					[self 						addActionsFrom: each						to: keywordmap						at: actions]].	^keywordmap! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!generalRegularExpressionsDo: aBlock 	self 		regularExpressionsDo: [:each | each isKeywordLiteral ifFalse: [aBlock value: each]]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction' stamp: ' 6/1/07 21:19'!specificRegularExpressionsDo: aBlock 	self 		regularExpressionsDo: [:each | each isKeywordLiteral ifTrue: [aBlock value: each]]! !!SmaCCScannerCompiler methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!grammar: aGrammar	grammar := aGrammar! !!SmaCCScannerCompiler methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!parseTokens	grammar scannerDefinition: (SmaCCScannerParser parse: scannerDefinitionString)! !!SmaCCScannerCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!scannerClass	^scannerClass! !!SmaCCScannerCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!scannerClass: anObject	scannerClass := anObject! !!SmaCCScannerCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!scannerDefinitionString: aString	scannerDefinitionString := aString! !!SmaCCScannerCompiler methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!symbols	^grammar symbols! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addExcludeState: aSymbol 	excludeStates add: aSymbol.	self addState: aSymbol! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addState: aSymbol	states add: aSymbol! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addToken: aSmaCCRENode withName: aString	tokens at: aString put: aSmaCCRENode! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!defaultState	^#default! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!nonExcludeStates	| nonExcludeStates |	nonExcludeStates := states reject: [:each | self isExcludeState: each].	nonExcludeStates add: self defaultState.	^nonExcludeStates! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!states	^states! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!tokenNamed: aString	^tokens at: aString! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!tokenNamed: aString ifAbsentPut: aBlock 	^tokens at: aString ifAbsentPut: aBlock! !!SmaCCScannerDefinition methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!tokens	^tokens! !!SmaCCScannerDefinition methodsFor: 'testing' stamp: ' 6/1/07 21:19'!includesTokenNamed: aString	^tokens includesKey: aString! !!SmaCCScannerDefinition methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isExcludeState: aSymbol	^excludeStates includes: aSymbol! !!SmaCCScannerDefinition methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	tokens := Dictionary new.	states := Set with: self defaultState.	excludeStates := Set new! !!SmaCCScannerParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!allCharacters	^SmaCCGrammar allCharacters! !!SmaCCScannerParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!charactersFor: aStream in: aToken 	| characters char endCharacters |	aStream atEnd ifTrue: [self reportCharacterBlockErrorForToken: aToken].	char := aStream next.	characters := char == $\ 				ifTrue: [(self nodeFor: aStream) characters]				ifFalse: [OrderedCollection with: char].	(characters size = 1 and: [aStream peekFor: $-]) ifFalse: [^characters].	endCharacters := self charactersFor: aStream in: aToken.	endCharacters size > 1 		ifTrue: [self reportCharacterBlockErrorForToken: aToken].	^(characters first asInteger to: endCharacters first asInteger) 		collect: [:each | Character value: each]! !!SmaCCScannerParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!generateImplicitToken: aSmaCCToken 	| node |	node := SmaCCGrammar implicitToken: aSmaCCToken value.	node isNil 		ifTrue: 			[currentToken := aSmaCCToken.			self reportErrorMessage: 'Token not specified'].	^node! !!SmaCCScannerParser methodsFor: 'private' stamp: 'lr 1/6/2007 21:44'!nodeFor: aStream 	| block char value count |	char := aStream next.	char == $f 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 12))].	char == $n 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 10))].	char == $r 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 13))].	char == $t ifTrue: [^SmaCCCharacterRENode characters: '	'].	char == $v 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 11))].	char == $c 		ifTrue: 			[^SmaCCCharacterRENode characters: (String 						with: (Character value: aStream next asInteger - $A asInteger))].	char == $x 		ifTrue: 			[count := value := 0.						[aStream atEnd not and: 					[count < 4 and: 							[char := aStream peek.							(char between: $0 and: $9) 								or: [(char between: $A and: $F) or: [char between: $a and: $f]]]]] 					whileTrue: 						[count := count + 1.						value := value * 16 + aStream next digitValue].			^SmaCCCharacterRENode characters: (String with: (Character value: value))].	char == $d ifTrue: [block := [:each | each between: $0 and: $9]].	char == $D ifTrue: [block := [:each | (each between: $0 and: $9) not]].	char == $s 		ifTrue: [block := [:each | #(9 10 11 12 13 32) includes: each asInteger]].	char == $S 		ifTrue: 			[block := [:each | (#(9 10 11 12 13 32) includes: each asInteger) not]].	char == $w 		ifTrue: 			[block := 					[:each | 					(each between: $a and: $z) or: 							[(each between: $A and: $Z) 								or: [(each between: $0 and: $9) or: [each == $_]]]]].	char == $W 		ifTrue: 			[block := 					[:each | 					((each between: $a and: $z) or: 							[(each between: $A and: $Z) 								or: [(each between: $0 and: $9) or: [each == $_]]]) 						not]].	block isNil 		ifTrue: [^SmaCCCharacterRENode characters: (String with: char)].	^SmaCCCharacterRENode 		characters: (String withAll: (self allCharacters select: block))! !!SmaCCScannerParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!parseCharacterBlock: aToken 	| characters aStream invert |	aStream := ReadStream 				on: (aToken value copyFrom: 2 to: aToken value size - 1).	characters := OrderedCollection new.	invert := aStream peekFor: $^.	[aStream atEnd] 		whileFalse: [characters addAll: (self charactersFor: aStream in: aToken)].	^String withAll: (invert 				ifTrue: [self allCharacters reject: [:each | characters includes: each]]				ifFalse: [characters])! !!SmaCCScannerParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!reportCharacterBlockErrorForToken: aToken 	currentToken := aToken.	self reportErrorMessage: 'Invalid character block'! !!SmaCCScannerParser methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!initialize	super initialize.	scannerDefinition := SmaCCScannerDefinition new! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForExcludeStates2: nodes 	^ scannerDefinition addExcludeState: (nodes at: 2)! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForFile1: nodes 	^ scannerDefinition! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForFile2: nodes 	^ scannerDefinition! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegex1: nodes 	^ nodes at: 1! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegex2: nodes 	^ (nodes at: 1) | (nodes at: 3)! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegex3: nodes 	^ (nodes at: 1) , (nodes at: 2)! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexRule1: nodes 	(nodes at: 3) position: (nodes at: 1) startPosition.	scannerDefinition addToken: (nodes at: 3) withName: (nodes at: 1) value.	^ nodes at: 3! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexRule2: nodes 	^ (nodes at: 2)		addState: (nodes at: 1);		yourself! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm10: nodes 	^ (nodes at: 1) repeatFor: 0 to: 1! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm11: nodes 	| readStream start stop |	readStream := ReadStream 				on: ((nodes at: 2) value copyFrom: 2 to: (nodes at: 2) value size - 1).	start := readStream upTo: $,.	stop := readStream upToEnd.	^ (nodes at: 1) 		repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber])		to: (stop isEmpty ifTrue: [1 bitShift: 31] ifFalse: [stop asNumber])! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm1: nodes 	^ SmaCCCharacterRENode characters: (nodes at: 1) value! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm2: nodes 	^ SmaCCCharacterRENode characters: self allCharacters! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm3: nodes 	^ self nodeFor: (ReadStream 				on: ((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size))! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm4: nodes 	^ nodes at: 2! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm5: nodes 	^ SmaCCCharacterRENode 		characters: (self parseCharacterBlock: (nodes at: 1))! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm6: nodes 	^ (scannerDefinition tokenNamed: (nodes at: 1) value		ifAbsentPut: [self generateImplicitToken: (nodes at: 1)]) copy! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm7: nodes 	^ SmaCCSequenceRENode nodes: ((nodes at: 1) value asOrderedCollection 				collect: [:each | SmaCCCharacterRENode characters: (String with: each)])! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm8: nodes 	^ (nodes at: 1) repeat! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRegexTerm9: nodes 	^ (nodes at: 1) repeatForAtLeast: 1! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForRule1: nodes 	^ (nodes at: 1) states isEmpty 		ifTrue: [(nodes at: 1) addStates: scannerDefinition nonExcludeStates]! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForStates2: nodes 	^ scannerDefinition addState: (nodes at: 2)! !!SmaCCScannerParser methodsFor: 'generated-reduction actions' stamp: 'lr 1/22/2007 13:12'!reduceActionForSymbol1: nodes 	^ (nodes at: 1) value asSymbol! !!SmaCCScannerParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:12'!reduceTable	^#(#(20 1 #reduceFor:)#(21 1 #reduceActionForFile1:)#(21 0 #reduceActionForFile2:)#(22 3 #reduceActionForRegexRule1:)#(22 2 #reduceActionForRegexRule2:)#(23 2 #reduceFor:)#(24 1 #reduceActionForRule1:)#(24 1 #reduceFor:)#(24 1 #reduceFor:)#(25 1 #reduceActionForRegex1:)#(25 3 #reduceActionForRegex2:)#(25 2 #reduceActionForRegex3:)#(26 1 #reduceActionForSymbol1:)#(27 0 #reduceFor:)#(27 2 #reduceActionForStates2:)#(28 0 #reduceFor:)#(28 2 #reduceActionForExcludeStates2:)#(29 1 #reduceActionForRegexTerm1:)#(29 1 #reduceActionForRegexTerm2:)#(29 1 #reduceActionForRegexTerm3:)#(29 3 #reduceActionForRegexTerm4:)#(29 1 #reduceActionForRegexTerm5:)#(29 1 #reduceActionForRegexTerm6:)#(29 1 #reduceActionForRegexTerm7:)#(29 2 #reduceActionForRegexTerm8:)#(29 2 #reduceActionForRegexTerm9:)#(29 2 #reduceActionForRegexTerm10:)#(29 2 #reduceActionForRegexTerm11:)#(32 2 #reduceFor:)#(32 3 #reduceFor:)#(33 2 #reduceFor:))! !!SmaCCScannerParser methodsFor: 'generated-tables' stamp: 'lr 1/22/2007 13:12'!transitionTable	^#(#(3 9 7 13 8 17 14 21 17 25 21 29 22 33 23 37 24 41 26 14 30 45 32 49 33)#(3 66 9 66 17 53 28)#(3 58 9 58 17 57 27)#(2 61 10)#(2 54 9 14 17)#(2 0 30)#(2 30 9)#(2 34 9)#(2 65 9)#(3 17 14 21 17 69 22 41 26)#(3 9 7 13 8 17 14 21 17 29 22 33 23 73 24 41 26 10 30 49 33)#(2 38 9)#(3 26 9 21 17 77 26)#(3 126 9 21 17 81 26)#(3 85 2 89 11 93 12 97 14 101 17 105 18 109 19 113 25 117 29)#(2 118 7 8 14 17 30)#(2 22 9)#(2 121 9)#(2 70 9 17)#(2 62 9 17)#(3 85 2 89 11 93 12 97 14 101 17 105 18 109 19 125 25 117 29)#(2 82 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 90 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 94 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 98 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 74 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 78 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(3 85 2 129 5 18 9 89 11 93 12 97 14 101 17 105 18 109 19 133 29)#(3 42 1 42 2 137 3 141 4 42 5 145 6 42 9 42 11 42 12 42 14 149 16 42 17 42 18 42 19)#(2 122 7 8 14 17 30)#(3 153 1 85 2 129 5 89 11 93 12 97 14 101 17 105 18 109 19 133 29)#(3 85 2 89 11 93 12 97 14 101 17 105 18 109 19 157 25 117 29)#(3 50 1 50 2 137 3 141 4 50 5 145 6 50 9 50 11 50 12 50 14 149 16 50 17 50 18 50 19)#(2 106 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 102 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 110 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 114 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(2 86 1 2 3 4 5 6 9 11 12 14 16 17 18 19)#(3 46 1 85 2 46 5 46 9 89 11 93 12 97 14 101 17 105 18 109 19 133 29))! !!SmaCCScannerParser class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:12'!parserDefinitionComment	"%left	""|"";%left ""("" <character> <backslashcharacter> <characterblock> <anycharacter> <tokenname> <symbol>;%left ""*"" ""+"" ""?"" <repeat> ;File: Rules	 {scannerDefinition} 	|  {scannerDefinition};Rules: Rule "";""	| Rules Rule "";"" ;Rule: RegexRule {'1' states isEmpty ifTrue: ['1' addStates: scannerDefinition nonExcludeStates]}	| ExcludeStatesLine 	| StatesLine ;RegexRule : <tokenname> "":"" Regex {'3' position: '1' startPosition. scannerDefinition addToken: '3' withName: '1' value. '3'}	| Symbol RegexRule {'2' addState: '1'; yourself};StatesLine : ""%states"" States ;States :	| States Symbol {scannerDefinition addState: '2'};ExcludeStatesLine : ""%excludes"" ExcludeStates ;ExcludeStates : 	| ExcludeStates Symbol {scannerDefinition addExcludeState: '2'};Symbol : <symbol> {'1' value asSymbol};Regex: RegexTerm {'1'}	| Regex ""|"" Regex {'1' | '3'}	| Regex RegexTerm {'1' , '2'};RegexTerm:	<character> {SmaCCCharacterRENode characters: '1' value}	| <anycharacter> {SmaCCCharacterRENode characters: self allCharacters}	| <backslashcharacter> {self nodeFor: (ReadStream on: ('1' value copyFrom: 2 to: '1' value size))} 	| ""("" Regex "")"" {'2'}	| <characterblock> {SmaCCCharacterRENode characters: (self parseCharacterBlock: '1')}	| <tokenname> {(scannerDefinition tokenNamed: '1' value ifAbsentPut: [self generateImplicitToken: '1']) copy}	| <symbol> {SmaCCSequenceRENode nodes: ('1' value asOrderedCollection collect: [:each | SmaCCCharacterRENode characters: (String with: each)])}	| RegexTerm ""*""	{'1' repeat}	| RegexTerm ""+"" {'1' repeatForAtLeast: 1}	| RegexTerm ""?"" {'1' repeatFor: 0 to: 1}	| RegexTerm <repeat> {| readStream start stop | 					readStream := ReadStream on: ('2' value copyFrom: 2 to: '2' value size - 1). 					start := readStream upTo: $,. 					stop := readStream upToEnd.					'1' repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber]) to: (stop isEmpty ifTrue: [(1 bitShift: 31)] ifFalse: [stop asNumber])} ;"! !!SmaCCScannerParser class methodsFor: 'generated-accessing' stamp: 'lr 1/22/2007 13:12'!scannerClass	^SmaCCScannerScanner! !!SmaCCScannerParser class methodsFor: 'generated-starting states' stamp: 'lr 1/22/2007 13:12'!startingStateForFile	^1! !!SmaCCScannerScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:12'!emptySymbolTokenId	^30! !!SmaCCScannerScanner methodsFor: 'generated-tokens' stamp: 'lr 1/22/2007 13:12'!errorTokenId	^31! !!SmaCCScannerScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan1		[self step.	currentCharacter ~= $*] whileTrue.	currentCharacter = $* 		ifTrue: 			[			[self step.			(currentCharacter <= $) 				or: [(currentCharacter between: $+ and: $.) or: [currentCharacter >= $0]]) 					ifTrue: [^ self scan1].			currentCharacter = $*] 					whileTrue.			currentCharacter = $/ ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	^ self reportLastMatch! !!SmaCCScannerScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan2	self step.	(currentCharacter <= $b 		or: [(currentCharacter between: $d and: $w) or: [currentCharacter >= $y]]) 			ifTrue: [^ self scan3].	currentCharacter = $c 		ifTrue: 			[self step.			(currentCharacter between: $A and: $Z) ifTrue: [^ self scan3].			^ self reportLastMatch].	currentCharacter = $x 		ifTrue: 			[self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $F) 						or: [currentCharacter between: $a and: $f]]) 				ifTrue: [^ self scan3].			^ self reportLastMatch].	^ self reportLastMatch! !!SmaCCScannerScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scan3		[self step.	currentCharacter <= $[ or: [currentCharacter >= $^]] whileTrue.	currentCharacter = $\ ifTrue: [^ self scan2].	currentCharacter = $] ifTrue: [^ self recordAndReportMatch: #(12 )].	^ self reportLastMatch! !!SmaCCScannerScanner methodsFor: 'generated-scanner' stamp: 'lr 1/22/2007 13:12'!scanForToken	self step.	(currentCharacter <= Character backspace or: 			[currentCharacter = Character newPage or: 					[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 						or: 							[(currentCharacter between: $!! and: $") or: 									[currentCharacter = $$ or: 											[(currentCharacter between: $& and: $') or: 													[(currentCharacter between: $, and: $-) or: 															[(currentCharacter between: $0 and: $9) or: 																	[(currentCharacter between: $= and: $>) or: 																			[currentCharacter = $@ or: 																					[(currentCharacter between: $] and: $^) 																						or: [currentCharacter = $` or: [currentCharacter >= $}]]]]]]]]]]]]) 		ifTrue: [^ self recordAndReportMatch: #(18 )].	((currentCharacter between: $A and: $Z) 		or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]) 			ifTrue: 				[self recordMatch: #(17 18 ).				self step.				((currentCharacter between: $0 and: $9) or: 						[(currentCharacter between: $A and: $Z) 							or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]) 					ifTrue: 						[						[self recordMatch: #(17 ).						self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 								whileTrue.						^ self reportLastMatch].				^ self reportLastMatch].	((currentCharacter between: Character tab and: (Character value: 11)) 		or: [currentCharacter = Character cr or: [currentCharacter = Character space]]) 			ifTrue: 				[				[self recordMatch: #whitespace.				self step.				(currentCharacter between: Character tab and: (Character value: 11)) 					or: [currentCharacter = Character cr or: [currentCharacter = Character space]]] 						whileTrue.				^ self reportLastMatch].	currentCharacter = $# 		ifTrue: 			[self recordMatch: #comment.			self step.			(currentCharacter <= Character tab or: 					[(currentCharacter between: (Character value: 11) and: Character newPage) 						or: [currentCharacter >= (Character value: 14)]]) 				ifTrue: 					[					[self recordMatch: #comment.					self step.					currentCharacter <= Character tab or: 							[(currentCharacter between: (Character value: 11) and: Character newPage) 								or: [currentCharacter >= (Character value: 14)]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $% 		ifTrue: 			[self recordMatch: #(18 ).			self step.			currentCharacter = $e 				ifTrue: 					[self step.					currentCharacter = $x 						ifTrue: 							[self step.							currentCharacter = $c 								ifTrue: 									[self step.									currentCharacter = $l 										ifTrue: 											[self step.											currentCharacter = $u 												ifTrue: 													[self step.													currentCharacter = $d 														ifTrue: 															[self step.															currentCharacter = $e 																ifTrue: 																	[self step.																	currentCharacter = $s ifTrue: [^ self recordAndReportMatch: #(7 )].																	^ self reportLastMatch].															^ self reportLastMatch].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			currentCharacter = $s 				ifTrue: 					[self step.					currentCharacter = $t 						ifTrue: 							[self step.							currentCharacter = $a 								ifTrue: 									[self step.									currentCharacter = $t 										ifTrue: 											[self step.											currentCharacter = $e 												ifTrue: 													[self step.													currentCharacter = $s ifTrue: [^ self recordAndReportMatch: #(8 )].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $( ifTrue: [^ self recordAndReportMatch: #(2 )].	currentCharacter = $) ifTrue: [^ self recordAndReportMatch: #(1 18 )].	currentCharacter = $* ifTrue: [^ self recordAndReportMatch: #(4 18 )].	currentCharacter = $+ ifTrue: [^ self recordAndReportMatch: #(3 18 )].	currentCharacter = $. ifTrue: [^ self recordAndReportMatch: #(19 )].	currentCharacter = $/ 		ifTrue: 			[self recordMatch: #(18 ).			self step.			currentCharacter = $* ifTrue: [^ self scan1].			^ self reportLastMatch].	currentCharacter = $: ifTrue: [^ self recordAndReportMatch: #(10 18 )].	currentCharacter = $; ifTrue: [^ self recordAndReportMatch: #(9 18 )].	currentCharacter = $< 		ifTrue: 			[self recordMatch: #(18 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter = $_ or: [currentCharacter between: $a and: $z]]]] 								whileTrue.						currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(14 )].						^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $? ifTrue: [^ self recordAndReportMatch: #(6 18 )].	currentCharacter = $[ 		ifTrue: 			[self step.			(currentCharacter <= $[ or: [currentCharacter >= $^]) 				ifTrue: [^ self scan3].			currentCharacter = $\ ifTrue: [^ self scan2].			^ self reportLastMatch].	currentCharacter = $\ 		ifTrue: 			[self step.			(currentCharacter <= $b 				or: [(currentCharacter between: $d and: $w) or: [currentCharacter >= $y]]) 					ifTrue: [^ self recordAndReportMatch: #(11 )].			currentCharacter = $c 				ifTrue: 					[self step.					(currentCharacter between: $A and: $Z) 						ifTrue: [^ self recordAndReportMatch: #(11 )].					^ self reportLastMatch].			currentCharacter = $x 				ifTrue: 					[self step.					((currentCharacter between: $0 and: $9) or: 							[(currentCharacter between: $A and: $F) 								or: [currentCharacter between: $a and: $f]]) 						ifTrue: 							[self recordMatch: #(11 ).							self step.							((currentCharacter between: $0 and: $9) or: 									[(currentCharacter between: $A and: $F) 										or: [currentCharacter between: $a and: $f]]) 								ifTrue: 									[self recordMatch: #(11 ).									self step.									((currentCharacter between: $0 and: $9) or: 											[(currentCharacter between: $A and: $F) 												or: [currentCharacter between: $a and: $f]]) 										ifTrue: 											[self recordMatch: #(11 ).											self step.											((currentCharacter between: $0 and: $9) or: 													[(currentCharacter between: $A and: $F) 														or: [currentCharacter between: $a and: $f]]) 												ifTrue: [^ self recordAndReportMatch: #(11 )].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = ${ 		ifTrue: 			[			[self step.			currentCharacter between: $0 and: $9] whileTrue.			currentCharacter = $, 				ifTrue: 					[					[self step.					currentCharacter between: $0 and: $9] whileTrue.					currentCharacter = $} ifTrue: [^ self recordAndReportMatch: #(16 )].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $| ifTrue: [^ self recordAndReportMatch: #(5 18 )].	^ self reportLastMatch! !!SmaCCScannerScanner class methodsFor: 'generated-comments' stamp: 'lr 1/22/2007 13:12'!scannerDefinitionComment	"<backslashcharacter>	:	\\ [^cx] | \\ c [A-Z] | \\ x [0-9A-Fa-f]{1,4} ;<characterblock>	: \[ ([^\]\\] | <backslashcharacter> )+ \] ;<whitespace>	:	[\ \t\v\r\n]+ ;<tokenname>	:	\< [a-zA-Z_] \w* \> ;<comment>	:	(\# [^\r\n]*) | (\/\* [^\*]* \*+ ([^\/\*] [^\*]* \*+)* \/) ;<repeat>	:	\{ [0-9]* \, [0-9]* \} ;<symbol> : [a-zA-Z_] \w* ;<character>	:	[^\ \t\v\\\r\n\{\(\[\.] ; <anycharacter>	: \. ;"! !!SmaCCSequenceRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!, aSmaCCRegularExpressionNode 	self action = aSmaCCRegularExpressionNode action 		ifFalse: [^super , aSmaCCRegularExpressionNode].	nodes add: aSmaCCRegularExpressionNode.	^self! !!SmaCCSequenceRENode methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!possibleMatchesSize	^nodes inject: 1 into: [:sum :each | sum * each possibleMatchesSize]! !!SmaCCSequenceRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!asNFAStartingWith: aSmaCCNode 	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	(nodes inject: startNode into: [:sum :each | each asNFAStartingWith: sum]) 		addEdgeTo: endNode.	^endNode! !!SmaCCSequenceRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream 	self 		possibleMatchesDo: aBlock		on: aStream		startingAt: 1! !!SmaCCSequenceRENode methodsFor: 'private' stamp: ' 6/1/07 21:19'!possibleMatchesDo: aBlock on: aStream startingAt: anInteger 	| node |	node := nodes at: anInteger.	nodes size = anInteger 		ifTrue: [node possibleMatchesDo: aBlock on: aStream]		ifFalse: 			[node possibleMatchesDo: 					[self 						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]! !!SmaCCSequenceRENode methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!nodes: aCollection 	nodes := aCollection! !!SmaCCSequenceRENode methodsFor: 'copying' stamp: ' 6/1/07 21:19'!postCopy	super postCopy.	nodes := nodes copy! !!SmaCCSequenceRENode methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	nodes do: [:each | each printOn: aStream] separatedBy: [aStream space]! !!SmaCCSequenceRENode class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!nodes: aCollection 	^(self new)		nodes: aCollection;		yourself! !!SmaCCShiftAction methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!id	^2r01! !!SmaCCShiftAction methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isShift	^true! !!SmaCCShiftAction class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!initialize	Shift := self basicNew! !!SmaCCShiftAction class methodsFor: 'class initialization' stamp: ' 6/1/07 21:19'!releaseObjects	Shift := nil! !!SmaCCShiftAction class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!new	^Shift! !!SmaCCStateEdge methodsFor: 'comparing' stamp: ' 6/1/07 21:19'!<= aSmaCCEdge 	^self class ~= aSmaCCEdge class 		or: [self transitionObjects first <= aSmaCCEdge transitionObjects first]! !!SmaCCStateEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!edgeFrequencyUsingTable: frequencyTable 	^SmallInteger maxVal * transitionObjects size! !!SmaCCStateEdge methodsFor: 'compiling' stamp: ' 6/1/07 21:19'!expression	^transitionObjects size = 1 		ifTrue: ['state == #' , transitionObjects asArray first]		ifFalse: ['(' , transitionObjects asArray storeString , ' includes: state)']! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!calculateFirstTerminals	^self subclassResponsibility! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!createIdMethod	^false! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!firstTerminals	^firstItems! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!isEmptySymbol	^self = self class empty! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!name	^name! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!precedence	^precedence! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!precedence: anInteger	precedence := anInteger! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!productionsDo: aBlock! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!regularExpression	^nil! !!SmaCCSymbol methodsFor: 'accessing' stamp: 'lr 1/7/2007 10:57'!safeMethodName	^self unsafeMethodName 		collect: [:each | each isAlphaNumeric ifTrue: [each] ifFalse: [$X]]! !!SmaCCSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!size	^0! !!SmaCCSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isStartingSymbol	^false! !!SmaCCSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isTerminal	^self subclassResponsibility! !!SmaCCSymbol methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!name: aString 	name := aString.	firstItems := Set new! !!SmaCCSymbol methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	aStream nextPutAll: name! !!SmaCCSymbol methodsFor: 'private' stamp: ' 6/1/07 21:19'!unsafeMethodName	^self printString! !!SmaCCNonTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addProduction: aSmaCCRHS	productions add: aSmaCCRHS! !!SmaCCNonTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!calculateFirstTerminals	| initialSize |	initialSize := firstItems size.	productions isEmpty 		ifTrue: [firstItems add: self class empty]		ifFalse: [productions do: [:each | firstItems addAll: each firstTerminals]].	^initialSize ~= firstItems size! !!SmaCCNonTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!positionOf: aSmaCCRHS 	^productions indexOf: aSmaCCRHS! !!SmaCCNonTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!productionsDo: aBlock 	productions do: aBlock! !!SmaCCNonTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!size	^productions size! !!SmaCCNonTerminalSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isEmpty	^productions isEmpty! !!SmaCCNonTerminalSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isTerminal	^false! !!SmaCCNonTerminalSymbol methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!name: aString 	super name: aString.	productions := OrderedCollection new! !!SmaCCStartingSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!asLRItemSet	| itemSet |	itemSet := SmaCCItemSet new.	productions do: 			[:each | 			itemSet add: (SmaCCLR1Item 						symbol: self						rhs: each						follow: ((SmaCCSymbolSet new)								add: self class empty;								yourself))].	^itemSet! !!SmaCCStartingSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!compileName	^(productions first at: 1) safeMethodName! !!SmaCCStartingSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isStartingSymbol	^true! !!SmaCCSymbol class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!empty	EmptySymbol isNil 		ifTrue: [EmptySymbol := SmaCCTerminalSymbol name: 'E O F'].	^EmptySymbol! !!SmaCCSymbol class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!error	ErrorSymbol isNil 		ifTrue: [ErrorSymbol := SmaCCTerminalSymbol name: 'error'].	^ErrorSymbol! !!SmaCCSymbol class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!name: aString 	^(self new)		name: aString;		yourself! !!SmaCCSymbol class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!releaseObjects	EmptySymbol := nil.	SentinelSymbol := nil.	ErrorSymbol := nil! !!SmaCCSymbol class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!sentinel	SentinelSymbol isNil 		ifTrue: [SentinelSymbol := SmaCCTerminalSymbol name: 'S e n t i n e l'].	^SentinelSymbol! !!SmaCCSymbolSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!add: aSmaCCSymbol 	(symbols includes: aSmaCCSymbol) ifTrue: [^self].	symbols add: aSmaCCSymbol.	self changed! !!SmaCCSymbolSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!addAll: aCollection 	| oldSize |	oldSize := symbols size.	symbols addAll: aCollection.	oldSize ~= symbols size ifTrue: [self changed]! !!SmaCCSymbolSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!baseOn: aSmaCCSymbolSet 	self addComponent: aSmaCCSymbolSet.	self addAll: aSmaCCSymbolSet symbols! !!SmaCCSymbolSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!mergeWith: aSmaCCSymbolSet 	self addAll: aSmaCCSymbolSet symbols.	self addComponentsFrom: aSmaCCSymbolSet! !!SmaCCSymbolSet methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!size	^symbols size! !!SmaCCSymbolSet methodsFor: 'private' stamp: ' 6/1/07 21:19'!addComponent: each 	(each = self or: [components includes: each]) ifTrue: [^self].	components add: each.	each addDependent: self.	self addAll: each symbols! !!SmaCCSymbolSet methodsFor: 'private' stamp: ' 6/1/07 21:19'!addComponentsFrom: aSmaCCSymbolSet 	aSmaCCSymbolSet components do: [:each | self addComponent: each]! !!SmaCCSymbolSet methodsFor: 'private' stamp: ' 6/1/07 21:19'!components	^components! !!SmaCCSymbolSet methodsFor: 'private' stamp: ' 6/1/07 21:19'!symbols	^symbols! !!SmaCCSymbolSet methodsFor: 'testing' stamp: ' 6/1/07 21:19'!allSatisfy: aBlock 	^symbols allSatisfy: aBlock! !!SmaCCSymbolSet methodsFor: 'testing' stamp: ' 6/1/07 21:19'!includes: aSmaCCSymbol 	^symbols includes: aSmaCCSymbol! !!SmaCCSymbolSet methodsFor: 'initialize-release' stamp: 'lr 1/8/2007 14:42'!initialize	symbols := Set new.	components := Set new! !!SmaCCSymbolSet methodsFor: 'printing' stamp: ' 6/1/07 21:19'!printOn: aStream 	symbols do: [:each | aStream nextPutAll: each printString]		separatedBy: [aStream space]! !!SmaCCSymbolSet methodsFor: 'updating' stamp: 'lr 1/8/2007 14:47'!update: aSender	(components includes: aSender) ifTrue: [self addAll: aSender symbols]! !!SmaCCSymbolSet class methodsFor: 'instance creation' stamp: ' 6/1/07 21:19'!basedOn: aSmaCCSymbolSet 	^(self new)		baseOn: aSmaCCSymbolSet;		yourself! !!SmaCCTerminalSymbol methodsFor: 'private' stamp: ' 6/1/07 21:19'!calculateFirstTerminals	^false! !!SmaCCTerminalSymbol methodsFor: 'private' stamp: ' 6/1/07 21:19'!unsafeMethodName	^name copyFrom: 2 to: name size - 1! !!SmaCCTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!createIdMethod	^createIdMethod! !!SmaCCTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!createIdMethod: aBoolean	createIdMethod := aBoolean! !!SmaCCTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!regularExpression	^regularExpression! !!SmaCCTerminalSymbol methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!regularExpression: aSmaCCRegularExpressionNode	regularExpression := aSmaCCRegularExpressionNode! !!SmaCCTerminalSymbol methodsFor: 'testing' stamp: ' 6/1/07 21:19'!isTerminal	^true! !!SmaCCTerminalSymbol methodsFor: 'initialize-release' stamp: ' 6/1/07 21:19'!name: aString 	super name: aString.	firstItems add: self.	createIdMethod := false! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!id	^id! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!startPosition	^start! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!stopPosition	^start + value size - 1! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!value	^value! !!SmaCCToken methodsFor: 'printing' stamp: ' 6/1/07 20:34'!printOn: aStream 	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self id printString;		nextPutAll: ')}'! !!SmaCCToken methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!value: anObject start: startPositionInteger id: anInteger 	value := anObject.	start := startPositionInteger.	id := anInteger! !!SmaCCToken class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!value: aString start: anInteger id: anObject 	^(self new)		value: aString			start: anInteger			id: anObject;		yourself! !!SmalllintChecker methodsFor: 'private'!checkClass: aClass 	context selectedClass: aClass.	(environment definesClass: aClass) ifTrue: [rule checkClass: context]! !!SmalllintChecker methodsFor: 'private'!checkMethodsForClass: aClass 	^environment selectorsForClass: aClass		do: 			[:each | 			context selector: each.			rule checkMethod: context.			methodBlock value]! !!SmalllintChecker methodsFor: 'accessing'!context: aSmalllintContext 	context := aSmalllintContext! !!SmalllintChecker methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!SmalllintChecker methodsFor: 'accessing'!methodBlock: aBlock 	methodBlock := aBlock! !!SmalllintChecker methodsFor: 'accessing'!rule: aLintRule 	rule := aLintRule! !!SmalllintChecker methodsFor: 'initialize-release'!initialize	methodBlock := [].	environment := SelectorEnvironment new.	context := SmalllintContext newNoCache! !!SmalllintChecker methodsFor: 'initialize-release'!release	context release.	super release! !!SmalllintChecker methodsFor: 'actions'!run	rule resetResult.	environment classesDo: 			[:aClass | 			self checkClass: aClass.			self checkMethodsForClass: aClass]! !!SmalllintChecker class methodsFor: 'instance creation'!newWithContext	^(self new)		context: SmalllintContext new;		yourself! !!SmalllintChecker class methodsFor: 'instance creation' stamp: 'nk 11/12/2002 13:12'!runRule: aLintRule	(self new)		rule: aLintRule;		run.	^aLintRule! !!SmalllintChecker class methodsFor: 'instance creation'!runRule: aLintRule onEnvironment: aBrowserEnvironment 	(self new)		rule: aLintRule;		environment: aBrowserEnvironment;		run.	^aLintRule! !!SmalllintContext methodsFor: 'private' stamp: 'md 8/2/2005 23:19'!addLiteralsFor: aCompiledMethod 	aCompiledMethod literalsDo: [:literal | self checkLiteral: literal]! !!SmalllintContext methodsFor: 'private'!buildParseTree	| tree |	tree := self selectedClass parseTreeFor: self selector.	tree isNil ifTrue: [^RBParser parseMethod: 'method'].	^tree! !!SmalllintContext methodsFor: 'private'!checkLiteral: aLiteral 	(aLiteral isSymbol or: [aLiteral isVariableBinding])		ifTrue: [literals add: aLiteral]		ifFalse: 			[aLiteral class == Array				ifTrue: [aLiteral do: [:each | self checkLiteral: each]]]! !!SmalllintContext methodsFor: 'private'!computeLiterals	literalSemaphore := Semaphore new.	literalProcess := [self primitiveComputeLiterals] fork! !!SmalllintContext methodsFor: 'private'!computeLiteralsForClass: aClass 	(selectors addAll: aClass selectors) do: 			[:sel | 			self computeLiteralsForSelector: sel in: aClass.			Processor yield]! !!SmalllintContext methodsFor: 'private'!computeLiteralsForSelector: aSelector in: aClass 	| method |	method := aClass compiledMethodAt: aSelector ifAbsent: [nil].	method isNil ifTrue: [^self].	self addLiteralsFor: method! !!SmalllintContext methodsFor: 'private' stamp: 'jws 10/23/2016 05:39'!computeMessages	| searcher |	selfMessages := Set new.	superMessages := Set new.	messages := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: 'self `@message: ``@args' do: [ :aNode :answer | selfMessages add: aNode selector ];		matches: 'super `@message: ``@args' do: [ :aNode :answer | superMessages add: aNode selector ];		matches: '``@receiver `@message: ``@args' do: [ :aNode :answer | messages add: aNode selector ].	searcher executeTree: self parseTree initialAnswer: nil! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 8/27/2003 14:35'!primitiveComputeLiterals	| semaphore |	literals := IdentitySet new: 25000.	literals addAll: self specialSelectors keys.	selectors := IdentitySet new.	SystemNavigation new allBehaviorsDo: [:aClass | self computeLiteralsForClass: aClass].	semaphore := literalSemaphore.	literalSemaphore := nil.	self signalProcesses: semaphore.	^literalProcess := nil! !!SmalllintContext methodsFor: 'private'!signalProcesses: aSemaphore 	aSemaphore isNil ifTrue: [^self].	[aSemaphore isEmpty] whileFalse: [aSemaphore signal]! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 9/15/2001 17:39'!specialSelectors	| answer |	answer := IdentityDictionary new.	(Smalltalk specialSelectors select: [:sel | sel isSymbol]) do:		[:sel | answer at: sel put: nil.].	^answer.! !!SmalllintContext methodsFor: 'accessing'!compiledMethod	^compiledMethod notNil		ifTrue: [compiledMethod]		ifFalse: [compiledMethod := class compiledMethodAt: selector]! !!SmalllintContext methodsFor: 'accessing'!instVarNames	^self selectedClass allInstVarNames! !!SmalllintContext methodsFor: 'accessing'!literals	literalSemaphore isNil		ifTrue: 			[literals isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^literals! !!SmalllintContext methodsFor: 'accessing'!messages	messages isNil ifTrue: [self computeMessages].	^messages! !!SmalllintContext methodsFor: 'accessing'!parseTree	^parseTree isNil		ifTrue: [parseTree := self buildParseTree]		ifFalse: [parseTree]! !!SmalllintContext methodsFor: 'accessing'!protocol	^self selectedClass whichCategoryIncludesSelector: self selector! !!SmalllintContext methodsFor: 'accessing'!protocols	^Array with: self protocol! !!SmalllintContext methodsFor: 'accessing'!selectedClass	^class! !!SmalllintContext methodsFor: 'accessing'!selectedClass: anObject 	class := anObject.	self selector: nil! !!SmalllintContext methodsFor: 'accessing'!selector	^selector! !!SmalllintContext methodsFor: 'accessing'!selector: anObject 	selector := anObject.	parseTree := compiledMethod := selfMessages := superMessages := messages := nil! !!SmalllintContext methodsFor: 'accessing'!selectors	literalSemaphore isNil		ifTrue: 			[selectors isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^selectors! !!SmalllintContext methodsFor: 'accessing'!selfMessages	selfMessages isNil ifTrue: [self computeMessages].	^selfMessages! !!SmalllintContext methodsFor: 'accessing' stamp: 'nk 2/26/2005 10:19'!sourceCode	^self selectedClass sourceCodeAt: self selector ifAbsent: [ '' ].! !!SmalllintContext methodsFor: 'accessing'!superMessages	superMessages isNil ifTrue: [self computeMessages].	^superMessages! !!SmalllintContext methodsFor: 'testing'!implements: aSelector 	^self selectors includes: aSelector! !!SmalllintContext methodsFor: 'testing'!isAbstract: aClass 	^(aClass isMeta or: 			[(self literals includes: aClass name)				or: [self literals includes: (Smalltalk associationAt: aClass name)]])		not! !!SmalllintContext methodsFor: 'testing'!uses: anObject 	^self literals includes: anObject! !!SmalllintContext methodsFor: 'initialize-release'!initialize	self computeLiterals! !!SmalllintContext methodsFor: 'initialize-release'!release	literalProcess notNil ifTrue: [literalProcess terminate].	super release! !!SmalllintContext class methodsFor: 'instance creation'!newNoCache	^self basicNew! !!SmalllintTest methodsFor: 'set up'!blockRuleFor: aSelector 	self blockRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!blockRuleFor: aSelector plusSelectors: symbolCollection 	| rule returnedEnvironment testSel |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	(BlockLintRule class includesSelector: testSel) ifFalse: [^self].	SmalllintChecker runRule: (rule := BlockLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!checkRule: aLintRule isEqualTo: anEnvironment 	| returnedEnvironment |	returnedEnvironment := aLintRule result.	self compare: returnedEnvironment to: anEnvironment.	self compare: anEnvironment to: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!compare: subEnvironment to: superEnvironment 	subEnvironment classesDo: 			[:each | 			(subEnvironment selectorsForClass: each) 				do: [:sel | self assert: (superEnvironment includesSelector: sel in: each)]]! !!SmalllintTest methodsFor: 'set up'!currentSelector	^thisContext sender selector! !!SmalllintTest methodsFor: 'set up'!parseTreeRuleFor: aSelector 	self parseTreeRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!parseTreeRuleFor: aSelector plusSelectors: symbolCollection 	| returnedEnvironment testSel rule |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	SmalllintChecker 		runRule: (rule := ParseTreeLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!refactoryTestAppEnvironment	| classEnvironment |	classEnvironment := ClassEnvironment new.	classEnvironment addClass: RefactoryTestDataApp.	^classEnvironment! !!SmalllintTest methodsFor: 'tests'!testAsOrderedCollectionNotNeeded	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInBlock	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAtIfAbsent	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBadMessage	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBooleanPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectSelectNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionMessagesToExternalObject	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionProtocol	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testConsistencyCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testDetectContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEndTrueFalse	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualsTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEquivalentSuperclassMethods	| returnedEnvironment rule |	SmalllintChecker 		runRule: (rule := BlockLintRule equivalentSuperclassMethods)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #isLiteral.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testExtraBlock	self parseTreeRuleFor: self currentSelector plusSelectors: #(#testMethod1)! !!SmalllintTest methodsFor: 'tests'!testFileBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests' stamp: 'bh 4/8/2000 19:06'!testFullBlocks	"skip this test in squeak""	self blockRuleFor: self currentSelector		plusSelectors: #(#caller1 #fullBlocks #detectContains #fileBlocks #moveDefinition #caller #assignmentInBlock #equalNotUsed #stringConcatenation #noMoveDefinition #referencesConditionFor: #returnInEnsure)"! !!SmalllintTest methodsFor: 'tests'!testGuardingClause	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueReturns	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testJustSendsSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLiteralArrayCharacters	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLongMethods	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMinMax	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMissingYourself	self parseTreeRuleFor: self currentSelector plusSelectors: #(#inlineMethod)! !!SmalllintTest methodsFor: 'tests'!testModifiesCollection	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testRefersToClass	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnInEnsure	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsBooleanAndOther	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSearchingLiteral	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSendsDifferentSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSizeCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testStringConcatenation	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSuperSends	| rule returnedEnvironment |	SmalllintChecker runRule: (rule := BlockLintRule superSends)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #release.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testTempVarOverridesInstVar	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testTempsReadBeforeWritten	self blockRuleFor: self currentSelector		plusSelectors: #(#inlineTemporary #noMoveDefinition #tempsReadBeforeWritten #equalNotUsed #fileBlocks #referencesConditionFor:)! !!SmalllintTest methodsFor: 'tests'!testThreeElementPoint	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDo	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoCollect	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoWithIncrement	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testUsesAdd	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testWhileTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testYourselfNotUsed	self parseTreeRuleFor: self currentSelector! !!SplitClassRefactoring methodsFor: 'private-transforming' stamp: 'jws 10/23/2016 05:38'!abstractReferenceTo: each	| setterMethod replacer accessorRef getterMethod |	accessorRef := CreateAccessorsForVariableRefactoring variable: each class: newClass classVariable: false.	self performComponentRefactoring: accessorRef.	getterMethod := accessorRef getterMethod.	setterMethod := accessorRef setterMethod.	replacer := ParseTreeRewriter		variable: each		getter: getterMethod		setter: setterMethod		receiver: referenceVariableName.	self		convertClasses: class withAllSubclasses		select: [ :aClass | aClass whichSelectorsReferToInstanceVariable: each ]		using: replacer.	self performComponentRefactoring: (RemoveInstanceVariableRefactoring remove: each from: class)! !!SplitClassRefactoring methodsFor: 'private-transforming'!addClass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: newClassName				superclass: Object				subclasses: #()				category: class category).	newClass := self model classNamed: newClassName! !!SplitClassRefactoring methodsFor: 'private-transforming'!addInstanceVariables	instanceVariables do: 			[:each | 			self performComponentRefactoring: (AddInstanceVariableRefactoring 						model: self model						variable: each						class: newClass)]! !!SplitClassRefactoring methodsFor: 'transforming'!abstractVariableReferences	instanceVariables do: [:each | self abstractReferenceTo: each]! !!SplitClassRefactoring methodsFor: 'transforming'!createNewClass	self		addClass;		addInstanceVariables! !!SplitClassRefactoring methodsFor: 'transforming'!createReference	self performComponentRefactoring: (AddInstanceVariableRefactoring 				variable: referenceVariableName				class: class)! !!SplitClassRefactoring methodsFor: 'transforming'!transform	self		createNewClass;		createReference;		abstractVariableReferences! !!SplitClassRefactoring methodsFor: 'initialize-release'!class: aClass instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	class := self model classFor: aClass.	instanceVariables := instVars.	newClassName := className.	referenceVariableName := newVariable! !!SplitClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidClassName: newClassName) 		& (RBCondition isGlobal: newClassName in: self model) not 			& (RBCondition isValidInstanceVariableName: referenceVariableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: referenceVariableName) 					not 			& (RBCondition isGlobal: referenceVariableName in: self model) not 			& (RBCondition definesTemporaryVariable: referenceVariableName in: class) 					not! !!SplitClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' instanceVariables: '.	instanceVariables asArray storeOn: aStream.	aStream		nextPutAll: ' newClassName: #';		nextPutAll: newClassName;		nextPutAll: ' referenceVariableName: ''';		nextPutAll: referenceVariableName;		nextPutAll: ''')'! !!SplitClassRefactoring class methodsFor: 'instance creation'!class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!SplitClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		model: aRBSmalltalk;		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!StParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!actionForCurrentToken	| ids action |	ids := currentToken id.	1 to: ids size		do: 			[:i | 			action := self actionFor: (ids at: i).			(action bitAnd: self actionMask) = self errorAction ifFalse: [^action].			(ids at: i) = scanner negativeNumberId 				ifTrue: 					[currentToken := SmaCCToken 								value: '-'								start: currentToken startPosition								id: (Array with: scanner binarySymbolId).					scanner position: currentToken stopPosition - 1.					^self actionForCurrentToken]].	^self errorAction! !!StParser methodsFor: 'private' stamp: ' 6/1/07 21:19'!createMessageNodeFrom: aCollection 	^RBMessageNode 		receiver: aCollection first		selector: (aCollection at: 2) first contents asSymbol		arguments: (aCollection at: 2) last! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArray1: nodes	^ WriteStream on: Array new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArray2: nodes	^ (nodes at: 1)		nextPut: (nodes at: 2);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArray3: nodes	(nodes at: 2) stopPosition + 1 = (nodes at: 3) startPosition		ifTrue: [ (nodes at: 1) nextPut: ((nodes at: 2) value , ':') asSymbol ]		ifFalse: [ 			(nodes at: 1)				nextPut: (nodes at: 2) value asSymbol;				nextPut: #':' ].	scanner position: (nodes at: 3) startPosition.	currentToken := nil.	^ nodes at: 1! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral10: nodes	^ (nodes at: 1) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral11: nodes	^ (nodes at: 1) value! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral2: nodes	^ (nodes at: 1) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral3: nodes	^ (nodes at: 1) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral4: nodes	^ (nodes at: 1) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral5: nodes	^ (nodes at: 1) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral6: nodes	^ (nodes at: 2) value asQualifiedReference! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral7: nodes	^ (nodes at: 2) value asQualifiedReference! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral8: nodes	^ (nodes at: 2) contents! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForArrayLiteral9: nodes	^ (nodes at: 2) contents! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBinaryMessage1: nodes	^ Array with: (ReadStream on: (nodes at: 1) value) with: (Array with: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBinaryMethodName1: nodes	^ Array with: (nodes at: 1) value asSymbol with: (Array with: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlock1: nodes	^ RBBlockNode arguments: (nodes at: 2) body: (nodes at: 4)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlock2: nodes	^ RBBlockNode body: (nodes at: 2)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlock3: nodes	^ RBBlockNode arguments: (nodes at: 2) body: (RBSequenceNode statements: #())! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlock4: nodes	^ RBBlockNode arguments: (nodes at: 2) body: (RBSequenceNode temporaries: (nodes at: 4) statements: (nodes at: 6))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlockArgs1: nodes	^ OrderedCollection with: (nodes at: 2)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForBlockArgs2: nodes	^ (nodes at: 1)		add: (nodes at: 3);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForByteArray1: nodes	^ WriteStream on: ByteArray new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForByteArray2: nodes	^ (nodes at: 1)		nextPut: (nodes at: 2) value;		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForCascade1: nodes	| messages |	(nodes at: 2) isEmpty		ifTrue: [ ^ nodes at: 1 ].	messages := OrderedCollection new: (nodes at: 2) size + 1.	messages add: (nodes at: 1).	(nodes at: 2)		do: [ :each | 			messages				add: (RBMessageNode receiver: (nodes at: 1) receiver selector: each first contents asSymbol arguments: each last) ].	^ RBCascadeNode messages: messages! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForCascadeList1: nodes	^ OrderedCollection new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForCascadeList2: nodes	^ (nodes at: 1)		add: (nodes at: 3);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForExpression1: nodes	^ RBAssignmentNode variable: (nodes at: 1) value: (nodes at: 3)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForKeywordMessage1: nodes	| stream |	stream := WriteStream on: (String new: 30).	stream nextPutAll: (nodes at: 1) value.	^ Array with: stream with: (OrderedCollection with: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForKeywordMessage2: nodes	(nodes at: 1) first nextPutAll: (nodes at: 2) value.	(nodes at: 1) last add: (nodes at: 3).	^ nodes at: 1! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForKeywordMethodName1: nodes	| stream |	stream := WriteStream on: (String new: 30).	stream nextPutAll: (nodes at: 1) value.	^ Array with: stream with: (OrderedCollection with: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForKeywordMethodName2: nodes	(nodes at: 1) first nextPutAll: (nodes at: 2) value.	(nodes at: 1) last add: (nodes at: 3).	^ nodes at: 1! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral10: nodes	^ (nodes at: 2) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral11: nodes	^ (nodes at: 2) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral12: nodes	^ (nodes at: 2) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral13: nodes	^ (nodes at: 3) contents! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral14: nodes	^ (nodes at: 3) contents! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral15: nodes	^ (nodes at: 3) value asQualifiedReference! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral16: nodes	^ (nodes at: 3) value asQualifiedReference! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral1: nodes	^ true! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral2: nodes	^ false! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral3: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral4: nodes	^ (nodes at: 1) value! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral5: nodes	^ (nodes at: 1) value! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral6: nodes	^ (nodes at: 1) value at: 2! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral7: nodes	^ ((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size - 1) copyReplaceAll: '''''' with: ''''! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral8: nodes	^ (((nodes at: 2) value copyFrom: 2 to: (nodes at: 2) value size - 1) copyReplaceAll: '''''' with: '''') asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForLiteral9: nodes	^ (nodes at: 2) value asSymbol! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethod1: nodes	^ (RBMethodNode selector: (nodes at: 1) value asSymbol arguments: #() body: (nodes at: 2) last)		tags: (nodes at: 2) first;		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethod2: nodes	^ (RBMethodNode selector: (nodes at: 1) first arguments: (nodes at: 1) last body: (nodes at: 2) last)		tags: (nodes at: 2) first;		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethod3: nodes	^ (RBMethodNode selector: (nodes at: 1) first contents asSymbol arguments: (nodes at: 1) last body: (nodes at: 2) last)		tags: (nodes at: 2) first;		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethodSequenceNode1: nodes	^ Array		with:			((nodes at: 1)				addAll: (nodes at: 5);				yourself)		with: (RBSequenceNode temporaries: (nodes at: 3) statements: (nodes at: 6))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethodSequenceNode2: nodes	^ Array		with:			((nodes at: 1)				addAll: (nodes at: 3);				yourself)		with: (RBSequenceNode temporaries: #() statements: (nodes at: 4))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForMethodSequenceNode3: nodes	^ Array with: (nodes at: 1) with: (RBSequenceNode temporaries: #() statements: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForOptionalXXXXX1: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForOptionalXXXXX2: nodes	^ nodes at: 1! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimary2: nodes	^ RBLiteralNode value: (nodes at: 1)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend10: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend11: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend2: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend3: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend4: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend5: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend6: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend7: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend8: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitiveMessageSend9: nodes	^ nil! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitives1: nodes	^ OrderedCollection new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForPrimitives2: nodes	^ (nodes at: 1)		add: ((nodes at: 2) startPosition to: (nodes at: 4) startPosition);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForSequenceNode1: nodes	^ RBSequenceNode temporaries: (nodes at: 1) statements: (nodes at: 2)! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForStatementList2: nodes	^ (nodes at: 1)		add: (nodes at: 3);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForStatements1: nodes	^ OrderedCollection new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForStatements3: nodes	^ (nodes at: 1)		add: (RBReturnNode value: (nodes at: 4));		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForStatements4: nodes	^ OrderedCollection with: (RBReturnNode value: (nodes at: 2))! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForTemporaries1: nodes	^ #()! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForTemporaries2: nodes	^ #()! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForTemporaries3: nodes	^ nodes at: 2! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForTemporaryVariables1: nodes	^ OrderedCollection new! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForTemporaryVariables2: nodes	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForUnaryMessage1: nodes	^ Array with: (ReadStream on: (nodes at: 1) value) with: #()! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForVariable1: nodes	^ RBVariableNode named: (nodes at: 1) value! !!StParser methodsFor: 'generated-reduction actions' stamp: 'jws 10/23/2016 05:56'!reduceActionForVariable2: nodes	^ RBVariableNode named: (nodes at: 1) value! !!StParser methodsFor: 'generated-tables' stamp: 'jws 10/23/2016 05:56'!reduceTable	^#(#(33 0 #reduceFor:)#(33 2 #reduceActionForPrimitiveMessageSend2:)#(33 2 #reduceActionForPrimitiveMessageSend3:)#(33 2 #reduceActionForPrimitiveMessageSend4:)#(33 2 #reduceActionForPrimitiveMessageSend5:)#(33 2 #reduceActionForPrimitiveMessageSend6:)#(33 2 #reduceActionForPrimitiveMessageSend7:)#(33 2 #reduceActionForPrimitiveMessageSend8:)#(33 2 #reduceActionForPrimitiveMessageSend9:)#(33 2 #reduceActionForPrimitiveMessageSend10:)#(33 2 #reduceActionForPrimitiveMessageSend11:)#(34 2 #reduceActionForKeywordMethodName1:)#(34 3 #reduceActionForKeywordMethodName2:)#(35 0 #reduceActionForTemporaryVariables1:)#(35 2 #reduceActionForTemporaryVariables2:)#(36 0 #reduceActionForStatements1:)#(36 2 #reduceActionForStatements2:)#(36 5 #reduceActionForStatements3:)#(36 3 #reduceActionForStatements4:)#(37 0 #reduceActionForTemporaries1:)#(37 1 #reduceActionForTemporaries2:)#(37 3 #reduceActionForTemporaries3:)#(38 1 #reduceFor:)#(38 3 #reduceActionForStatementList2:)#(39 0 #reduceActionForOptionalXXXXX1:)#(39 1 #reduceActionForOptionalXXXXX2:)#(40 3 #reduceActionForExpression1:)#(40 1 #reduceActionForExpression2:)#(41 2 #reduceActionForBlockArgs1:)#(41 3 #reduceActionForBlockArgs2:)#(42 5 #reduceActionForBlock1:)#(42 3 #reduceActionForBlock2:)#(42 3 #reduceActionForBlock3:)#(42 7 #reduceActionForBlock4:)#(43 2 #reduceActionForCascade1:)#(43 1 #reduceActionForCascade2:)#(44 1 #reduceActionForMessageSend1:)#(44 1 #reduceActionForMessageSend2:)#(44 1 #reduceActionForMessageSend3:)#(45 0 #reduceActionForCascadeList1:)#(45 3 #reduceActionForCascadeList2:)#(46 0 #reduceActionForPrimitives1:)#(46 4 #reduceActionForPrimitives2:)#(47 2 #reduceActionForKeywordMessageSend1:)#(47 2 #reduceActionForKeywordMessageSend2:)#(47 2 #reduceActionForKeywordMessageSend3:)#(48 2 #reduceActionForBinaryMessageSend1:)#(48 2 #reduceActionForBinaryMessageSend2:)#(48 2 #reduceActionForBinaryMessageSend3:)#(49 2 #reduceActionForUnaryMessageSend1:)#(49 2 #reduceActionForUnaryMessageSend2:)#(50 1 #reduceActionForSimpleMessage1:)#(50 1 #reduceActionForSimpleMessage2:)#(50 1 #reduceActionForSimpleMessage3:)#(51 1 #reduceActionForUnaryMessage1:)#(52 2 #reduceActionForBinaryMessage1:)#(53 2 #reduceActionForKeywordMessage1:)#(53 3 #reduceActionForKeywordMessage2:)#(54 1 #reduceActionForKeywordArgument1:)#(54 1 #reduceActionForKeywordArgument2:)#(54 1 #reduceActionForKeywordArgument3:)#(55 1 #reduceActionForBinaryArgument1:)#(55 1 #reduceActionForBinaryArgument2:)#(56 2 #reduceActionForMethod1:)#(56 2 #reduceActionForMethod2:)#(56 2 #reduceActionForMethod3:)#(57 1 #reduceActionForVariable1:)#(57 1 #reduceActionForVariable2:)#(58 2 #reduceActionForBinaryMethodName1:)#(59 6 #reduceActionForMethodSequenceNode1:)#(59 4 #reduceActionForMethodSequenceNode2:)#(59 2 #reduceActionForMethodSequenceNode3:)#(60 0 #reduceActionForByteArray1:)#(60 2 #reduceActionForByteArray2:)#(61 0 #reduceActionForArray1:)#(61 2 #reduceActionForArray2:)#(61 3 #reduceActionForArray3:)#(62 1 #reduceActionForArrayLiteral1:)#(62 1 #reduceActionForArrayLiteral2:)#(62 1 #reduceActionForArrayLiteral3:)#(62 1 #reduceActionForArrayLiteral4:)#(62 1 #reduceActionForArrayLiteral5:)#(62 3 #reduceActionForArrayLiteral6:)#(62 3 #reduceActionForArrayLiteral7:)#(62 3 #reduceActionForArrayLiteral8:)#(62 3 #reduceActionForArrayLiteral9:)#(62 1 #reduceActionForArrayLiteral10:)#(62 1 #reduceActionForArrayLiteral11:)#(63 3 #reduceActionForPrimary1:)#(63 1 #reduceActionForPrimary2:)#(63 1 #reduceActionForPrimary3:)#(63 1 #reduceActionForPrimary4:)#(66 1 #reduceFor:)#(67 2 #reduceActionForSequenceNode1:)#(68 1 #reduceActionForLiteral1:)#(68 1 #reduceActionForLiteral2:)#(68 1 #reduceActionForLiteral3:)#(68 1 #reduceActionForLiteral4:)#(68 1 #reduceActionForLiteral5:)#(68 1 #reduceActionForLiteral6:)#(68 1 #reduceActionForLiteral7:)#(68 2 #reduceActionForLiteral8:)#(68 2 #reduceActionForLiteral9:)#(68 2 #reduceActionForLiteral10:)#(68 2 #reduceActionForLiteral11:)#(68 2 #reduceActionForLiteral12:)#(68 4 #reduceActionForLiteral13:)#(68 4 #reduceActionForLiteral14:)#(68 4 #reduceActionForLiteral15:)#(68 4 #reduceActionForLiteral16:))! !!StParser methodsFor: 'generated-tables' stamp: 'jws 10/23/2016 05:56'!transitionTable	^#(#(3 13 20 17 24 21 26 25 34 29 56 33 58)#(3 82 1 37 9 82 10 82 11 82 12 82 14 41 15 82 16 82 17 82 20 82 21 82 22 82 23 82 29 82 30 45 37 82 64 49 67)#(3 170 1 170 6 170 9 170 10 170 11 170 12 170 14 170 15 170 16 170 17 170 20 170 21 170 22 170 23 170 29 170 30 53 46 57 59 170 64)#(3 61 20 65 29 69 57)#(3 61 20 65 29 73 57)#(3 170 1 170 6 170 9 170 10 170 11 170 12 170 14 170 15 170 16 170 17 170 20 170 21 170 22 170 23 77 24 170 29 170 30 53 46 81 59 170 64)#(2 0 64)#(3 170 1 170 6 170 9 170 10 170 11 170 12 170 14 170 15 170 16 170 17 170 20 170 21 170 22 170 23 170 29 170 30 53 46 85 59 170 64)#(3 58 9 58 20 58 29 89 35)#(2 86 1 10 11 12 14 16 17 19 20 21 22 23 29 30 64)#(3 93 1 97 10 101 11 105 12 109 14 113 16 117 17 66 19 61 20 121 21 125 22 129 23 65 29 133 30 137 36 141 38 145 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 66 64 181 68)#(2 0 64)#(3 93 1 185 6 189 9 97 10 101 11 105 12 109 14 193 15 113 16 117 17 61 20 121 21 125 22 129 23 65 29 133 30 197 36 141 38 145 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 66 64 181 68)#(2 258 64)#(2 270 1 2 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 29 30 64)#(2 274 1 2 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 29 30 64)#(2 50 1 6 9 10 11 12 14 15 16 17 20 21 22 23 24 29 30 64)#(2 278 1 6 9 10 11 12 14 15 16 17 20 21 22 23 29 30 64)#(3 61 20 65 29 201 57)#(2 266 64)#(2 262 64)#(3 205 9 61 20 65 29 209 57)#(3 213 3 217 10 221 17 225 20 229 23 233 24 237 25 241 26)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 245 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 181 68)#(2 382 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 386 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 390 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 249 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 181 68)#(3 82 1 37 9 82 10 82 11 82 12 82 14 41 15 82 16 82 17 253 18 82 19 82 20 82 21 82 22 82 23 82 29 82 30 45 37 257 41 261 67)#(2 394 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 398 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 406 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 402 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 378 19 64)#(3 265 5 102 19 269 39 102 64)#(2 94 5 19 64)#(2 370 2 4 5 19 20 24 26 64)#(2 114 4 5 19 64)#(3 162 2 162 4 162 5 162 19 273 45 162 64)#(2 150 2 4 5 19 64)#(3 154 2 154 4 154 5 154 19 277 24 281 26 285 52 289 53 154 64)#(3 158 2 158 4 158 5 158 19 293 20 277 24 281 26 297 51 301 52 305 53 158 64)#(3 366 4 366 5 309 13 366 19 366 20 366 24 366 26 366 64)#(3 146 4 146 5 146 19 293 20 277 24 281 26 313 51 317 52 321 53 146 64)#(2 362 2 4 5 19 20 24 26 64)#(3 6 1 6 2 6 3 6 4 6 5 6 7 6 8 6 10 6 11 6 12 6 14 6 20 6 21 6 22 6 23 6 24 6 26 6 30 325 33)#(3 58 9 58 20 58 29 329 35)#(3 170 1 170 6 170 10 170 11 170 12 170 14 170 16 170 17 170 20 170 21 170 22 170 23 170 29 170 30 333 46 170 64)#(2 290 64)#(2 54 1 6 9 10 11 12 14 15 16 17 20 21 22 23 24 29 30 64)#(2 90 1 10 11 12 14 16 17 19 20 21 22 23 29 30 64)#(2 62 9 20 29)#(3 337 20 341 29)#(3 302 1 302 3 302 4 302 10 302 11 302 12 302 14 302 17 302 20 302 21 302 22 302 23 302 24 302 25 302 26 302 29 302 30 302 32 345 61)#(3 294 19 294 21 349 60)#(2 414 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 410 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 422 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 426 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 418 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 353 4)#(3 357 5 102 19 361 39 102 64)#(3 61 20 65 29 365 57)#(3 369 9 373 15 377 18 381 19)#(2 385 19)#(3 93 1 97 10 101 11 105 12 109 14 389 16 117 17 106 19 61 20 121 21 125 22 129 23 65 29 133 30 393 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 106 64 181 68)#(2 70 19 64)#(3 397 2 142 4 142 5 142 19 142 64)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 149 42 401 48 405 49 409 54 413 57 417 63 181 68)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 149 42 421 49 425 55 413 57 429 63 181 68)#(2 190 2 4 5 19 24 26 64)#(3 178 2 178 4 178 5 178 19 433 24 178 64)#(2 222 2 4 5 19 20 24 26 64)#(2 202 2 4 5 19 20 24 26 64)#(2 194 2 4 5 19 24 26 64)#(3 182 2 182 4 182 5 182 19 433 24 182 64)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 437 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 181 68)#(2 206 2 4 5 19 20 24 26 64)#(2 198 2 4 5 19 24 26 64)#(3 186 2 186 4 186 5 186 19 433 24 186 64)#(3 93 1 441 2 445 3 449 4 453 5 457 7 461 8 465 10 101 11 105 12 109 14 469 20 121 21 125 22 129 23 473 24 477 26 133 30 481 68)#(3 485 9 61 20 65 29 209 57)#(3 93 1 185 6 97 10 101 11 105 12 109 14 113 16 117 17 61 20 121 21 125 22 129 23 65 29 133 30 489 36 141 38 145 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 66 64 181 68)#(2 493 8)#(2 497 8)#(3 93 1 501 3 505 4 509 10 101 11 105 12 109 14 513 17 517 20 121 21 125 22 129 23 521 24 525 25 529 26 533 29 133 30 537 32 541 62 545 68)#(3 549 19 553 21)#(2 358 2 4 5 19 20 24 26 64)#(2 106 19 64)#(2 78 19 64)#(2 118 9 15 18 19)#(3 82 1 37 9 82 10 82 11 82 12 82 14 41 15 82 16 82 17 82 19 82 20 82 21 82 22 82 23 82 29 82 30 45 37 557 67)#(3 58 9 58 20 58 29 561 35)#(3 61 20 65 29 565 57)#(2 134 2 4 5 19 20 24 26 64)#(2 130 2 4 5 19 20 24 26 64)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 569 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 181 68)#(2 98 5 19 64)#(3 293 20 277 24 281 26 573 50 577 51 581 52 585 53)#(3 238 2 238 4 238 5 238 19 238 24 281 26 285 52 238 64)#(3 242 2 242 4 242 5 242 19 293 20 242 24 281 26 297 51 301 52 242 64)#(2 230 2 4 5 19 24 64)#(2 366 2 4 5 19 20 24 26 64)#(3 246 2 246 4 246 5 246 19 293 20 246 24 281 26 313 51 317 52 246 64)#(3 250 2 250 4 250 5 250 19 293 20 250 24 250 26 297 51 250 64)#(2 226 2 4 5 19 24 26 64)#(3 254 2 254 4 254 5 254 19 293 20 254 24 254 26 313 51 254 64)#(3 93 1 97 10 101 11 105 12 109 14 117 17 61 20 121 21 125 22 129 23 65 29 133 30 149 42 401 48 405 49 589 54 413 57 417 63 181 68)#(2 110 4 5 19 64)#(2 34 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 26 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 22 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 38 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 174 1 6 9 10 11 12 14 15 16 17 20 21 22 23 29 30 64)#(2 30 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 18 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 42 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 10 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 46 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(2 14 1 2 3 4 5 7 8 10 11 12 14 20 21 22 23 24 26 30)#(3 170 1 170 6 170 10 170 11 170 12 170 14 170 16 170 17 170 20 170 21 170 22 170 23 170 29 170 30 593 46 170 64)#(2 286 64)#(2 438 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 442 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(3 597 20 601 29)#(2 434 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(3 302 1 302 3 302 4 302 10 302 11 302 12 302 14 302 17 302 20 302 21 302 22 302 23 302 24 302 25 302 26 302 29 302 30 302 32 605 61)#(3 294 19 294 21 609 60)#(3 318 1 318 3 318 4 318 10 318 11 318 12 613 13 318 14 318 17 318 20 318 21 318 22 318 23 318 24 318 25 318 26 318 29 318 30 318 32)#(2 326 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 330 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 322 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 354 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 350 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 306 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 314 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 430 1 2 3 4 5 7 8 10 11 12 14 17 19 20 21 22 23 24 25 26 29 30 32 64)#(2 298 19 21)#(2 617 19)#(3 621 9 61 20 65 29 209 57)#(2 122 9 15 18 19)#(3 357 5 102 19 625 39 102 64)#(2 166 2 4 5 19 64)#(2 210 2 4 5 19 64)#(2 214 2 4 5 19 64)#(3 218 2 218 4 218 5 218 19 433 24 218 64)#(2 234 2 4 5 19 24 64)#(3 93 1 185 6 97 10 101 11 105 12 109 14 113 16 117 17 61 20 121 21 125 22 129 23 65 29 133 30 629 36 141 38 145 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 66 64 181 68)#(2 633 8)#(2 637 8)#(3 93 1 501 3 641 4 509 10 101 11 105 12 109 14 513 17 517 20 121 21 125 22 129 23 521 24 525 25 529 26 533 29 133 30 537 32 541 62 545 68)#(3 645 19 553 21)#(2 310 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 126 2 4 5 19 20 24 26 64)#(3 93 1 97 10 101 11 105 12 109 14 113 16 117 17 66 19 61 20 121 21 125 22 129 23 65 29 133 30 649 36 141 38 145 40 149 42 153 43 157 44 161 47 165 48 169 49 173 57 177 63 181 68)#(2 74 19 64)#(2 282 64)#(2 334 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 338 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 342 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 346 1 3 4 10 11 12 14 17 20 21 22 23 24 25 26 29 30 32)#(2 653 19)#(2 138 2 4 5 19 20 24 26 64))! !!StParser class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!parseExpression: aString 	^self simplifyExpression: (self parse: aString				startingAt: self startingStateForSequenceNode)! !!StParser class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!parseExpression: aString onError: aBlock 	^self simplifyExpression: (self 				parse: aString				startingAt: self startingStateForSequenceNode				onError: aBlock)! !!StParser class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!parseMethod: aString 	^self parse: aString startingAt: self startingStateForMethod! !!StParser class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!parseMethod: aString onError: aBlock 	^self 		parse: aString		startingAt: self startingStateForMethod		onError: aBlock! !!StParser class methodsFor: 'generated-comments' stamp: 'jws 10/23/2016 05:56'!parserDefinitionComment	"%id <number> <negativeNumber> <name> <binarySymbol>;%start SequenceNode ;Method:	  <name> MethodSequenceNode {(RBMethodNode selector: '1' value asSymbol arguments: #() body: '2' last) tags: '2' first; yourself}	| BinaryMethodName MethodSequenceNode {(RBMethodNode selector: '1' first arguments: '1' last body: '2' last) tags: '2' first; yourself}	| KeywordMethodName MethodSequenceNode {(RBMethodNode selector: '1' first contents asSymbol arguments: '1' last body: '2' last) tags: '2' first; yourself};BinaryMethodName:	<binarySymbol> Variable {Array with: '1' value asSymbol with: (Array with: '2')} ;KeywordMethodName:	<keyword> Variable {| stream | stream := WriteStream on: (String new: 30). stream nextPutAll: '1' value. Array with: stream with: (OrderedCollection with: '2')}	| KeywordMethodName <keyword> Variable {'1' first nextPutAll: '2' value. '1' last add: '3'. '1'};Primitives:	{OrderedCollection new}	| Primitives ""<"" PrimitiveMessageSend "">"" {'1' add: ('2' startPosition to: '4' startPosition); yourself};PrimitiveMessageSend:	| PrimitiveMessageSend <keyword> {nil}	| PrimitiveMessageSend Literal {nil}	| PrimitiveMessageSend ""("" {nil}	| PrimitiveMessageSend "")"" {nil}	| PrimitiveMessageSend ""{"" {nil}	| PrimitiveMessageSend ""}"" {nil}	| PrimitiveMessageSend "";"" {nil}	| PrimitiveMessageSend ""."" {nil}	| PrimitiveMessageSend <name> {nil}	| PrimitiveMessageSend <binarySymbol> {nil};MethodSequenceNode:	Primitives ""|"" TemporaryVariables ""|"" Primitives Statements {Array with: ('1' addAll: '5'; yourself) with: (RBSequenceNode temporaries: '3' statements: '6')}	| Primitives ""||"" Primitives Statements {Array with: ('1' addAll: '3'; yourself) with: (RBSequenceNode temporaries: #() statements: '4')}	| Primitives Statements {Array with: '1' with: (RBSequenceNode temporaries: #() statements: '2')};SequenceNode:	Temporaries Statements {RBSequenceNode temporaries: '1' statements: '2'};Temporaries:	{#()}	| ""||"" {#()}	| ""|"" TemporaryVariables ""|"" {'2'};TemporaryVariables:	{OrderedCollection new}	| TemporaryVariables Variable {'1' add: '2'; yourself};Statements:	{OrderedCollection new}	| StatementList "".""? {#liftFirstValue:}	| StatementList ""."" ""^"" Expression "".""? {'1' add: (RBReturnNode value: '4'); yourself}	| ""^"" Expression "".""? {OrderedCollection with: (RBReturnNode value: '2')};StatementList:	Expression	| StatementList ""."" Expression {'1' add: '3'; yourself};Block:	""["" BlockArgs ""|"" SequenceNode ""]"" {RBBlockNode arguments: '2' body: '4'}	| ""["" SequenceNode ""]"" {RBBlockNode body: '2'}	| ""["" BlockArgs ""]"" {RBBlockNode arguments: '2' body: (RBSequenceNode statements: #())}	| ""["" BlockArgs ""||"" TemporaryVariables ""|"" Statements ""]"" {RBBlockNode arguments: '2' body: (RBSequenceNode temporaries: '4' statements: '6')};BlockArgs:	"":"" Variable {OrderedCollection with: '2'}	| BlockArgs "":"" Variable {'1' add: '3'; yourself};Expression:	Variable "":="" Expression {RBAssignmentNode variable: '1' value: '3'}|	Cascade {#liftFirstValue:};Cascade:	MessageSend CascadeList 				{| messages |				'2' isEmpty ifTrue: [^'1'].				messages := OrderedCollection new: '2' size + 1.				messages add: '1'.				'2' do: [:each | messages add: (RBMessageNode receiver: '1' receiver selector: each first contents asSymbol arguments: each last)].				RBCascadeNode messages: messages}|	Primary {#liftFirstValue:};MessageSend:	KeywordMessageSend {#liftFirstValue:}|	BinaryMessageSend {#liftFirstValue:}|	UnaryMessageSend {#liftFirstValue:};CascadeList:	{OrderedCollection new}|	CascadeList "";"" SimpleMessage {'1' add: '3'; yourself};SimpleMessage:	UnaryMessage {#liftFirstValue:}|	BinaryMessage {#liftFirstValue:}|	KeywordMessage {#liftFirstValue:};KeywordMessageSend:	BinaryMessageSend KeywordMessage {#createMessageNodeFrom:}|	UnaryMessageSend KeywordMessage {#createMessageNodeFrom:}|	Primary KeywordMessage {#createMessageNodeFrom:};KeywordMessage:	<keyword> KeywordArgument {| stream | stream := WriteStream on: (String new: 30). stream nextPutAll: '1' value. Array with: stream with: (OrderedCollection with: '2')}|	KeywordMessage <keyword> KeywordArgument {'1' first nextPutAll: '2' value. '1' last add: '3'. '1'};KeywordArgument:	BinaryMessageSend {#liftFirstValue:}|	UnaryMessageSend {#liftFirstValue:}|	Primary {#liftFirstValue:};BinaryMessageSend:	BinaryMessageSend BinaryMessage {#createMessageNodeFrom:}|	UnaryMessageSend BinaryMessage {#createMessageNodeFrom:}|	Primary BinaryMessage {#createMessageNodeFrom:} ;BinaryMessage :	<binarySymbol> BinaryArgument {Array with: (ReadStream on: '1' value) with: (Array with: '2')};BinaryArgument:	UnaryMessageSend {#liftFirstValue:}|	Primary {#liftFirstValue:};UnaryMessageSend :	UnaryMessageSend UnaryMessage {#createMessageNodeFrom:}|	Primary UnaryMessage {#createMessageNodeFrom:};UnaryMessage :	<name> {Array with: (ReadStream on: '1' value) with: #()};Primary: 	""("" Expression "")"" {#liftSecondValue:}|	Literal {RBLiteralNode value: '1'}|	Variable {#liftFirstValue:}|	Block {#liftFirstValue:};Variable: 	<name> {RBVariableNode named: '1' value}|	<dottedName> {RBVariableNode named: '1' value};Literal:	""true"" {true}|	""false"" {false}|	""nil"" {nil}|	<number> {'1' value}|	<negativeNumber> {'1' value}|	<character> {'1' value at: 2}|	<string> {('1' value copyFrom: 2 to: '1' value size - 1) copyReplaceAll: '''''' with: ''''}|	 ""#"" <string> {(('2' value copyFrom: 2 to: '2' value size - 1) copyReplaceAll: '''''' with: '''') asSymbol}|	""#"" <name> {'2' value asSymbol}|	""#"" <binarySymbol> {'2' value asSymbol}|	""#"" <keyword> {'2' value asSymbol}|	""#"" <multikeyword> {'2' value asSymbol}|	""#"" ""["" ByteArray ""]"" {'3' contents}|	""#"" ""("" Array "")"" {'3' contents}|	""#"" ""{"" <name> ""}"" {'3' value asQualifiedReference}|	""#"" ""{"" <dottedName> ""}"" {'3' value asQualifiedReference};ByteArray: 	{WriteStream on: ByteArray new}|	ByteArray <number> {'1' nextPut: '2' value; yourself};Array: 	{WriteStream on: Array new}|	Array ArrayLiteral {'1' nextPut: '2'; yourself} |	Array <name> "":="" {'2' stopPosition + 1 = '3' startPosition ifTrue: ['1' nextPut: ('2' value, ':') asSymbol] ifFalse: ['1' nextPut: '2' value asSymbol; nextPut: #':']. scanner position: '3' startPosition. currentToken := nil. '1'};ArrayLiteral:	Literal {#liftFirstValue:}|	<name> {'1' value asSymbol}|	<binarySymbol> {'1' value asSymbol}|	<keyword> {'1' value asSymbol}|	<multikeyword> {'1' value asSymbol}|	""{"" <name> ""}"" {'2' value asQualifiedReference}|	""{"" <dottedName> ""}"" {'2' value asQualifiedReference}|	""("" Array "")"" {'2' contents}|	""["" ByteArray ""]"" {'2' contents}|	<anyChar> {'1' value asSymbol}|	<dottedName> {'1' value};"! !!StParser class methodsFor: 'generated-accessing' stamp: 'jws 10/23/2016 05:56'!scannerClass	^StScanner! !!StParser class methodsFor: 'private' stamp: ' 6/1/07 21:19'!simplifyExpression: aSequenceNode 	^(aSequenceNode statements size == 1 		and: [aSequenceNode temporaries isEmpty]) 			ifTrue: [aSequenceNode statements first]			ifFalse: [aSequenceNode]! !!StParser class methodsFor: 'generated-starting states' stamp: 'jws 10/23/2016 05:56'!startingStateForMethod	^1! !!StParser class methodsFor: 'generated-starting states' stamp: 'jws 10/23/2016 05:56'!startingStateForSequenceNode	^2! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:55'!binarySymbolId	^26! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:56'!emptySymbolTokenId	^64! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:56'!errorTokenId	^65! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:55'!nameId	^20! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:55'!negativeNumberId	^22! !!StScanner methodsFor: 'generated-tokens' stamp: 'jws 10/23/2016 05:55'!numberId	^21! !!StScanner methodsFor: 'scanning' stamp: 'lr 6/28/2007 12:06'!negativeNumber	stream skip: -2.	^self scanNumber: self negativeNumberId! !!StScanner methodsFor: 'scanning' stamp: 'lr 6/28/2007 12:06'!number	stream skip: -1.	^self scanNumber: self numberId! !!StScanner methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!scanNumber: id 	| number |	number := Number readFrom: stream.	outputStream reset.	matchActions := Array with: id.	^self createTokenFor: number! !!StScanner methodsFor: 'scanning' stamp: ' 6/1/07 21:19'!variableAssignment	| token |	outputStream skip: -2.	stream skip: -2.	matchActions := Array with: self nameId.	token := self createTokenFor: outputStream contents.	outputStream reset.	^token! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scan1	[ 	self step.	currentCharacter ~= $' ] whileTrue.	currentCharacter = $'		ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scan2	self recordMatch: #(23).	self step.	currentCharacter = $'		ifTrue: [ ^ self scan1 ].	^ self reportLastMatch! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scan3	self recordMatch: #(24).	self step.	((currentCharacter between: $A and: $Z)		or: [ 			currentCharacter = $_				or: [ 					(currentCharacter between: $a and: $z)						or: [ 							currentCharacter = $ª								or: [ 									currentCharacter = $µ										or: [ 											currentCharacter = $º												or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ])		ifTrue: [ ^ self scan4 ].	currentCharacter = $=		ifTrue: [ ^ self recordAndReportMatch: #variableAssignment ].	^ self reportLastMatch! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scan4	[ 	self step.	(currentCharacter between: $0 and: $9)		or: [ 			(currentCharacter between: $A and: $Z)				or: [ 					currentCharacter = $_						or: [ 							(currentCharacter between: $a and: $z)								or: [ 									currentCharacter = $ª										or: [ 											currentCharacter = $µ												or: [ 													currentCharacter = $º														or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ] ] ]		whileTrue.	currentCharacter = $:		ifTrue: [ 			self recordMatch: #(25).			self step.			((currentCharacter between: $A and: $Z)				or: [ 					currentCharacter = $_						or: [ 							(currentCharacter between: $a and: $z)								or: [ 									currentCharacter = $ª										or: [ 											currentCharacter = $µ												or: [ 													currentCharacter = $º														or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ])				ifTrue: [ ^ self scan4 ].			^ self reportLastMatch ].	^ self reportLastMatch! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scan5	self step.	((currentCharacter between: $A and: $Z)		or: [ 			currentCharacter = $_				or: [ 					(currentCharacter between: $a and: $z)						or: [ 							currentCharacter = $ª								or: [ 									currentCharacter = $µ										or: [ 											currentCharacter = $º												or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ])		ifTrue: [ 			[ 			self recordMatch: #(29).			self step.			(currentCharacter between: $0 and: $9)				or: [ 					(currentCharacter between: $A and: $Z)						or: [ 							currentCharacter = $_								or: [ 									(currentCharacter between: $a and: $z)										or: [ 											currentCharacter = $ª												or: [ 													currentCharacter = $µ														or: [ 															currentCharacter = $º																or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ] ] ]				whileTrue.			currentCharacter = $.				ifTrue: [ ^ self scan5 ].			^ self reportLastMatch ].	^ self reportLastMatch! !!StScanner methodsFor: 'generated-scanner' stamp: 'jws 10/23/2016 05:56'!scanForToken	self step.	((currentCharacter between: $A and: $Z)		or: [ 			currentCharacter = $_				or: [ 					(currentCharacter between: $a and: $z)						or: [ 							currentCharacter = $ª								or: [ 									currentCharacter = $µ										or: [ 											currentCharacter = $º												or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ])		ifTrue: [ 			self recordMatch: #(20 32).			self step.			((currentCharacter between: $0 and: $9)				or: [ 					(currentCharacter between: $A and: $Z)						or: [ 							currentCharacter = $_								or: [ 									(currentCharacter between: $a and: $z)										or: [ 											currentCharacter = $ª												or: [ 													currentCharacter = $µ														or: [ 															currentCharacter = $º																or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ] ])				ifTrue: [ 					[ 					self recordMatch: #(20).					self step.					(currentCharacter between: $0 and: $9)						or: [ 							(currentCharacter between: $A and: $Z)								or: [ 									currentCharacter = $_										or: [ 											(currentCharacter between: $a and: $z)												or: [ 													currentCharacter = $ª														or: [ 															currentCharacter = $µ																or: [ 																	currentCharacter = $º																		or: [ (currentCharacter between: $À and: $Ö) or: [ (currentCharacter between: $Ø and: $ö) or: [ currentCharacter >= $ø ] ] ] ] ] ] ] ] ] ]						whileTrue.					currentCharacter = $:						ifTrue: [ ^ self scan3 ].					currentCharacter = $.						ifTrue: [ ^ self scan5 ].					^ self reportLastMatch ].			currentCharacter = $:				ifTrue: [ ^ self scan3 ].			currentCharacter = $.				ifTrue: [ ^ self scan5 ].			^ self reportLastMatch ].	((currentCharacter between: Character tab and: Character lf)		or: [ (currentCharacter between: Character newPage and: Character cr) or: [ currentCharacter = Character space ] ])		ifTrue: [ 			self recordMatch: #whitespace.			self step.			((currentCharacter between: Character tab and: Character lf)				or: [ (currentCharacter between: Character newPage and: Character cr) or: [ currentCharacter = Character space ] ])				ifTrue: [ 					[ 					self recordMatch: #whitespace.					self step.					(currentCharacter between: Character tab and: Character lf)						or: [ (currentCharacter between: Character newPage and: Character cr) or: [ currentCharacter = Character space ] ] ]						whileTrue.					^ self reportLastMatch ].			^ self reportLastMatch ].	(currentCharacter between: $0 and: $9)		ifTrue: [ ^ self recordAndReportMatch: #number ].	currentCharacter = $:		ifTrue: [ 			self recordMatch: #(18 32).			self step.			currentCharacter = $=				ifTrue: [ ^ self recordAndReportMatch: #(13) ].			^ self reportLastMatch ].	currentCharacter = $.		ifTrue: [ ^ self recordAndReportMatch: #(5 32) ].	(currentCharacter = $!!		or: [ 			(currentCharacter between: $% and: $&)				or: [ 					(currentCharacter between: $* and: $,)						or: [ 							currentCharacter = $/								or: [ 									currentCharacter = $=										or: [ (currentCharacter between: $? and: $@) or: [ currentCharacter = $\ or: [ currentCharacter = $~ ] ] ] ] ] ] ])		ifTrue: [ 			self recordMatch: #(26 32).			self step.			(currentCharacter = $!!				or: [ 					(currentCharacter between: $% and: $&)						or: [ 							(currentCharacter between: $* and: $,)								or: [ 									currentCharacter = $/										or: [ 											(currentCharacter between: $< and: $@)												or: [ currentCharacter = $\ or: [ currentCharacter = $| or: [ currentCharacter = $~ ] ] ] ] ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(26) ].			^ self reportLastMatch ].	currentCharacter = $#		ifTrue: [ ^ self recordAndReportMatch: #(1 32) ].	currentCharacter = $]		ifTrue: [ ^ self recordAndReportMatch: #(19 32) ].	currentCharacter = $[		ifTrue: [ ^ self recordAndReportMatch: #(17 32) ].	currentCharacter = $(		ifTrue: [ ^ self recordAndReportMatch: #(10 32) ].	currentCharacter = $)		ifTrue: [ ^ self recordAndReportMatch: #(4 32) ].	currentCharacter = $"		ifTrue: [ 			self recordMatch: #(32).			self step.			currentCharacter ~= $"				ifTrue: [ 					[ 					self step.					currentCharacter ~= $" ] whileTrue.					currentCharacter = $"						ifTrue: [ ^ self recordAndReportMatch: #comment ].					^ self reportLastMatch ].			currentCharacter = $"				ifTrue: [ ^ self recordAndReportMatch: #comment ].			^ self reportLastMatch ].	currentCharacter = $'		ifTrue: [ 			self recordMatch: #(32).			self step.			currentCharacter ~= $'				ifTrue: [ ^ self scan1 ].			currentCharacter = $'				ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	currentCharacter = $^		ifTrue: [ ^ self recordAndReportMatch: #(16 32) ].	currentCharacter = $|		ifTrue: [ 			self recordMatch: #(9 26 32).			self step.			(currentCharacter = $!!				or: [ 					(currentCharacter between: $% and: $&)						or: [ 							(currentCharacter between: $* and: $,)								or: [ 									currentCharacter = $/										or: [ 											(currentCharacter between: $< and: $@)												or: [ currentCharacter = $\ or: [ currentCharacter = $| or: [ currentCharacter = $~ ] ] ] ] ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(26) ].			^ self reportLastMatch ].	currentCharacter = $;		ifTrue: [ ^ self recordAndReportMatch: #(2 32) ].	currentCharacter = $-		ifTrue: [ 			self recordMatch: #(26 32).			self step.			(currentCharacter between: $0 and: $9)				ifTrue: [ ^ self recordAndReportMatch: #negativeNumber ].			(currentCharacter = $!!				or: [ 					(currentCharacter between: $% and: $&)						or: [ 							(currentCharacter between: $* and: $,)								or: [ 									currentCharacter = $/										or: [ 											(currentCharacter between: $< and: $@)												or: [ currentCharacter = $\ or: [ currentCharacter = $| or: [ currentCharacter = $~ ] ] ] ] ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(26) ].			^ self reportLastMatch ].	currentCharacter = $>		ifTrue: [ 			self recordMatch: #(7 26 32).			self step.			(currentCharacter = $!!				or: [ 					(currentCharacter between: $% and: $&)						or: [ 							(currentCharacter between: $* and: $,)								or: [ 									currentCharacter = $/										or: [ 											(currentCharacter between: $< and: $@)												or: [ currentCharacter = $\ or: [ currentCharacter = $| or: [ currentCharacter = $~ ] ] ] ] ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(26) ].			^ self reportLastMatch ].	currentCharacter = $<		ifTrue: [ 			self recordMatch: #(6 26 32).			self step.			(currentCharacter = $!!				or: [ 					(currentCharacter between: $% and: $&)						or: [ 							(currentCharacter between: $* and: $,)								or: [ 									currentCharacter = $/										or: [ 											(currentCharacter between: $< and: $@)												or: [ currentCharacter = $\ or: [ currentCharacter = $| or: [ currentCharacter = $~ ] ] ] ] ] ] ])				ifTrue: [ ^ self recordAndReportMatch: #(26) ].			^ self reportLastMatch ].	currentCharacter = $}		ifTrue: [ ^ self recordAndReportMatch: #(8 32) ].	currentCharacter = ${		ifTrue: [ ^ self recordAndReportMatch: #(3 32) ].	(currentCharacter <= Character backspace		or: [ 			currentCharacter = (Character value: 11)				or: [ 					(currentCharacter between: (Character value: 14) and: (Character value: 31))						or: [ 							currentCharacter = $`								or: [ 									(currentCharacter between: Character delete and: $©)										or: [ 											(currentCharacter between: $« and: $´)												or: [ 													(currentCharacter between: $¶ and: $¹)														or: [ (currentCharacter between: $» and: $¿) or: [ currentCharacter = $× or: [ currentCharacter = $÷ ] ] ] ] ] ] ] ] ])		ifTrue: [ ^ self recordAndReportMatch: #(32) ].	currentCharacter = $$		ifTrue: [ 			self recordMatch: #(32).			self step.			currentCharacter <= $ÿ				ifTrue: [ ^ self recordAndReportMatch: #(30) ].			^ self reportLastMatch ].	^ self reportLastMatch! !!StScanner class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!frequencyTable	^#(0.0 1.31372e-7 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0481767 0.0 0.0 0.0 0.0252514 0.0 0.0 2.62743e-7 1.31372e-7 5.25487e-7 1.31372e-7 1.31372e-7 0.0 1.31372e-7 0.0 2.62743e-7 0.0 1.31372e-7 7.8823e-7 2.62743e-7 2.62743e-7 1.31372e-7 5.25487e-7 0.106011 5.13007e-5 0.004554 0.00655584 2.41133e-4 3.60615e-5 1.93248e-4 0.00410241 0.00463893 0.0046369 2.82712e-4 4.64268e-4 0.0011675 9.75895e-4 0.00982753 2.26945e-4 0.00795055 0.00590903 0.0036363 0.00220212 0.00180485 0.00224265 0.00183191 0.00138545 0.00146217 0.00115246 0.0248349 0.00129723 7.50395e-4 0.00496762 8.97532e-4 1.44378e-4 0.00164497 0.00403659 0.00332443 0.00587547 0.00266882 0.00223293 0.00382922 9.91266e-4 9.99673e-4 0.00418163 3.27773e-5 6.31044e-4 0.00271013 0.00248917 0.00292348 0.00278226 0.00359742 7.08751e-4 0.00239287 0.00749351 0.00486778 0.00145908 0.00167453 0.00112251 2.2458e-4 2.32856e-4 4.40752e-5 0.00467815 1.22701e-4 0.00470173 0.00298378 7.73451e-4 2.634e-4 0.0515694 0.00918972 0.0257636 0.0226939 0.09244 0.0167193 0.0108988 0.0138365 0.042864 9.52379e-4 0.00366494 0.0402202 0.0159142 0.0440905 0.0418992 0.0154463 5.66869e-4 0.043972 0.0443068 0.0543899 0.0180997 0.00593537 0.00725816 0.00494884 0.00808567 0.00128285 7.45009e-4 0.00281083 7.45206e-4 1.08907e-4 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 6.56859e-8 3.28429e-7 0.0 0.0 1.97058e-7 0.0 0.0 0.0 0.0 3.94115e-7 6.56859e-8 0.0 2.62743e-7 1.31372e-7 0.0 1.31372e-7 1.31372e-7 0.0 0.0 1.97058e-7 1.31372e-7 6.56859e-8 1.31372e-7 0.0 0.0 7.8823e-7 0.0 0.0 1.31372e-7 1.31372e-7 4.59801e-7 7.8823e-7 0.0 9.85288e-7 5.25487e-7 1.31372e-7 6.56859e-8 1.05097e-6 0.0 2.62743e-7 0.0 1.97058e-7 4.59801e-7 1.97058e-7 5.25487e-7 2.62743e-7 0.0 1.51078e-6 5.91173e-7 1.11666e-6 0.0 1.97058e-7 8.53916e-7 1.57646e-6 0.0 0.0 0.0 0.0 0.0 0.0 0.0 6.56859e-8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 5.25487e-7 0.0 0.0 0.0 0.0 0.0 0.0 7.8823e-7 0.0 2.62743e-7 0.0 0.0 3.28429e-7 1.31372e-7 0.0 2.62743e-7 0.0 3.28429e-7 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.62743e-7 0.0 5.25487e-7 0.0 0.0 1.31372e-7 0.0 0.0 0.0 0.0)! !!StScanner class methodsFor: 'generated-initialization' stamp: 'jws 10/23/2016 05:55'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(20 'false' 12) #(20 'nil' 14) #(20 'true' 11) #(26 '||' 15))		do: [ :each | (keywordMap at: each first ifAbsentPut: [ Dictionary new ]) at: (each at: 2) put: each last ].	^ keywordMap! !!StScanner class methodsFor: 'generated-comments' stamp: 'jws 10/23/2016 05:56'!scannerDefinitionComment	"<name>	:	(<isLetter> | \_) (<isLetter> | [\d\_]) *;<number>:	\d	;<negativeNumber>	:	\- <number>	;<string>	:	\'  [^\']* \' (\' [^\']* \')*	;<keyword>	:	<name> \:	;<multikeyword>	:	<name> \: (<name> \: )+	;<binarySymbol>	:	[\~\-\!!\@\%\&\*\+\=\\\|\?\/\>\<\,] [\~\!!\@\%\&\*\+\=\\\|\?\/\>\<\,]?	;<whitespace>	:	<isSeparator>+	;<comment>	:	\"" [^\""]* \""	;<dottedName>	:	<name> (\. <name>)+	;<character>	:	\$ .	;<variableAssignment> : <name> \: \=	;<anyChar> : . ; # For VW literal arrays that handle #(;) -> #(#';')"! !!String methodsFor: 'testing' stamp: 'jws 10/23/2016 05:37'!isPatternVariable	 ^self keywords anySatisfy: [:each | each first = $`]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findNode	| tree node interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^nil].	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findNodeUnderCaret	| tree node interval |	interval := self selectedInterval.	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findSelectionNode	| node |	node := self findNode.	^ node ifNil: [RBProgramNode new] ifNotNil: [node]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!parseSelection	^RBParser parseExpression: self selectedText onError: [:str :pos | ^nil]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/13/2004 21:51'!parseTree	^ RBParser parseMethod: self text				onError: [:str :err | ^ RBParser parseExpression: self selectedText onError: [:strr :pos | ^ nil]]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self codeTextMorph text asString copyFrom: interval first		to: interval last! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!text	^self contents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:40'!abstractClassVar	| name |	name := self selectClassVar.	name isEmpty ifTrue: [^self].	self abstractClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:52'!abstractClassVar: aString 	self performRefactoring: (AbstractClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:39'!abstractInstVar	| name |	name := self selectInstVar.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!abstractInstVar: aString 	self 		performRefactoring: (AbstractInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:00'!abstractSelectedInstVar	| name |	name := self selectedVariableName.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:17'!addClassVar	self changeRequest ifFalse: [^self].	self addClassVarIn: self nonMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:19'!addClassVarIn: aClass 	| newName |	newName := self requestClassVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddClassVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!addInstVar	self changeRequest ifFalse: [^self].	self addInstVarIn: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:21'!addInstVarIn: aClass 	| newName |	newName := self requestInstVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddInstanceVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!bindTight	self performRefactoring: (MoveVariableDefinitionRefactoring 				bindTight: (self convertToSourceInterval: self selectedInterval)				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:28'!changeClassCategory	| state |	self changeRequest ifFalse: [^self].	state := self getState.	self changeClassCategoryFor: self nonMetaClasses.	self setState: state updateClasses: true.	self changed: #category with: self category! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:33'!changeClassCategoryFor: classCollection 	self needsWork.	self error:'not yet implemented.'.	"| dialog newCategory oldCategory changeClasses |	classCollection isEmpty ifTrue: [^self].	oldCategory := self environment whichCategoryIncludes: classCollection first name.	dialog := CategoryDialog new.	dialog organizer: Smalltalk organization.	dialog currentCategory: oldCategory.	dialog open ifFalse: [^self].	newCategory := dialog categoryName asSymbol.	changeClasses := classCollection				select: [:each | (self environment whichCategoryIncludes: each name) ~= newCategory].	changeClasses isEmpty ifTrue: [^self].	changeClasses do: 			[:each | 			Smalltalk organization classify: each name under: newCategory.			ChangeSet current changeClass: each]"! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 11:21'!convertToSibling	| name subclasses |self needsWork.  "Still not right."	name := self request: 'Enter name for new parent class'.	name isEmpty ifTrue: [^self].	subclasses := self selectSubclassesOf: self nonMetaClass.	subclasses isNil ifTrue: [^self].	self handleError: 			[(ChildrenToSiblingsRefactoring name: name				class: self nonMetaClass				subclasses: subclasses) execute.			self selectClasses: (Array with: name asSymbol)				meta: self isMeta				categories: self categories]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:50'!createAccessorsForClassVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString)				classVariable: true)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createAccessorsForInstVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString)				classVariable: false)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 3/4/2005 13:27'!createClassVarAccessors	| name |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createInstVar	self performRefactoring: (TemporaryToInstanceVariableRefactoring 				class: self selectedClassOrMetaClass				selector: self selector				variable: self selectedText)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createInstVarAccessors	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:57'!createSelectedClassVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createSelectedInstVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'jws 10/28/2016 14:05'!extractMethod	| currentSelector |	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	currentSelector := self selectedMessageName.	self performRefactoring: (ExtractMethodRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	self messageListIndex: (self messageList indexOf: currentSelector).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'jws 10/28/2016 14:05'!extractMethodToComponent	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self performRefactoring: (ExtractMethodToComponentRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 02:18'!extractToTemp	| newName node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isValue not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter name for Temporary:'.	newName isEmpty ifTrue: [^self].	self performRefactoring: (ExtractToTemporaryRefactoring 				extract: (self convertToSourceInterval: node sourceInterval)				to: newName				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:42'!findNode	| tree node interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^nil].	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 19:57'!handleError: aBlock 	^[Cursor execute showWhile: aBlock] on: Refactoring preconditionSignal		do: 			[:ex | 			ex isResumable 				ifTrue: 					[(self confirm: (ex messageText last == $? 								ifTrue: [ex messageText]								ifFalse: [ex messageText , '\Do you want to proceed?' withCRs])) 						ifTrue: [ex resume]]				ifFalse: 					[ex parameter notNil 						ifTrue: [(self confirm: ex messageText) ifTrue: [ex parameter value]]						ifFalse: [self warn: ex messageText]].			ex return: nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineMethod	| node |	node := self findNode.	(node isNil or: [node isMessage not]) 		ifTrue: [^self warn: 'Could not find message send'].	(node receiver isVariable 		and: [#('self' 'super') includes: node receiver name]) 			ifTrue: 				[self performRefactoring: (InlineMethodRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]			ifFalse: 				[self performRefactoring: (InlineMethodFromComponentRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineParameter	self handleError: 			[| ref |			ref := InlineParameterRefactoring 						inlineParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'jws 10/28/2016 14:05'!inlineSelfSends	self messageListIndex = 0 ifTrue: [^self].	self handleError: 			[| refactoring aCollection |			refactoring := InlineAllSendersRefactoring sendersOf: self selector						in: self selectedClassOrMetaClass.			refactoring execute.			refactoring messagesNotReplaced > 0 				ifTrue: 					[self warn: ('<1p> message sends were not replaced' 								expandMacrosWith: refactoring messagesNotReplaced)].			self changed: #messageList.			self changedSelector].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!inlineTemporary	| node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isAssignment not]) 		ifTrue: [^self warn: 'Could not find the node'].	self performRefactoring: (InlineTemporaryRefactoring 				inline: (self convertToSourceInterval: node sourceInterval)				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/15/2000 22:12'!inspectAllInstances	(self nonMetaClass allInstances) inspect! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 17:53'!navigateToClass	self navigateToClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/28/2001 23:46'!navigateToClass: foundClass 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/31/2004 09:21'!navigateToClassNamed: className 	| foundClass |	foundClass := Smalltalk classNamed: className.	self navigateToClass: foundClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 18:13'!openBrowserForClass	self class fullOnClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:45'!parseSelection	^RBParser parseExpression: self selectedText onError: [:str :pos | ^nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:41'!performClassRefactoring: refactoring 	self handleError: 			[refactoring execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 01:15'!performRefactoring: aRefactoring 	aRefactoring isNil ifTrue: [^self].	self handleError: 			[aRefactoring execute.			self changed: #messageList.			self changed: #contents]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:43'!protectInstVar	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!protectInstVar: aString 	self 		performRefactoring: (ProtectInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:01'!protectSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:45'!pullUpClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectSubclassClassVar.	classVar isNil ifTrue: [^self].	self pullUpClassVar: self nonMetaClass in: classVar.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:44'!pullUpClassVar: class in: classVar 	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: classVar				class: class.	self performClassRefactoring: refactoring! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!pullUpInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectSubclassInstVar.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/30/2001 18:12'!pushDownClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(PushDownClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass].self needsWork.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!pushDownInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self handleError: 			[(PushDownInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:49'!pushUpClassVar: aString 	self performRefactoring: (PullUpClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString) superclass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:37'!pushUpSelectedClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self pushUpClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 2/26/2006 16:53'!pushUpSelectedInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectedVariableName.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass superclass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'jws 10/28/2016 14:00'!removeClassSafe	self classListIndex = 0 ifTrue: [^self].	self changeRequest ifFalse: [^self].	self removeClassesSafe: self nonMetaClasses.	self newClassList: self classNames.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:09'!removeClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(RemoveClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/12/2000 23:05'!removeClassesSafe: classCollection 	self handleError: 			[(RemoveClassRefactoring 				classNames: (classCollection collect: [:each | each name])) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!removeInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self removeInstVar: instVar fromClass: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:10'!removeInstVar: instVar fromClass: cls 	self handleError: 			[(RemoveInstanceVariableRefactoring variable: instVar class: cls) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 11/2/2002 18:54'!renameClass: aClass 	| aString newName |	aString := self request: 'Enter new ClassName' initialAnswer: aClass name.	aString isEmpty ifTrue: [^self].	newName := aString asSymbol.	self handleError: 			[(RenameClassRefactoring rename: aClass to: newName) execute.			self selectClasses: (Array with: aString asSymbol)				meta: self isMeta				categories: self categories.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:11'!renameClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:45'!renameClassVar: aString 	self navigator renameClassVar: aString asSymbol		in: (self nonMetaClass whichClassDefinesClassVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:46'!renameClassVar: oldName in: aClass 	| newName |	newName := self requestClassVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameClassVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar	| name |	name := self selectInstVarSupers: false subs: false.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameInstVar: aString 	self navigator renameInstVar: aString		in: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar: oldName in: aClass 	| newName |	newName := self requestInstVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameInstanceVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 3/15/2006 17:28'!renameMethod: aSelector in: aClass 	| oldMethodName newMethodName oldArguments argumentPermutation |	oldArguments := (RBParser parseMethod: self selectedMessage) argumentNames.	oldMethodName := RBMethodName selector: aSelector arguments: oldArguments.	(newMethodName := MethodNameEditor forMethodName: oldMethodName) 		ifNil: [^nil].	argumentPermutation := newMethodName arguments 				collect: [:e | oldArguments indexOf: e].	^self handleError: 			[(RenameMethodRefactoring 				renameMethod: aSelector				in: aClass				to: newMethodName selector				permutation: argumentPermutation) execute.			newMethodName selector]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:55'!renameSelectedClassVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/27/2003 14:25'!renameSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameTemporary	| newName node |	node := self findNode.	(node isNil or: [node isVariable not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter new name:' initialAnswer: node name.	newName isEmpty ifTrue: [^self].	self performRefactoring: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertToSourceInterval: node sourceInterval)				to: newName				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVar	self selectedClassOrMetaClass chooseClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select cvars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassClassVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectClassVar].	subsBoolean ifTrue:[^self selectSubclassClassVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectClassVariables	| variables |	variables := self nonMetaClass classVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: variables		values: variables		cancel: [#()]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 10:53'!selectClasses: classCollection meta: aBoolean categories: categoriesCollection	classCollection ifNotEmpty:		[ :col |		self selectClass: classCollection first ].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVar	self selectedClassOrMetaClass chooseInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select ivars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassInstVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectInstVar].	subsBoolean ifTrue:[^self selectSubclassInstVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectInstanceVariables	| variables |	variables := self selectedClass instVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: self selectedClass instVarNames		values: self selectedClass instVarNames		cancel: [#()]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassClassVar	self selectedClassOrMetaClass chooseSubclassesClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassInstVar	self selectedClassOrMetaClass chooseSubclassesInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 2/25/2005 08:32'!selectSubclassesOf: aClass 	| subclasses |	subclasses := aClass subclasses 				asSortedCollection: [:a :b | a name < b name].	subclasses isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: ('Choose subclasses of {1}:' translated format: { aClass name })		multipleSelect: true		fromList: subclasses		values: subclasses		cancel: [nil]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!addClassSubMenuTo: aMenu 	| findSubMenu rewriteSubMenu lintSubMenu lastBrowse pkg |	World ifNil: [^aMenu].	pkg := self packageForSelectedCategory.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #finderOnClass;				add: 'code in class hierarchy...' translated					action: #finderOnClassHierarchy;				add: 'code in class category...' translated action: #finderOnClassCategory;				yourself.	pkg ifNotNil: 			[findSubMenu add: 'code in package...' translated				action: #finderOnPackageWithClassCategory].	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #rewriteToolOnClass;				add: 'code in class hierarchy...' translated					action: #rewriteToolOnClassHierarchy;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				yourself.	pkg ifNotNil: 			[rewriteSubMenu add: 'code in package...' translated				action: #rewriteToolOnPackageWithClassCategory].	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class...' translated action: #lintOnClass;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on class hierarchy...' translated action: #lintOnClassHierarchy;				yourself.	pkg ifNotNil: 			[lintSubMenu add: 'on package...' translated				action: #lintOnPackageWithClassCategory].	aMenu defaultTarget: aMenu.	lastBrowse := 4.	pkg ifNotNil: 			[aMenu				add: 'browse package ' , pkg packageName					target: self					action: #browsePackageWithClassCategory;				addMorph: aMenu submorphs last asElementNumber: 4.			lastBrowse := 5].	aMenu		add: 'browse category' translated			target: self			action: #browseSelectedClassCategory;		addMorph: aMenu submorphs last asElementNumber: lastBrowse.	aMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu;		addLine;		add: 'class'			subMenu: ((MenuMorph new)					defaultTarget: self;					addLine;					add: 'references...' translated action: #classRefs;					add: 'create subclass...' translated action: #createSubclass;					add: 'rename as...' translated action: #rbRenameClass;					add: 'remove...' translated action: #removeClass;					add: 'safe remove' translated action: #removeClassSafe;					add: 'convert to sibling' translated action: #convertToSibling;					add: 'inspect all instances...' translated action: #inspectAllInstances;					add: 'find reference path to an instance...' translated						action: #findReferencePathToInstance;					add: 'find all reference paths to an instance...' translated						action: #findAllReferencesToInstances;					add: 'check protocols...' translated action: #checkProtocols;					yourself)! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addClassVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'class variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #classVarRefs;						add: 'add...' translated action: #addClassVar;						add: 'rename as...' translated action: #renameClassVar;						add: 'remove...' translated action: #removeClassVar;						add: 'push down...' translated action: #pushDownClassVar;						add: 'pull up...' translated action: #pullUpClassVar;						add: 'create accessors...' translated action: #createClassVarAccessors;						add: 'abstract...' translated action: #abstractClassVar;						yourself)]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addInstanceVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'instance variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #instVarRefs;						add: 'readers...' translated action: #instVarReaders;						add: 'writers...' translated action: #instVarWriters;						add: 'add...' translated action: #addInstVar;						add: 'rename as...' translated action: #renameInstVar;						add: 'remove...' translated action: #removeInstVar;						add: 'push down...' translated action: #pushDownInstVar;						add: 'pull up...' translated action: #pullUpInstVar;						add: 'create accessors...' translated action: #createInstVarAccessors;						add: 'abstract...' translated action: #abstractInstVar;						add: 'protect/concrete...' translated action: #protectInstVar;						yourself)]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:24'!addSelectionSubMenuTo: aMenu	| title subMenu |	World ifNotNil: 		[aMenu defaultTarget: aMenu.		title := 'selection...'.		subMenu := self selectMenu. 		aMenu add: title subMenu: subMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!assignmentMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'inline temporary' translated action: #inlineTemporary;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:36'!classListMenu: aMenu shifted: shifted 	| moreItem |	super classListMenu: aMenu shifted: shifted.	shifted 		ifFalse: 			[moreItem := aMenu submorphs last.			moreItem delete.			self addClassSubMenuTo: aMenu.			self addClassVariableSubMenuTo: aMenu.			self addInstanceVariableSubMenuTo: aMenu.			aMenu addLine.			aMenu addMorphBack: moreItem].	^aMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!classVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseClassVarRefs;		add: 'rename class variable...' translated action: #renameClassVar;		add: 'push up' translated action: #pushUpSelectedClassVar;		add: 'create accessors' translated action: #createClassVarAccessors;		add: 'abstract' translated action: #abstractClassVar;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/5/2005 16:45'!codePaneMenu: aMenu shifted: shifted 	| moreItem |	super codePaneMenu: aMenu shifted: shifted.	moreItem := aMenu submorphs last.	moreItem delete.	aMenu add: 'extract method' translated action: #extractMethod.	aMenu add: 'extract method to component' translated		action: #extractMethodToComponent.	self addSelectionSubMenuTo: aMenu.	aMenu addLine; addMorphBack: moreItem.	^aMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!globalVariableMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'navigate to' translated action: #navigateToClass;		add: 'open browser on...' translated action: #openBrowserForClass;		add: 'browse references...' translated action: #browseReferencesToGlobal;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!instanceVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseSelectedInstVarRefs;		add: 'readers...' translated action: #browseSelectedInstVarReaders;		add: 'writers...' translated action: #browseSelectedInstVarWriters;		add: 'rename instance variable...' translated			action: #renameSelectedInstVar;		add: 'pull up' translated action: #pushUpSelectedInstVar;		add: 'create accessors' translated action: #createSelectedInstVarAccessors;		add: 'abstract' translated action: #abstractSelectedInstVar;		add: 'protect/concrete' translated action: #protectSelectedInstVar;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:25'!messageListMenu: aMenu shifted: shifted 	^shifted ifFalse: [		super messageListMenu: aMenu shifted: shifted.		aMenu addStayUpItem.		aMenu submorphs last delete.		aMenu addTranslatedList: #(			#-			#('safe remove' #removeMethodSafe) 			#('add parameter' #addParameter) 			#('rename method' #renameMethod) 			#('inline all self sends' #inlineSelfSends) 			#('push up' #pushUpMethod) 			#('push down' #pushDownMethod) 			#-			#('more...' #shiftedYellowButtonActivity))]		ifTrue: [self shiftedMessageListMenu: aMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!messageMenuFor: aNode 	"add: stuff action: bar"	^(MenuMorph new)		defaultTarget: self;		add: 'senders...' translated action: #browseSenders;		add: 'implementors...' translated action: #browseImplementors;		add: 'inline message' translated action: #inlineMethod;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!noMenu	^(MenuMorph new)		add: 'no selection' translated action: #printString;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!parameterMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'remove parameter' translated action: #removeParameter;		add: 'inline parameter' translated action: #inlineParameter;		add: 'rename...' translated action: #renameTemporary;		yourself	"Things that used to be here -#(#MenuItem #rawLabel: 'con&vert to instance variable' #value: #createInstVar) #(#MenuItem #rawLabel: 'move to inner &scope' #value: #bindTight)) #(5) nil) 		decodeAsLiteralArray"! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 5/17/2000 21:12'!selectMenu	| node |	node := self findNode.	node isNil ifTrue: [^self noMenu].	node isVariable ifTrue: [^self selectVariableMenuFor: node].	node isMessage ifTrue: [^self messageMenuFor: node].	node isAssignment ifTrue: [^self assignmentMenuFor: node].	node isValue ifTrue: [^self valueNodeMenuFor: node].	^self noMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 10/15/2000 21:06'!selectVariableMenuFor: aNode 	(aNode whoDefines: aNode name) notNil 		ifTrue: [^self temporaryMenuFor: aNode].	(self selectedClassOrMetaClass allInstVarNames includes: aNode name) 		ifTrue: [^self instanceVariableMenu].	(self nonMetaClass allClassVarNames 		detect: [:each | each asString = aNode name]		ifNone: [nil]) notNil 		ifTrue: [^self classVariableMenu].	^(Smalltalk includesKey: aNode name asSymbol) 		ifTrue: 			[self globalVariableMenuFor: (Smalltalk associationAt: aNode name asSymbol)]		ifFalse: [self noMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!systemCategoryMenu: aMenu 	| newMenu findSubMenu rewriteSubMenu lintSubMenu |	newMenu := super systemCategoryMenu: aMenu.	newMenu addLine.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated action: #finderOnClassCategory;				add: 'code in package...' translated					target: self					action: #finderOnPackageWithClassCategory;				yourself.	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				add: 'code in package...' translated					target: self					action: #rewriteToolOnPackageWithClassCategory;				yourself.	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on package...' translated action: #lintOnPackageWithClassCategory;				yourself.	newMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu.	newMenu addLine.	self packageForSelectedCategory ifNotNilDo: 			[:pkg | 			newMenu 				add: 'browse package ' , pkg packageName				target: self				action: #browsePackageWithClassCategory].	newMenu 		add: 'browse category' translated		target: self		action: #browseSelectedClassCategory.	^newMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!temporaryMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'convert to instance variable' translated action: #createInstVar;		add: 'rename...' translated action: #renameTemporary;		add: 'move to inner scope' translated action: #bindTight;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'dvf 9/1/2001 19:07'!temporaryMenuFor: aNode 	aNode parent ifNil:[^self noMenu].	^aNode parent isMethod		ifTrue:[self parameterMenu]		ifFalse:[self temporaryMenu].! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!valueNodeMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'jws 10/28/2016 14:05'!addParameter	| newSelector aCollection |	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self addParameterTo: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	aCollection := Array with: newSelector.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'dvf 9/30/2001 02:16'!addParameterTo: aSelector in: aClass 	| initializer newSelector initialAnswer |	initialAnswer := aSelector numArgs == 0 				ifTrue: [aSelector , ':']				ifFalse: [aSelector].	newSelector := self request: 'Enter new selector:'				initialAnswer: initialAnswer.	newSelector isEmpty ifTrue: [^nil].	initializer := self request: 'Enter default value for parameter:'				initialAnswer: 'nil'.	initializer isEmpty ifTrue: [^nil].	^self handleError: 			[(AddParameterRefactoring 				addParameterToMethod: aSelector				in: aClass				newSelector: newSelector asSymbol				initializer: initializer) execute.			newSelector]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'jws 10/28/2016 14:05'!pushDownMethod	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushDownMethodRefactoring pushDown: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'jws 10/28/2016 14:05'!pushUpMethod	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushUpMethodRefactoring pushUp: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'jws 10/28/2016 14:05'!removeMethodSafe	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self removeMethodsSafe: self selectors from: self selectedClassOrMetaClass.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 5/12/2000 21:58'!removeMethodsSafe: sels from: cls 	self		handleError: [(RemoveMethodRefactoring removeMethods: sels from: cls) execute]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 10/15/2000 21:07'!removeParameter	self handleError: 			[| ref |			ref := RemoveParameterRefactoring 						removeParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'jws 10/28/2016 14:05'!renameMethod	| newSelector |	self messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self renameMethod: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	self changed: #messageList.	self messageListIndex: (self messageList indexOf: newSelector).	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:49'!browseAllCallsOn: aSymbol	((BrowserEnvironment new)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllCallsOn: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:05'!browseAllImplementorsOf: aSymbol	((BrowserEnvironment new)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllImplementorsOf: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:40'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aName method filteredList result |	(aName := self selectedMessageName) ifNotNil: 			[method := self selectedClassOrMetaClass compiledMethodAt: aName.			filteredList := method messages 						reject: [:each | #(#new #initialize #=) includes: each].			filteredList := filteredList inject: Set new						into: 							[:s :sel | 							s								addAll: (self systemNavigation allImplementorsOf: sel);								yourself].			result := SelectorEnvironment new.			filteredList 				do: [:mr | result addClass: mr actualClass selector: mr methodSymbol].			result openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 00:01'!browseGlobalInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseGlobalReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:34'!browseGlobalReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:06'!browseImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self navigator! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:48'!browseImplementorsOf: aSymbol	(SelectorEnvironment implementorsOf: aSymbol in: BrowserEnvironment new) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 15:58'!browseInstVarDefs	self browseInstVarWriters! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!browseInstVarReaders	| name |	name := self selectInstVar.	name isEmptyOrNil ifTrue: [^self].	self navigator browseGlobalInstVarReadersTo: name		in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'rga 9/16/2001 22:06'!browseInstVarRefs	"first handle situation where no class selected"	| name |	self selectedClass		ifNil: [^ self inform: 'Nothing selected.'].	name := self selectInstVar.	"then handle the situation where no ivar selected"	name isEmpty		ifFalse: [self navigator browseGlobalInstVarRefsTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseInstVarWriters	| name |	name := self selectInstVar.	name notNil 		ifTrue: [self navigator browseGlobalInstVarWritersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:11'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseLocalSendersOfMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllCallsOn:localTo: 		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:59'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self systemNavigation! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:33'!browsePackageWithClassCategory	(self environmentForPackageWithClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseReferencesToGlobal	| name association |	name := self selectedVariableName.	name isNil ifTrue: [^self].	association := Smalltalk associationAt: name asSymbol ifAbsent: [^self].	self navigator browseGlobalReferencesTo: association! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 16:57'!browseSelectedClassCategory	(self environmentForSelectedClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedClassVarRefs	| name association |	name := self selectedVariableName.	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedInstVarReaders	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarReadersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarRefs	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarRefsTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarWriters	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarWritersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/17/2000 22:33'!browseSenders	| node |	node := self findNode.	(node isNil or: [node isMessage not]) ifTrue: [^self].	(BrowserEnvironment new referencesTo: node selector) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:58'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!classRefs	self 		browseReferencesTo: (self browserEnvironment associationAt: self className)! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 6/14/2000 10:49'!classVarRefs	| classVar association |	classVar := self selectClassVarSupers: true subs: false.	classVar isNil ifTrue: [^self].	association := self findAssociationForClassVariable: classVar.	self browseReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!instVarReaders	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifTrue: [^self].	self browseInstVarReadersTo: instVar in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/5/2005 16:18'!instVarRefs	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifFalse: 		 [self browseInstVarRefsTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 10/15/2000 21:04'!instVarWriters	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar notNil		ifTrue: [self browseInstVarWritersTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 07:02'!methodHierarchy	self browseAllImplementorsOf: (self selectedMessageName ifNil: [ ^self ]) localTo: (self selectedClassOrMetaClass ifNil: [ ^self ])! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 15:54'!browseClassRefs	| cls association |	(cls := self selectedClass) ifNotNil: [	association := Smalltalk associationAt: cls theNonMetaClass name ifAbsent: [^self].	self navigator browseGlobalReferencesTo: association ].! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 15:52'!browseClassVarRefs	| name association |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 16:00'!browseClassVariables	self browseClassVarRefs! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 13:00'!browserEnvironment	^BrowserEnvironment new! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:26'!categories	^#().! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 10/3/2001 18:18'!checkProtocolFor: aSelector in: aClass 	| exp1 exp2 exp3 exp4 |	self needsWork.	self error:'not yet implemented'. {exp1. [exp2]. exp3. [exp4]} allTrue"	| protocol |	protocol := aClass organization categoryOfElement: aSelector.	^protocol isNil 		ifTrue: 			[(Dialog confirm: aSelector asString 						, ' is not classified under a protocol.\Do you want to classify it?' 								withCRs) 				ifTrue: 					[protocol := Dialog 								request: 'Enter a protocol name for ' asText 										, (aSelector asText emphasizeAllWith: #(#italic)) , ':'.					protocol isEmpty 						ifFalse: 							[self 								moveMethods: (Array with: aSelector)								to: protocol								in: aClass]].			true]		ifFalse: [false]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocolMatchFor: aSelector in: aClass 	self needsWork.	self error:'not yet implemented'.[ "comment block"	| protocol superClass superProtocol patchClass |	protocol := aClass organization categoryOfElement: aSelector.	protocol isNil ifTrue: [^false].	superClass := aClass superclass whichClassIncludesSelector: aSelector.	superClass isNil ifTrue: [^false].	superProtocol := superClass organization categoryOfElement: aSelector.	superProtocol == protocol ifTrue: [^false].	superProtocol isNil ifTrue: [^false].	patchClass := self 				choose: (aSelector printString , ' is classified under "' , protocol 						, '" in ' , aClass name 						, '\and under "' , superProtocol 						, '" in ' , superClass name 						, '. Patch?') withCRs				labels: (Array 						with: aClass name asString						with: superClass name asString						with: 'neither')				values: (Array 						with: aClass						with: superClass						with: nil)				default: aClass.	patchClass isNil ifTrue: [^false].	patchClass == aClass 		ifTrue: 			[self 				moveMethods: (Array with: aSelector)				to: superProtocol				in: aClass]		ifFalse: 			[self 				moveMethods: (Array with: aSelector)				to: protocol				in: superClass].	^true].! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocols	self changeRequest ifFalse: [^self].	Cursor wait showWhile: 			[(self nonMetaClasses inject: false				into: 					[:changed :class | 					changed | (self checkProtocolsFor: class)						| (self checkProtocolsFor: class class)])					ifTrue: [self setState: self getState updateClasses: true]					ifFalse: [self warn: 'No changes made.']]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:53'!checkProtocolsFor: aClass 	^(self browserEnvironment selectorsForClass: aClass) inject: false		into: 			[:bool :each | 			bool | (self checkProtocolFor: each in: aClass) 				| (self checkProtocolMatchFor: each in: aClass)]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:23'!createSubclass	| class |	self changeRequest		ifFalse: [^ self].	class := self createSubclassOf: self nonMetaClass.	class isNil		ifTrue: [^ self].			self changedClass.	self selectClass: class! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:20'!createSubclassOf: aClass 	| name subclasses aCategory categoryChoices |	name := self requestClassName.	name isNil		ifTrue: [^ nil].	subclasses := self selectSubclassesOf: aClass.	subclasses isNil		ifTrue: [^ nil].	categoryChoices := (OrderedCollection with: aClass category) addAll: Smalltalk organization categories;				 yourself.	aCategory := (SelectionMenu selections: categoryChoices lines: #(1 ))				startUpWithCaption: 'Choose a class category:'.	aCategory		ifNil: [^ nil].	^ self		handleError: [(AddClassRefactoring				addClass: name				superclass: aClass				subclasses: subclasses				category: aCategory) execute.			Smalltalk				at: name asSymbol				ifAbsent: []]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:15'!environmentForPackageWithClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new 		forPackageContainingClassCategory: self selectedSystemCategoryName! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:21'!environmentForSelectedClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new forCategories: {self selectedSystemCategoryName}! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:17'!environmentForSelectedClassHierarchy	| classes |	self selectedClass ifNil: [^nil].	classes := Set new.	self selectedClass withAllSubAndSuperclassesDo: [:cls | classes add: cls].	^BrowserEnvironment new forClasses: classes! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 10:54'!findAllReferencesToInstances	self needsWork.	self error:'ReferenceFinder does not work yet. Sorry.'.	"self showWaitCursorWhile: 			[| paths |			paths := ReferenceFinder findAllPathsToInstanceOf: self selectedClass.			paths isEmpty 				ifTrue: [self warn: 'No reference paths exist']				ifFalse: [paths inspect]]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:03'!findReferencePathToInstance	self needsWork.	self error:'ReferenceFinder does not work yet, sorry.'.	"self showWaitCursorWhile: 			[| path |			path := ReferenceFinder findPathToInstanceOf: self selectedClass.			path notNil 				ifTrue: [path inspect]				ifFalse: [self warn: 'No reference paths exist']]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'md 7/18/2006 14:23'!packageForSelectedCategory		self selectedSystemCategoryName isNil ifTrue:[ ^ nil].	^PackageInfo allPackages 		detect: [:p | p includesSystemCategory: self selectedSystemCategoryName]		ifNone: []! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:07'!rbRenameClass	self changeRequest ifFalse: [^self].	self renameClass: self nonMetaClass! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/7/2000 23:01'!requestClassName	| name |	name := self request: 'Enter a class name:'.	^name isEmpty ifTrue: [nil] ifFalse: [name]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/29/2001 18:13'!selectedClassInCode	^Smalltalk classNamed: self findNode name asSymbol! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!selectedInterval	^self codeTextMorph selectionInterval! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:46'!selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self codeTextMorph text asString copyFrom: interval first		to: interval last! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!text	^self contents! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:29'!changeRequest	^self okToChange.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:30'!changed: aSymbol with:anObject	"Temporary"	aSymbol == #category ifTrue: [ self changed: #categoryList ].	! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'hboon 11/12/2004 15:29'!changedClass	self changed: #categoryList.	self changed: #messageList.	self changed: #classList.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:14'!changedSelector	self changed: #contents.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/5/2000 22:06'!className	^self selectedClassName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:14'!classNames	^{self selectedClassName}! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:13'!convertToSourceInterval: anInterval 	"Convert the selected interval from our text widget, to the interval in the stored source code.	For this widget, we don't need to do anything."	^anInterval! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:33'!findAssociationForClassVariable: classVar 	| association definingClass name |self needsWork. "well, maybe not work, but needs testing."	definingClass := self nonMetaClass.	association := nil.		[definingClass notNil and: 			[name := definingClass classPool keys 						detect: [:each | each asString = classVar asString]						ifNone: [nil].			association := definingClass classPool associationAt: name ifAbsent: [nil].			association isNil]] 			whileTrue: [definingClass := definingClass superclass].	^association! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!getState	"do nothing, this is temporary"! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/8/2000 10:47'!isMeta	^self metaClassIndicated.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:31'!navigator	^self.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:13'!newClassList:aCollection	self changed: #classList.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClass	^self selectedClassOrMetaClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClasses	^{self selectedClassOrMetaClass}.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 20:06'!request: aString	^FillInTheBlank request: aString! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:47'!requestClassVarName: oldName 	| name |	name := self request: 'Enter a class variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/16/2000 23:22'!requestInstVarName: oldName 	| name |	name := self request: 'Enter a instance variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:18'!selectedVariableName	| node |	node := self findNode.	^(node notNil and: [node isVariable]) ifTrue: [node name] ifFalse: [nil]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:10'!selector	^self selectedMessageName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:35'!selectors	^{self selectedMessageName}! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!setState: aNavigatorState updateClasses: aBoolean 	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:37'!showWaitCursorWhile: aBlock	^Cursor execute showWhile:aBlock.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 8/26/2001 16:33'!updateContents	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:12'!updateRequest	^true.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 19:57'!warn: aString	^PopUpMenu notify:aString.! !!RefactoringBrowser methodsFor: 'initialize-release' stamp: 'jf 7/24/2005 01:02'!defaultBrowserTitle	^ 'RB'! !!RefactoringBrowser methodsFor: 'tools' stamp: 'dvf 9/29/2001 00:04'!finderOnClass	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 12:32'!finderOnClassCategory	(self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [(FinderTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:44'!finderOnClassHierarchy	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 14:26'!finderOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [ FinderTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 11:11'!lintOnClass	self selectedClass ifNil: [^nil].	LintDialog onEnvironment: (BrowserEnvironment new forClasses: {self selectedClass}).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:21'!lintOnClassCategory	^LintDialog onEnvironment: (self environmentForSelectedClassCategory ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:19'!lintOnClassHierarchy	^LintDialog onEnvironment: (self environmentForSelectedClassHierarchy ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:16'!lintOnPackageWithClassCategory	^LintDialog onEnvironment: (self environmentForPackageWithClassCategory ifNil: [ ^nil ])! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClass	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClassCategory	(self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [(RewriteTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:52'!rewriteToolOnClassHierarchy	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [ RewriteTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!hierarchyBrowserIsRBPreferenceChanged	(Preferences valueOfPreference: #hierarchyBrowserIsRB)		ifTrue: [ HierarchyBrowser superclass == self			ifFalse: [ HierarchyBrowser superclass: self ]]		ifFalse: [ HierarchyBrowser superclass == self			ifTrue: [  HierarchyBrowser superclass: Browser  ]]! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 07:56'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Refactoring Browser'. {self. #openBrowser}}.	self registerInAppRegistry.	Preferences addPreference: #hierarchyBrowserIsRB		categories: #(browsing)		default: true		balloonHelp: 'if true, the HierarchyBrowser will be a kind of RefactoringBrowser'		projectLocal: false		changeInformee: self		changeSelector: #hierarchyBrowserIsRBPreferenceChanged.	self hierarchyBrowserIsRBPreferenceChanged ! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!unload	"Called when the class is being removed"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	Preferences removePreference: #hierarchyBrowserIsRB.	HierarchyBrowser superclass == self		ifTrue: [  HierarchyBrowser superclass: Browser  ].! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:13'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'jf 7/24/2005 00:55'!openBrowser	"Create and schedule a BrowserView with label 'RB'. The 	view consists of five subviews, starting with the list view of system 	categories of SystemOrganization. The initial text view part is empty."	self openBrowserView: (self new openEditString: nil)			label: 'RB'! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:09'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'nk 2/27/2005 13:16'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu addLine;	add: 'find code in methods...' target: self action: #finderForSelectors;	add: 'rewrite code in methods...' target: self action: #rewriteToolForSelectors;	add: 'run lint on methods...' target: self action: #lintForSelectors;	yourself.! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'bh 5/14/2000 20:30'!open	World ifNotNil: [^ self openAsMorph].	self error: self class name asString, ' only works in Morphic so far.'.! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 10:21'!addMorphicSwitchesTo: aListMorph 	| switches pane divider dividerFrame |	pane := (BorderedMorph new)				color: Color transparent;				borderWidth: 2;				yourself.	pane layoutPolicy: ProportionalLayout new.	switches := self buildMorphicSwitches.	switches borderWidth: 0.	pane addMorph: switches fullFrame: self morphicSwitchesFrame.	divider := (BorderedSubpaneDividerMorph forTopEdge)				height: 2;				yourself.	Preferences alternativeWindowLook 		ifTrue: 			[| aColor |			aColor := (Color colorFrom: self defaultBackgroundColor) darker.			divider				borderRaised;				borderWidth: 4;				borderColor: aColor darker.			pane				borderRaised;				borderColor: aColor.			aListMorph borderInset].	dividerFrame := self morphicSwitchesFrame.	dividerFrame bottomOffset: dividerFrame topOffset.	dividerFrame topOffset: dividerFrame topOffset - divider height.	pane addMorph: divider fullFrame: dividerFrame.	aListMorph borderWidth: 0.	pane addMorph: aListMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ dividerFrame topOffset)).	^pane! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:42'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4) offsets: (0@0 corner: 0@0)! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:17'!lowerPanesFrame	^0 @ 0.4 corner: 1 @ 1! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:16'!messageListFrame	^0.5 @ 0 extent: 0.5 @ 0.4! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 08:17'!morphicSwitchesFrame	"Frame for switches *within* the message list"	^LayoutFrame fractions: (0@1 corner: 1@1)		offsets: (0 @ -25 corner: 0 @ 0)! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:06'!openAsMorph	| window aListMorph pane |	window := (SystemWindow labelled: self browserEnvironment label) 				model: self.	aListMorph := PluggableListMorph 				on: self				list: #classList				selected: #classListIndex				changeSelected: #classListIndex:				menu: #classListMenu:shifted:				keystroke: #classListKey:from:.	pane := self addMorphicSwitchesTo: aListMorph.	window addMorph: pane fullFrame: self classListFrame.	aListMorph := PluggableListMorph 				on: self				list: #messageList				selected: #messageListIndex				changeSelected: #messageListIndex:				menu: #messageListMenu:shifted:				keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: self messageListFrame.	self 		addLowerPanesTo: window		at: self lowerPanesFrame		with: nil.	window setUpdatablePanesFrom: #(#classList #messageList).	^window! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment	^browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment: anObject	browserEnvironment := anObject! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^(self browserEnvironment selectionIntervalFor: self contents) 		ifNil: [1 to: 0]! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 8/31/2004 08:45'!selectedMethod	| nonMetaClass selector class |	(nonMetaClass := self selectedClass) ifNil:[ ^nil ].	(selector := self selectedMessageName) ifNil:[ ^nil ].	class := self classMessagesIndicated ifTrue:[ nonMetaClass class ] ifFalse:[ nonMetaClass ].	^class compiledMethodAt: selector ifAbsent: [].! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNames asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!finderForSelectors	(FinderTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'FinderTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!lintForSelectors	LintDialog runOnEnvironment: self browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!rewriteToolForSelectors	(RewriteTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'RewriteTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'jws 10/28/2016 13:59'!selectedClass	| cls envt |	cls := self classList at: self classListIndex ifAbsent: [^nil].	envt := self selectedEnvironment.	^envt classNamed: cls.! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:42'!selectedClassName	^(self selectedClass ifNil: [ ^nil ]) name! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:46'!selectedClassOrMetaClass	| cls |	cls := self selectedClass ifNil: [ ^nil ].	^self metaClassIndicated ifTrue: [ cls class ] ifFalse: [ cls ]! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:51'!initializeOnEnvironment: aBrowserEnvironment 	self browserEnvironment: aBrowserEnvironment.	self classListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/2/2005 14:06'!labelString	| theLabel |	theLabel := self browserEnvironment printStringLimitedTo: 60.	theLabel isEmpty ifTrue: [^super labelString].	^theLabel! !!SelectorEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:06'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: [self browserEnvironment privateSelectorsForClass: self selectedClass]		ifFalse: 			[self browserEnvironment privateSelectorsForClass: self selectedClass class]) 			asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 2/26/2005 12:39'!selectCategoryForClass: theClass	self systemCategoryListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/4/2005 10:52'!selectedEnvironment	^Smalltalk! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/7/2005 13:24'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^self selectedClass ifNotNilDo: [ :cls | cls category ] ! !!SelectorEnvironmentBrowser methodsFor: 'message category list' stamp: 'jws 10/28/2016 14:06'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	self messageListIndex = 0 ifTrue: [^ nil].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!ClassEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:27'!initializeOnEnvironment: aBrowserEnvironment 	super initializeOnEnvironment: aBrowserEnvironment asSelectorEnvironment! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!SmaCCCodeHolder methodsFor: 'menus' stamp: 'apl 2/18/2003 12:39'!contents: aStringOrText notifying: aRequestor 	| result |	self ownerAcceptSelector notNil ifTrue: [result := (self owner			perform: self ownerAcceptSelector			with: aStringOrText			with: aRequestor)] ifFalse: [result := true].		result ifTrue: [self acceptContents: aStringOrText.			^ true].	^ false! !!SmaCCCodeHolder methodsFor: 'menus' stamp: 'apl 2/20/2003 11:32'!contentsMenu: aMenu shifted: shifted 	"Note that unless we override perform:orSendTo:,  	PluggableTextController will respond to all menu items in a text pane"	| selections labelsString linesArray |	selections := #(#menuFind #findAgain #setSearchString #again #undo #copySelection #cut #paste #pasteRecent #accept #cancel #saveContentsInFile #sendContentsToPrinter #printerSetup #readContentsFromFile ).	labelsString := 'find...(f)\find again (g)\set search string (h)\do again (j)\undo (z)\copy (c)\cut (x)\paste (v)\paste...\accept (s)\cancel (l)\save contents to file...\send contents to printer\printer setup\read contents from file...' withCRs.	linesArray := #(3 5 9 11 14).	^ aMenu		labels: labelsString		lines: linesArray		selections: selections! !!SmaCCCodeHolder methodsFor: 'menus' stamp: 'apl 2/17/2003 11:16'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, 	then perform it on myself. If not, send it to otherTarget,  	presumably the editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!SmaCCCodeHolder methodsFor: 'menus' stamp: 'apl 2/18/2003 12:00'!readContentsFromFile	| result fullFilename |	(result := StandardFileMenu oldFile)		ifNotNil: [fullFilename := result directory fullNameFor: result name.			(FileDirectory default fileExists: fullFilename)				ifFalse: [^ PopUpMenu inform: ' ' , fullFilename , ' doesn''t exists '].			self acceptContents: (FileStream fileNamed: fullFilename) contents. self changed: #contents]! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/6/2004 10:38'!contentsMorph   | txtClass |   contentsMorph isNil       ifTrue: [txtClass := ((Smalltalk                               associationAt: #SVIPrefs                               ifAbsent: []) isNil                           or: [(Smalltalk at: #SVIPrefs) sviIsDefaultCodeEditor not])                       ifTrue: [PluggableTextMorph]                       ifFalse: [Smalltalk at: #PluggableSVIMorph].           contentsMorph := txtClass                       on: self                       text: #contents                       accept: #contents:notifying:                       readSelection: nil                       menu: #contentsMenu:shifted:].   ^ contentsMorph! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/17/2003 11:23'!owner	^owner! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/17/2003 11:23'!owner: anObject	owner := anObject! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/17/2003 12:30'!owner: aSmaCCParserGenerator ownerAcceptSelector: aSymbol 	self owner: aSmaCCParserGenerator.	self ownerAcceptSelector: aSymbol.! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/17/2003 11:26'!ownerAcceptSelector	^ownerAcceptSelector! !!SmaCCCodeHolder methodsFor: 'accessing' stamp: 'apl 2/17/2003 11:26'!ownerAcceptSelector: anObject	ownerAcceptSelector := anObject! !!SmaCCCodeHolder methodsFor: 'edit flag' stamp: 'apl 2/18/2003 10:25'!hasUnacceptedEdits	^ self contentsMorph hasUnacceptedEdits! !!SmaCCCodeHolder methodsFor: 'edit flag' stamp: 'apl 2/17/2003 11:39'!hasUnacceptedEdits: aBoolean 	^ self contentsMorph hasUnacceptedEdits: aBoolean! !!SmaCCCodeHolder methodsFor: 'edit flag' stamp: 'apl 2/17/2003 11:39'!okToChange	^ super okToChange! !!SmaCCCodeHolder class methodsFor: 'instance creation' stamp: 'apl 2/18/2003 13:44'!owner: aSmaCCParserGenerator 	^ self owner: aSmaCCParserGenerator ownerAcceptSelector: nil! !!SmaCCCodeHolder class methodsFor: 'instance creation' stamp: 'apl 2/17/2003 11:26'!owner: aSmaCCParserGenerator ownerAcceptSelector: aSymbol 	^ self new owner: aSmaCCParserGenerator ownerAcceptSelector: aSymbol ! !!SubclassOfClassToRename methodsFor: 'accessing'!calls	^self rewriteRule1: self name , self rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!calls1	^self rewriteRule1: (self rewriteRule1: self calls)! !!SubclassOfClassToRename methodsFor: 'accessing'!name	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1: anObject	^rewriteRule1 := anObject! !!SubclassOfClassToRename methodsFor: 'performing'!reference	^ClassToRename new! !!SubclassOfClassToRename methodsFor: 'performing'!symbolReference	^#ClassToRename! !!SwapMethodRefactoring methodsFor: 'preconditions' stamp: 'dc 4/22/2007 16:19'!checkInstVars	class instanceVariableNames do: [ :each |		(target instanceVariableNames includes: each) ifFalse: [			((class whichSelectorsReferToInstanceVariable: each) includes: selector) ifTrue: [				self					refactoringError: ('<1p> refers to <2s> which is not defined in <3p>' expandMacrosWith: selector with: each with: target) ] ] ]! !!SwapMethodRefactoring methodsFor: 'preconditions' stamp: 'lr 4/5/2007 09:07'!preconditions	^ (RBCondition definesSelector: selector in: class) 		& (RBCondition definesSelector: selector in: target) not		& (RBCondition withBlock: [ self checkInstVars. true ])! !!SwapMethodRefactoring methodsFor: 'initialization' stamp: 'lr 4/5/2007 08:53'!swapMethod: aSelector in: aClass	class := self classObjectFor: aClass.	target := self classObjectFor: (class isMeta		ifTrue: [ class nonMetaclass ]		ifFalse: [ class metaclass ]).	selector := aSelector! !!SwapMethodRefactoring methodsFor: 'transforming' stamp: 'lr 4/5/2007 09:00'!transform	target compile: (class sourceCodeFor: selector) classified: (class protocolsFor: selector).	class removeMethod: selector! !!SwapMethodRefactoring class methodsFor: 'instance-creation' stamp: 'lr 4/5/2007 08:48'!model: aRBSmalltalk swapMethod: aSelector in: aClass	^ self new 		model: aRBSmalltalk;		swapMethod: aSelector in: aClass;		yourself! !!SwapMethodRefactoring class methodsFor: 'instance-creation' stamp: 'lr 4/5/2007 08:48'!swapMethod: aSelector in: aClass	^ self new swapMethod: aSelector in: aClass! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'ClementBera 4/12/2013 16:00'!visitArgumentNode: anArgumentNode	"Sent *each time* an argument node is found"	^ self visitVariableNode: anArgumentNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'ClementBera 4/12/2013 15:59'!visitArgumentNodes: aNodeCollection 	"Sent *once* when visiting method and block nodes"	^aNodeCollection do: [ :each | self visitArgumentNode: each ]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:16'!visitArrayNode: anArrayNode 	anArrayNode children do: [:each | self visitNode: each]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:18'!visitAssignmentNode: anAssignmentNode	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:20'!visitBlockNode: aBlockNode 	self visitArgumentNodes: aBlockNode arguments.	self visitNode: aBlockNode body! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:18'!visitCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:18'!visitLiteralArrayNode: aRBLiteralArrayNode 	aRBLiteralArrayNode contents do: [:each | self visitNode: each]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:19'!visitLiteralNode: aLiteralNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:19'!visitMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:20'!visitMethodNode: aMethodNode 	self visitArgumentNodes: aMethodNode arguments.	aMethodNode pragmas		do: [ :each | self visitNode: each ].	self visitNode: aMethodNode body! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'CamilloBruni 10/31/2012 19:14'!visitNode: aNode 	^aNode acceptVisitor: self! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:19'!visitParseErrorNode: anErrorNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:20'!visitPatternBlockNode: aRBPatternBlockNode 	self visitArgumentNodes: aRBPatternBlockNode arguments.	self visitNode: aRBPatternBlockNode body! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:20'!visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self visitArgumentNodes: aRBPatternWrapperBlockNode arguments.	self visitNode: aRBPatternWrapperBlockNode body! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:19'!visitPragmaNode: aPragmaNode	aPragmaNode arguments do: [ :each | self visitNode: each ]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:25'!visitReturnNode: aReturnNode 	^ self visitNode: aReturnNode value! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:25'!visitSelfNode: aSelfNode	^ self visitVariableNode: aSelfNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:21'!visitSequenceNode: aSequenceNode 	self visitTemporaryNodes: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:20'!visitSuperNode: aSuperNode	^ self visitVariableNode: aSuperNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'ClementBera 6/4/2013 14:55'!visitTemporaryNode: aNode 	"Sent *each time* a temporary node is found"	^ self visitVariableNode: aNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'ClementBera 6/4/2013 14:53'!visitTemporaryNodes: aNodeCollection 	"This is triggered when defining the temporaries between the pipes"	^self visitArgumentNodes: aNodeCollection! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:20'!visitThisContextNode: aThisContextNode	^ self visitVariableNode: aThisContextNode! !!TRBProgramNodeVisitor methodsFor: 'visiting' stamp: 'ClementBera 4/12/2013 16:27'!visitVariableNode: aVariableNode	^ aVariableNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArgumentNode: anArgumentNode	"Sent *each time* an argument node is found"	^ self visitVariableNode: anArgumentNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArgumentNodes: aNodeCollection 	"Sent *once* when visiting method and block nodes"	^aNodeCollection do: [ :each | self visitArgumentNode: each ]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArrayNode: anArrayNode 	anArrayNode children do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitAssignmentNode: anAssignmentNode	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitBlockNode: aBlockNode 	self visitArgumentNodes: aBlockNode arguments.	self visitNode: aBlockNode body! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitLiteralArrayNode: aRBLiteralArrayNode 	aRBLiteralArrayNode contents do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitLiteralNode: aLiteralNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitMethodNode: aMethodNode 	self visitArgumentNodes: aMethodNode arguments.	aMethodNode pragmas		do: [ :each | self visitNode: each ].	self visitNode: aMethodNode body! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitNode: aNode 	^aNode acceptVisitor: self! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitParseErrorNode: anErrorNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitPatternBlockNode: aRBPatternBlockNode 	self visitArgumentNodes: aRBPatternBlockNode arguments.	self visitNode: aRBPatternBlockNode body! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self visitArgumentNodes: aRBPatternWrapperBlockNode arguments.	self visitNode: aRBPatternWrapperBlockNode body! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitPragmaNode: aPragmaNode	aPragmaNode arguments do: [ :each | self visitNode: each ]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitReturnNode: aReturnNode 	^ self visitNode: aReturnNode value! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitSelfNode: aSelfNode	^ self visitVariableNode: aSelfNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitSequenceNode: aSequenceNode 	self visitTemporaryNodes: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitSuperNode: aSuperNode	^ self visitVariableNode: aSuperNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitTemporaryNode: aNode 	"Sent *each time* a temporary node is found"	^ self visitVariableNode: aNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitTemporaryNodes: aNodeCollection 	"This is triggered when defining the temporaries between the pipes"	^self visitArgumentNodes: aNodeCollection! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitThisContextNode: aThisContextNode	^ self visitVariableNode: aThisContextNode! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitVariableNode: aVariableNode	^ aVariableNode! !!ParseTreeSearcher methodsFor: 'testing' stamp: 'lr 1/3/2010 11:48'!canMatchMethod: aCompiledMethod	| actualMessages |	self messages isEmpty		ifTrue: [ ^ true ].	actualMessages := aCompiledMethod messages.	^ self messages 		anySatisfy: [ :each | actualMessages includes: each ]! !!ParseTreeSearcher methodsFor: 'testing'!hasRules	^searches notEmpty! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!answer	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!context	^context! !!ParseTreeSearcher methodsFor: 'accessing'!executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer! !!ParseTreeSearcher methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:35'!executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := Dictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree! !!ParseTreeSearcher methodsFor: 'accessing'!messages	messages notNil ifTrue: [^messages].	argumentSearches notEmpty ifTrue: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray! !!ParseTreeSearcher methodsFor: 'visiting' stamp: 'CamilleTeruel 4/3/2013 16:22'!visitArgumentNode: aNode	| value |	value := self performSearches: argumentSearches on: aNode.	^ value		ifNil: [ 			super visitArgumentNode: aNode.			aNode ]		ifNotNil: [ value ]! !!ParseTreeSearcher methodsFor: 'visiting' stamp: 'CamilleTeruel 4/3/2013 16:23'!visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^ value		ifNil: [ 			super visitNode: aNode.			aNode ]		ifNotNil: [ value ]! !!ParseTreeSearcher methodsFor: 'private'!foundMatch! !!ParseTreeSearcher methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]! !!ParseTreeSearcher methodsFor: 'private' stamp: 'CamilloBruni 12/15/2011 15:28'!performSearches: aSearchCollection on: aNode 	| value |	aSearchCollection do: [ :aSearchRule|		value := aSearchRule performOn: aNode.		value notNil 			ifTrue: 				[self foundMatch.				^value]].	^nil! !!ParseTreeSearcher methodsFor: 'private' stamp: 'jws 10/23/2016 05:35'!recusivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := Dictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext! !!ParseTreeSearcher methodsFor: 'initialize-release'!answer: anObject	answer := anObject! !!ParseTreeSearcher methodsFor: 'initialization' stamp: 'jws 10/23/2016 05:35'!initialize	super initialize.	context := Dictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil! !!ParseTreeSearcher methodsFor: 'searching'!matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:30'!visitArrayNode: anArrayNode	anArrayNode statements: (anArrayNode statements collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitBlockNode: aBlockNode 	aBlockNode arguments: (self visitArgumentNodes: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								show: 'Cannot replace message node inside of cascaded node with non-message node.';								cr.							newMessages add: each]]].	notFound size = aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitLiteralArrayNode: aRBArrayLiteralNode	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents collect: [ :each | self visitNode: each ])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitMessageNode: aMessageNode	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode arguments: (aMessageNode arguments collect: [ :each | self visitNode: each ])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitMethodNode: aMethodNode	aMethodNode arguments: (self visitArgumentNodes: aMethodNode arguments).	aMethodNode pragmas: (aMethodNode pragmas collect: [ :each | self visitNode: each ]).	aMethodNode body: (self visitNode: aMethodNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitPragmaNode: aPragmaNode	aPragmaNode arguments: (aPragmaNode arguments collect: [ :each | self visitNode: each ])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:29'!visitReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:31'!visitSequenceNode: aSequenceNode	aSequenceNode temporaries: (self visitTemporaryNodes: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [ :each | self visitNode: each ])! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:29'!visitArgumentNodes: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgumentNode: each]! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)! !!ParseTreeRewriter methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:35'!executeTree: aParseTree 	| oldContext |	oldContext := context.	context := Dictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeRewriter methodsFor: 'accessing'!tree	^tree! !!ParseTreeRewriter methodsFor: 'private'!foundMatch	answer := true! !!ParseTreeRewriter methodsFor: 'private' stamp: 'CamilloBruni 8/31/2013 20:51'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: [:key :value | 		(key isString not and: [key recurseInto]) 			ifTrue: 				[oldContext at: key put: (value collect: [:each | self visitNode: each])]]! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]! !!ParseTreeSearcher class methodsFor: 'private'!buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]! !!ParseTreeSearcher class methodsFor: 'instance creation'!getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation' stamp: 'lr 11/4/2009 11:44'!justSendsSuper	^ self new		matchesAnyMethodOf: #(			'`@method: `@args ^ super `@method: `@args' 			'`@method: `@args super `@method: `@args')		do: [ :node :answer | true ];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatchingStatements: aString in: aParseTree 	| notifier tree |	notifier := self new.	tree := RBParser parseExpression: aString.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].	notifier matchesTree: tree		do: [:aNode :answer | ^RBParser parseExpression: aString].	notifier executeTree: aParseTree.	^nil! !!ParseTreeRewriter class methodsFor: 'instance creation'!removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule replaceTree: (RBLiteralNode value: literal)		withTree: (RBLiteralNode value: newLiteral).	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation' stamp: 'lr 11/23/2009 14:27'!variable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self'! !!ParseTreeRewriter class methodsFor: 'instance creation' stamp: 'lr 11/23/2009 14:27'!variable: aVarName getter: getMethod setter: setMethod receiver: aString 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: aString , ' ' , setMethod , ' ``@object';		replace: aVarName with: aString , ' ' , getMethod.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree replaceStmt |	tree := self buildTree: code method: false.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]		ifFalse: 			[tree addNode: (RBPatternVariableNode named: '`@.S2').			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].	^self 		replace: tree formattedCode		with: replaceStmt		in: aParseTree		onInterval: anInterval! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:55'!visitArrayNode: anArrayNode	self bracketWith: '{}' around: [ self formatArray: anArrayNode ]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:55'!visitAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.	self visitNode: anAssignmentNode value! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitBlockNode: aBlockNode	self bracketWith: '[]' around: [self formatBlock: aBlockNode]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitCascadeNode: aCascadeNode 	self visitNode: aCascadeNode receiver.	self indentAround: 			[NewLineBeforeFirstCascade ifTrue: [self newLine] ifFalse: [self space].			aCascadeNode messages do: 					[:each | 					self indentAround: 							[self 								formatSelectorAndArguments: each								firstSeparator: []								restSeparator: ((self isMultiLineMessage: each) 										ifTrue: [[self newLine]]										ifFalse: [[self space]])]]				separatedBy: 					[codeStream nextPut: $;.					NewLineAfterCascade ifTrue: [self newLine] ifFalse: [self space]]]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitLiteralArrayNode: aRBArrayLiteralNode 	| brackets |	codeStream nextPut: $#.	brackets := aRBArrayLiteralNode isForByteArray 				ifTrue: ['[]']				ifFalse: ['()'].	self bracketWith: brackets		around: 			[aRBArrayLiteralNode contents do: [:each | self visitNode: each]				separatedBy: [self space]]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'PabloHerrero 2/16/2015 00:41'!visitLiteralNode: aLiteralNode	aLiteralNode value isLiteral		ifFalse: [ self writeString: '''<an unprintable nonliteral value>''' ]		ifTrue: [ self writeString: aLiteralNode sourceText ].! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitMessageNode: aMessageNode 	self visitNode: aMessageNode receiver.	self formatSelectorAndArguments: aMessageNode! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self formatMethodBodyFor: aMethodNode! !!RBConfigurableFormatter methodsFor: 'visiting'!visitNode: aNode	| needsParenthesis |	(lookaheadCode includesKey: aNode)		ifTrue: [^self writeString: (lookaheadCode at: aNode)].	needsParenthesis := self needsParenthesisFor: aNode.	self		bracketWith:			(needsParenthesis				ifTrue: ['()']				ifFalse: [''])		around:			[needsParenthesis ifTrue: [codeStream nextPutAll: StringInsideParentheses].			super visitNode: aNode.			(FormatCommentWithStatements or: [aNode isMethod or: [aNode isSequence]])				ifFalse: [self formatCommentsFor: aNode].			needsParenthesis				ifTrue: [codeStream nextPutAll: StringInsideParentheses]]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitPatternBlockNode: aRBPatternBlockNode 	codeStream nextPut: $`.	self 		bracketWith: '{}' 		around: [self formatBlock: aRBPatternBlockNode]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:56'!visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	codeStream nextPut: $`.	self 		bracketWith: '{}' 		around: [self formatBlock: aRBPatternWrapperBlockNode]! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:57'!visitPragmaNode: aPragmaNode	codeStream nextPut: $<.	self 		formatSelectorAndArguments: aPragmaNode 		firstSeparator: [ 			aPragmaNode selector isInfix				ifTrue: [ self space ] ]		restSeparator: [ self space ].	codeStream nextPut: $>! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:57'!visitReturnNode: aReturnNode 	codeStream		nextPut: $^;		nextPutAll: StringFollowingReturn.	self visitNode: aReturnNode value! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:57'!visitSequenceNode: aSequenceNode 	self formatTemporariesFor: aSequenceNode.	self formatSequenceCommentsFor: aSequenceNode.	self formatSequenceNodeStatementsFor: aSequenceNode! !!RBConfigurableFormatter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 15:57'!visitVariableNode: aVariableNode 	codeStream nextPutAll: aVariableNode name! !!RBConfigurableFormatter methodsFor: 'private'!addNewLinesBeforeStatementStartingAt: anInteger 	| newLines |	newLines := MinimumNewLinesBetweenStatements 				max: (RetainBlankLinesBetweenStatements 						ifTrue: [self newLinesBeforeStartingAt: anInteger]						ifFalse: [0]).	newLines = 0 ifTrue: [self space] ifFalse: [self newLines: newLines]! !!RBConfigurableFormatter methodsFor: 'private'!bracketWith: bracketString around: aBlock 	bracketString isEmpty ifTrue: [^aBlock value].	codeStream nextPut: bracketString first.	^aBlock ensure: [codeStream nextPut: bracketString last]! !!RBConfigurableFormatter methodsFor: 'private'!currentLineLength	^codeStream position - lineStart! !!RBConfigurableFormatter methodsFor: 'private'!formatTemporariesFor: aSequenceNode	aSequenceNode temporaries isEmpty ifTrue: [^self].	self		bracketWith: '|'		around:			[self space.			aSequenceNode temporaries				do:					[:each | 					self visitNode: each.					FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].					self space]].	self newLines: NewLinesAfterTemporaries! !!RBConfigurableFormatter methodsFor: 'private'!formattedSourceFor: aNode 	^lookaheadCode at: aNode		ifAbsentPut: [self class format: aNode withIndents: indent]! !!RBConfigurableFormatter methodsFor: 'private'!indent: anInteger around: aBlock 	indent := indent + anInteger.	^aBlock ensure: [indent := indent - anInteger]! !!RBConfigurableFormatter methodsFor: 'private'!indentAround: aBlock 	self indent: 1 around: aBlock! !!RBConfigurableFormatter methodsFor: 'private' stamp: 'lr 11/22/2009 17:17'!isLineTooLong: aString 	^ self currentLineLength + (aString indexOf: Character cr ifAbsent: [ aString size ]) >= MaxLineLength! !!RBConfigurableFormatter methodsFor: 'private' stamp: 'CamilloBruni 10/31/2012 17:11'!needsParenthesisFor: aNode 	| parent grandparent |	aNode ifNil: [ ^ false ].	aNode isValue ifFalse: [ ^ false ].	parent := aNode parent ifNil: [ ^ false ].	(CascadedMessageInsideParentheses and: [ aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ] ]) ifTrue: [		grandparent := parent parent.		(grandparent notNil and: [ grandparent isCascade ])			ifTrue: [ ^ true ] ].	(aNode precedence < parent precedence) ifTrue: [ ^ false ].	(aNode isAssignment and: [ parent isAssignment ]) ifTrue: [ ^ false ].	(aNode isAssignment and: [ aNode isCascade ]) ifTrue: [ ^ true ].	(aNode precedence = 0) ifTrue: [ ^ false ].	(aNode isMessage) ifFalse: [ ^ true ].	(aNode precedence = parent precedence) ifFalse: [ ^ true ].	(aNode isUnary) ifTrue: [ ^ false ].	(aNode isKeyword) ifTrue: [ ^ true ].	(parent receiver == aNode) ifFalse: [ ^ true ].	^ UseTraditionalBinaryPrecedenceForParentheses and: [ self precedenceOf: parent selector greaterThan: aNode selector ]! !!RBConfigurableFormatter methodsFor: 'private'!newLine	self newLines: 1! !!RBConfigurableFormatter methodsFor: 'private'!newLines: anInteger 	anInteger + IndentString size = 0 ifTrue: [codeStream space].	anInteger timesRepeat: [codeStream cr].	lineStart := codeStream position.	indent timesRepeat: [codeStream nextPutAll: IndentString]! !!RBConfigurableFormatter methodsFor: 'private' stamp: 'PeterUhnak 11/5/2014 09:47'!newLinesBeforeStartingAt: anIndex 	| count cr lf index char |	originalSource ifNil: [^0].	(anIndex isNil or: [anIndex > originalSource size]) ifTrue: [^0].	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index > 0 and: [(char := originalSource at: index) isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(originalSource at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count! !!RBConfigurableFormatter methodsFor: 'private'!precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"	| childIndex parentIndex |	childIndex := 0.	parentIndex := 0.	1 to: TraditionalBinaryPrecedence size		do: 			[:i | 			((TraditionalBinaryPrecedence at: i) includes: parentSelector first) 				ifTrue: [parentIndex := i].			((TraditionalBinaryPrecedence at: i) includes: childSelector first) 				ifTrue: [childIndex := i]].	^childIndex < parentIndex! !!RBConfigurableFormatter methodsFor: 'private'!space	codeStream space! !!RBConfigurableFormatter methodsFor: 'private'!willBeMultiline: aNode 	^(self formattedSourceFor: aNode) includes: Character cr! !!RBConfigurableFormatter methodsFor: 'private'!writeString: aString 	| index |	index := aString lastIndexOf: Character cr ifAbsent: [0].	codeStream nextPutAll: aString.	index > 0 		ifTrue: [lineStart := codeStream position - (aString size - index)]! !!RBConfigurableFormatter methodsFor: 'initialization'!initialize	super initialize.	lineStart := 0.	indent := 0.	lookaheadCode := IdentityDictionary new.	codeStream := WriteStream on: (String new: 256)! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 11/2/2009 09:31'!formatArray: anArrayNode	self formatSequenceCommentsFor: anArrayNode.	self formatSequenceNodeStatementsFor: anArrayNode! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 2/28/2010 21:54'!formatBlock: aBlockNode	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])		ifTrue: [ self newLine ]		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ].	self formatBlockArgumentsFor: aBlockNode.	(self willBeMultiline: aBlockNode body)		ifTrue: [ self newLine ].	self visitNode: aBlockNode body.	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])		ifTrue: [ self newLine ]		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 2/28/2010 21:59'!formatBlockArgumentsFor: aBlockNode	aBlockNode arguments isEmpty		ifTrue: [ ^ self ].	aBlockNode arguments		do: [ :each | 			codeStream nextPut: $:.			self visitNode: each.			FormatCommentWithStatements				ifTrue: [ self formatCommentsFor: each ].			self space ].	codeStream nextPutAll: '| '! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 11/7/2013 11:12'!formatCommentsFor: aNode 	originalSource isNil ifTrue: [^self].	aNode comments do: 			[:each | 			codeStream				space;				nextPutAll: (originalSource copyFrom: each start to: each stop)]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 11/2/2009 09:22'!formatMethodBodyFor: aMethodNode 	self		indentAround: 			[self newLines: NewLinesAfterMethodPattern.			self formatMethodCommentFor: aMethodNode.			self formatPragmasFor: aMethodNode.			self visitNode: aMethodNode body]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 11/7/2013 11:12'!formatMethodCommentFor: aMethodNode	originalSource isNil ifTrue: [^self].	(FormatCommentWithStatements		ifTrue: [aMethodNode methodComments]		ifFalse: [aMethodNode comments])		do:			[:each | 			codeStream				nextPutAll:					(originalSource						copyFrom: each start						to: each stop).			self newLines: NewLinesAfterMethodComment]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 10/22/2013 14:02'!formatMethodPatternFor: aMethodNode 	aMethodNode arguments isEmpty		ifTrue: [codeStream nextPutAll: aMethodNode selector]		ifFalse: 			[self				with: aMethodNode selectorParts				and: aMethodNode arguments				do: 					[:key :arg | 					codeStream nextPutAll: key.					self space.					self visitNode: arg]				separatedBy: 					[MethodSignatureOnMultipleLines						ifTrue: [self newLine]						ifFalse: [self space]]]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 11/2/2009 10:09'!formatPragmasFor: aMethodNode	aMethodNode pragmas do: [ :each | self visitNode: each; newLine ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'lr 2/28/2010 22:17'!formatSelectorAndArguments: aMessageNode	| newLineBetweenArguments |	newLineBetweenArguments := self isMultiLineMessage: aMessageNode.	self		indent:			(newLineBetweenArguments				ifTrue: [ IndentsForKeywords ]				ifFalse: [ 0 ])		around: [ 			self				formatSelectorAndArguments: aMessageNode				firstSeparator:					((newLineBetweenArguments or: [ NewLineBeforeFirstKeyword ])						ifTrue: [ [ self newLine ] ]						ifFalse: [ [ self space ] ])				restSeparator:					(newLineBetweenArguments						ifTrue: [ [ self newLine ] ]						ifFalse: [ [ self space ] ]) ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 10/22/2013 14:02'!formatSelectorAndArguments: aMessageNode firstSeparator: firstBlock restSeparator: restBlock	| separatorBlock |	separatorBlock := firstBlock.	aMessageNode isUnary		ifTrue: [ self handleLineForSelector: aMessageNode selector withSeparatorBlock: separatorBlock.				codeStream nextPutAll: aMessageNode selector ]		ifFalse: [ 			aMessageNode selectorParts				with: aMessageNode arguments				do: [ :selector :argument | 					self handleLineForSelector:  selector withSeparatorBlock: separatorBlock.					separatorBlock := restBlock.					self						indentAround: [ 							codeStream nextPutAll: selector.							(KeepBlockInMessage and: [ argument isBlock ])								ifTrue: [ 									self										space;										visitNode: argument ]								ifFalse: [ 									((self willBeMultiline: argument) or: [ self isLineTooLong: (self formattedSourceFor: argument) ])										ifTrue: [ self newLine ]										ifFalse: [ self space ].									self visitNode: argument ] ] ] ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 11/7/2013 11:12'!formatSequenceCommentsFor: aSequenceNode	originalSource isNil ifTrue: [^self].	aSequenceNode comments		do:			[:each | 			codeStream				nextPutAll:					(originalSource						copyFrom: each start						to: each stop).			self newLine]! !!RBConfigurableFormatter methodsFor: 'private-formatting'!formatSequenceNodeStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size		do: 			[:i | 			self visitNode: (statements at: i).			(i < statements size or: 					[aSequenceNode parent ifNil: [self class periodsAsTerminators]						ifNotNil: 							[:parent | 							parent isBlock 								ifTrue: [self class periodsAtEndOfBlock]								ifFalse: [self class periodsAtEndOfMethod]]]) 				ifTrue: [codeStream nextPut: $.].			self formatStatementCommentsFor: (statements at: i).			i < statements size 				ifTrue: 					[self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 1/5/2015 10:08'!formatStatementCommentsFor: aStatementNode	originalSource isNil		ifTrue: [ ^ self ].	FormatCommentWithStatements		ifFalse: [ ^ self ].	aStatementNode statementComments		do: [ :each | 			| count |			count := self newLinesBeforeStartingAt: each start.			RetainBlankLinesBeforeComments & (count > 0)				ifTrue: [ self newLines: count ]				ifFalse: [ codeStream tab ].			codeStream nextPutAll: (originalSource copyFrom: each start to: each stop) ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'StephaneDucasse 3/29/2013 17:23'!handleLineForSelector: selector withSeparatorBlock: aBlock	^ (self isLineTooLong: selector)		ifTrue: [ self newLine ]		ifFalse: [ aBlock value ]! !!RBConfigurableFormatter methodsFor: 'private-formatting' stamp: 'PabloHerrero 10/22/2013 14:02'!isMultiLineMessage: aMessageNode	| messageStream |	(MultiLineMessages includes: aMessageNode selector)		ifTrue: [ ^ true ].	(OneLineMessages includes: aMessageNode selector)		ifTrue: [ ^ false ].	(NumberOfArgumentsForMultiLine <= aMessageNode arguments size)		ifTrue: [ ^ true ].	(aMessageNode arguments 		anySatisfy: [ :each | self indent: IndentsForKeywords + 1 around: [ self willBeMultiline: each ] ]) 		ifTrue: [ ^ true ].	aMessageNode isUnary		ifTrue: [ ^ self isLineTooLong: aMessageNode selector ].	messageStream := WriteStream on: (String new: 100).	self  with: aMessageNode selectorParts and: aMessageNode arguments 		do: [ :selector :arg | messageStream nextPutAll: selector; space; nextPutAll: (self formattedSourceFor: arg) ]		separatedBy: [ messageStream space ].	^ self isLineTooLong: messageStream contents! !!RBConfigurableFormatter methodsFor: 'public interface'!format: aParseTree 	originalSource := aParseTree source.	self visitNode: aParseTree.	^codeStream contents! !!RBConfigurableFormatter methodsFor: 'utility'!with: firstCollection and: secondCollection do: aBlock separatedBy: separatorBlock 	firstCollection isEmpty ifTrue: [^self].	aBlock		value: firstCollection first		value: secondCollection first.	2		to: firstCollection size		do: 			[:i | 			separatorBlock value.			aBlock				value: (firstCollection at: i)				value: (secondCollection at: i)]! !!RBConfigurableFormatter methodsFor: 'initialize-release'!indent: anInteger	indent := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 7/25/2011 20:53'!cascadedMessageInsideParentheses	^ CascadedMessageInsideParentheses! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 7/25/2011 20:53'!cascadedMessageInsideParentheses: aBoolean	CascadedMessageInsideParentheses := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!formatCommentWithStatements	^ FormatCommentWithStatements! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!formatCommentWithStatements: aBoolean	FormatCommentWithStatements := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnAccept	^FormatOnAccept ifNil:[false]! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:45'!formatOnAccept:aBoolean	FormatOnAccept :=aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnDisplay	^FormatOnDisplay ifNil:[false]! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnDisplay:aBoolean	FormatOnDisplay :=aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!indentString	^ IndentString! !!RBConfigurableFormatter class methodsFor: 'accessing'!indentString: aString	IndentString := aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!indentsForKeywords	^ IndentsForKeywords! !!RBConfigurableFormatter class methodsFor: 'accessing'!indentsForKeywords: anInteger	IndentsForKeywords := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 2/28/2010 21:49'!keepBlockInMessage	^ KeepBlockInMessage! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 2/28/2010 21:50'!keepBlockInMessage: aBoolean	KeepBlockInMessage := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!lineUpBlockBrackets	^ LineUpBlockBrackets! !!RBConfigurableFormatter class methodsFor: 'accessing'!lineUpBlockBrackets: aBoolean	LineUpBlockBrackets := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!maxLineLength	^ MaxLineLength! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!maxLineLength: anInteger	MaxLineLength := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!methodSignatureOnMultipleLines	^ MethodSignatureOnMultipleLines! !!RBConfigurableFormatter class methodsFor: 'accessing'!methodSignatureOnMultipleLines: aBoolean	MethodSignatureOnMultipleLines := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!minimumNewLinesBetweenStatements	^ MinimumNewLinesBetweenStatements! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!minimumNewLinesBetweenStatements: anInteger	MinimumNewLinesBetweenStatements := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 9/11/2010 17:20'!multiLineMessages	^ MultiLineMessages printString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'MarcusDenker 4/30/2013 11:21'!multiLineMessages: aString	MultiLineMessages := self compiler evaluate: aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLineAfterCascade	^ NewLineAfterCascade! !!RBConfigurableFormatter class methodsFor: 'accessing'!newLineAfterCascade: aBoolean	NewLineAfterCascade := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLineBeforeFirstCascade	^ NewLineBeforeFirstCascade! !!RBConfigurableFormatter class methodsFor: 'accessing'!newLineBeforeFirstCascade: aBoolean	NewLineBeforeFirstCascade := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLineBeforeFirstKeyword	^ NewLineBeforeFirstKeyword! !!RBConfigurableFormatter class methodsFor: 'accessing'!newLineBeforeFirstKeyword: aBoolean	NewLineBeforeFirstKeyword := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLinesAfterMethodComment	^ NewLinesAfterMethodComment! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLinesAfterMethodComment: anInteger	NewLinesAfterMethodComment := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLinesAfterMethodPattern	^ NewLinesAfterMethodPattern! !!RBConfigurableFormatter class methodsFor: 'accessing'!newLinesAfterMethodPattern: anInteger	NewLinesAfterMethodPattern := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!newLinesAfterTemporaries	^ NewLinesAfterTemporaries! !!RBConfigurableFormatter class methodsFor: 'accessing'!newLinesAfterTemporaries: anInteger	NewLinesAfterTemporaries := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!numberOfArgumentsForMultiLine	^ NumberOfArgumentsForMultiLine! !!RBConfigurableFormatter class methodsFor: 'accessing'!numberOfArgumentsForMultiLine: anInteger	NumberOfArgumentsForMultiLine := anInteger! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 9/11/2010 17:20'!oneLineMessages	^ OneLineMessages printString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'MarcusDenker 4/30/2013 11:20'!oneLineMessages: aString	OneLineMessages := self compiler evaluate: aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAsTerminators	^ PeriodsAtEndOfBlock and: [ PeriodsAtEndOfMethod ]! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAsTerminators: aBoolean	PeriodsAtEndOfBlock := aBoolean.	PeriodsAtEndOfMethod := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAtEndOfBlock	^ PeriodsAtEndOfBlock! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAtEndOfBlock: aBoolean	PeriodsAtEndOfBlock := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAtEndOfMethod	^ PeriodsAtEndOfMethod! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!periodsAtEndOfMethod: aBoolean	PeriodsAtEndOfMethod := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PeterUhnak 8/21/2014 21:13'!retainBlankLinesBeforeComments	^ RetainBlankLinesBeforeComments! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PeterUhnak 8/21/2014 21:13'!retainBlankLinesBeforeComments: aBoolean	RetainBlankLinesBeforeComments := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!retainBlankLinesBetweenStatements	^ RetainBlankLinesBetweenStatements! !!RBConfigurableFormatter class methodsFor: 'accessing'!retainBlankLinesBetweenStatements: aBoolean	RetainBlankLinesBetweenStatements := aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!stringFollowingReturn	^ StringFollowingReturn! !!RBConfigurableFormatter class methodsFor: 'accessing'!stringFollowingReturn: aString	StringFollowingReturn := aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!stringInsideBlocks	^ StringInsideBlocks! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!stringInsideBlocks: aString	StringInsideBlocks := aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!stringInsideParentheses	^ StringInsideParentheses! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!stringInsideParentheses: aString	StringInsideParentheses := aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 9/11/2010 17:20'!traditionalBinaryPrecedence	^ TraditionalBinaryPrecedence printString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'MarcusDenker 4/30/2013 11:22'!traditionalBinaryPrecedence: aString	TraditionalBinaryPrecedence := self compiler evaluate: aString! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!useTraditionalBinaryPrecedenceForParentheses	^ UseTraditionalBinaryPrecedenceForParentheses! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'lr 12/27/2009 13:35'!useTraditionalBinaryPrecedenceForParentheses: aBoolean	UseTraditionalBinaryPrecedenceForParentheses := aBoolean! !!RBConfigurableFormatter class methodsFor: 'public'!format: aParseTree 	^self format: aParseTree withIndents: 0! !!RBConfigurableFormatter class methodsFor: 'public' stamp: 'lr 12/27/2009 13:05'!format: aParseTree withIndents: anInteger 	^ self new		indent: anInteger;		format: aParseTree! !!RBConfigurableFormatter class methodsFor: 'initialization' stamp: 'PaulDeBruicker 6/10/2015 13:45'!initialize	CascadedMessageInsideParentheses := false.	FormatCommentWithStatements := true.	IndentString := String with: Character tab.	IndentsForKeywords := 1.	KeepBlockInMessage := true.	LineUpBlockBrackets := false.	MaxLineLength := 120.	MethodSignatureOnMultipleLines := false.	MinimumNewLinesBetweenStatements := 1.	MultiLineMessages := #(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse: #on:do: #ensure: #ifCurtailed:).	NewLineAfterCascade := true.	NewLineBeforeFirstCascade := true.	NewLineBeforeFirstKeyword := false.	NewLinesAfterMethodComment := 2.	NewLinesAfterMethodPattern := 1.	NewLinesAfterTemporaries := 1.	NumberOfArgumentsForMultiLine := 4.	OneLineMessages := #(#to: #to:do: #to:by: #to:by:do:).	PeriodsAtEndOfBlock := false.	PeriodsAtEndOfMethod := false.	RetainBlankLinesBetweenStatements := false.	RetainBlankLinesBeforeComments := false.	StringFollowingReturn := ' '.	StringInsideBlocks := ' '.	StringInsideParentheses := ''.	TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	UseTraditionalBinaryPrecedenceForParentheses := true.	FormatOnAccept := false.	FormatOnDisplay := false! !!RBConfigurableFormatter class methodsFor: 'settings' stamp: 'PaulDeBruicker 6/10/2015 13:46'!settingsOn: aBuilder	<systemsettings>	(aBuilder group: #configurableFormatter)		target: self;		parent: #codeBrowsing;		label: 'Pretty Printing';		description: 'Settings related to the formatter';		with: [ 					(aBuilder setting: #cascadedMessageInsideParentheses) label: 'Cascaded message inside parentheses'.					(aBuilder setting: #formatCommentWithStatements) label: 'Format comment with statements'.					(aBuilder setting: #indentString) label: 'Indent string'.					(aBuilder setting: #indentsForKeywords) label: 'Indents for keywords'.					(aBuilder setting: #keepBlockInMessage) label: 'Keep block in message'.					(aBuilder setting: #lineUpBlockBrackets) label: 'Line up block brackets'.					(aBuilder setting: #methodSignatureOnMultipleLines) label: 'Method signature on multiple lines'.					(aBuilder setting: #maxLineLength) label: 'Max line length'.					(aBuilder setting: #oneLineMessages) label: 'One line messages'.					(aBuilder setting: #multiLineMessages) label: 'Multi line messages'.					(aBuilder setting: #minimumNewLinesBetweenStatements) label: 'Minimum new lines between statements'.					(aBuilder setting: #newLineAfterCascade) label: 'New line after cascade'.					(aBuilder setting: #newLineBeforeFirstCascade) label: 'New line before first cascade'.					(aBuilder setting: #newLineBeforeFirstKeyword) label: 'New line before first keyword'.					(aBuilder setting: #newLinesAfterMethodComment) label: 'New lines after method comment'.					(aBuilder setting: #newLinesAfterMethodPattern) label: 'New lines after method pattern'.					(aBuilder setting: #newLinesAfterTemporaries) label: 'New lines after temporaries'.					(aBuilder setting: #numberOfArgumentsForMultiLine) label: 'Number of arguments for multi line'.					(aBuilder setting: #periodsAsTerminators) label: 'Periods as terminators'.					(aBuilder setting: #periodsAtEndOfBlock) label: 'Periods at end of block'.					(aBuilder setting: #periodsAtEndOfMethod) label: 'Periods at end of method'.					(aBuilder setting: #retainBlankLinesBetweenStatements) label: 'Retain blank lines between statements'.					(aBuilder setting: #retainBlankLinesBeforeComments) label: 'Retain blank lines before comments'.					(aBuilder setting: #stringFollowingReturn) label: 'String following return'.					(aBuilder setting: #stringInsideBlocks) label: 'String inside blocks'.					(aBuilder setting: #stringInsideParentheses) label: 'String inside parentheses'.					(aBuilder setting: #traditionalBinaryPrecedence) label: 'Traditional binary precedence'.					(aBuilder setting: #useTraditionalBinaryPrecedenceForParentheses)						label: 'Use traditional binary precedence for parentheses'.					(aBuilder setting: #formatOnDisplay) label: 'Format methods on display'.					(aBuilder setting: #formatOnAccept) label: 'Format methods on accept' ]! !!RBFindBlockArgumentAssignment methodsFor: 'initialization' stamp: 'NicolaiHess 8/23/2014 21:20'!initialize	super initialize.	arguments := Set new.	argumentAssignments := Set new.! !!RBFindBlockArgumentAssignment methodsFor: 'accessing' stamp: 'NicolaiHess 8/23/2014 21:20'!assignments	^  argumentAssignments! !!RBFindBlockArgumentAssignment methodsFor: 'visiting' stamp: 'NicolaiHess 8/23/2014 21:20'!executeTree: aParseTree	^ self visitNode: aParseTree! !!RBFindBlockArgumentAssignment methodsFor: 'visiting' stamp: 'NicolaiHess 10/8/2014 23:44'!visitArgumentNode: anArgumentNode	"register argument node if it is an block argument"	anArgumentNode parent isBlock		ifTrue: [ arguments add: anArgumentNode ]! !!RBFindBlockArgumentAssignment methodsFor: 'visiting' stamp: 'NicolaiHess 10/10/2014 00:31'!visitAssignmentNode: anAssignmentNode	"search registered argument variable with the same name and scope"	| varName |	super visitAssignmentNode: anAssignmentNode.	varName := anAssignmentNode variable name.	arguments		detect: [ :elem | elem name = varName and: [ self is: anAssignmentNode variable inScopeOf: elem ] ]		ifFound: [ argumentAssignments add: varName ]! !!RBFindBlockArgumentAssignment methodsFor: 'visiting' stamp: 'NicolaiHess 8/23/2014 21:20'!visitTemporaryNodes: aNodeCollection	"here our trait calls visitArgumentNodes: but we are not interested on temporary nodes -> ignore this."	! !!RBFindBlockArgumentAssignment methodsFor: 'private' stamp: 'NicolaiHess 10/10/2014 00:30'!is: aVar inScopeOf: anArgumentNode	"if this Var is a child of if anArgumentNode parent, then theassignment on aVar happens in scope of the BlockNode of this ArgumentNode "	| parent |	parent := aVar parent.	[ parent notNil ]		whileTrue: [ 			parent = anArgumentNode parent				ifTrue: [ ^ true ].			parent := parent parent ].	^ false! !!RBFindBlockArgumentAssignment class methodsFor: 'accessing' stamp: 'NicolaiHess 8/23/2014 21:21'!collectAssignments: aParseTree	^ (self new executeTree: aParseTree) assignments! !!RBParseTreeSearcher methodsFor: 'initialization' stamp: 'jws 10/29/2016 09:16'!initialize	super initialize.	context := Dictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil! !!RBParseTreeSearcher methodsFor: 'searching'!matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!RBParseTreeSearcher methodsFor: 'searching'!matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]! !!RBParseTreeSearcher methodsFor: 'searching'!matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]! !!RBParseTreeSearcher methodsFor: 'searching'!matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]! !!RBParseTreeSearcher methodsFor: 'searching'!matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]! !!RBParseTreeSearcher methodsFor: 'searching'!matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!RBParseTreeSearcher methodsFor: 'searching'!matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!RBParseTreeSearcher methodsFor: 'searching'!matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)! !!RBParseTreeSearcher methodsFor: 'searching'!matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!RBParseTreeSearcher methodsFor: 'visiting' stamp: 'CamilleTeruel 4/3/2013 16:22'!visitArgumentNode: aNode	| value |	value := self performSearches: argumentSearches on: aNode.	^ value		ifNil: [ 			super visitArgumentNode: aNode.			aNode ]		ifNotNil: [ value ]! !!RBParseTreeSearcher methodsFor: 'visiting' stamp: 'CamilleTeruel 4/3/2013 16:23'!visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^ value		ifNil: [ 			super visitNode: aNode.			aNode ]		ifNotNil: [ value ]! !!RBParseTreeSearcher methodsFor: 'private'!foundMatch! !!RBParseTreeSearcher methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]! !!RBParseTreeSearcher methodsFor: 'private' stamp: 'CamilloBruni 12/15/2011 15:28'!performSearches: aSearchCollection on: aNode 	| value |	aSearchCollection do: [ :aSearchRule|		value := aSearchRule performOn: aNode.		value notNil 			ifTrue: 				[self foundMatch.				^value]].	^nil! !!RBParseTreeSearcher methodsFor: 'private' stamp: 'jws 10/29/2016 09:16'!recusivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := Dictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext! !!RBParseTreeSearcher methodsFor: 'initialize-release'!answer: anObject	answer := anObject! !!RBParseTreeSearcher methodsFor: 'accessing'!addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self! !!RBParseTreeSearcher methodsFor: 'accessing'!addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]! !!RBParseTreeSearcher methodsFor: 'accessing'!addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self! !!RBParseTreeSearcher methodsFor: 'accessing'!addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]! !!RBParseTreeSearcher methodsFor: 'accessing'!answer	^answer! !!RBParseTreeSearcher methodsFor: 'accessing'!context	^context! !!RBParseTreeSearcher methodsFor: 'accessing'!executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer! !!RBParseTreeSearcher methodsFor: 'accessing' stamp: 'jws 10/29/2016 09:16'!executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := Dictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer! !!RBParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree! !!RBParseTreeSearcher methodsFor: 'accessing'!messages	messages notNil ifTrue: [^messages].	argumentSearches notEmpty ifTrue: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray! !!RBParseTreeSearcher methodsFor: 'testing' stamp: 'lr 1/3/2010 11:48'!canMatchMethod: aCompiledMethod	| actualMessages |	self messages isEmpty		ifTrue: [ ^ true ].	actualMessages := aCompiledMethod messages.	^ self messages 		anySatisfy: [ :each | actualMessages includes: each ]! !!RBParseTreeSearcher methodsFor: 'testing'!hasRules	^searches notEmpty! !!RBParseTreeRewriter methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:29'!visitArgumentNodes: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgumentNode: each]! !!RBParseTreeRewriter methodsFor: 'private'!foundMatch	answer := true! !!RBParseTreeRewriter methodsFor: 'private' stamp: 'CamilloBruni 8/31/2013 20:51'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: [:key :value | 		(key isString not and: [key recurseInto]) 			ifTrue: 				[oldContext at: key put: (value collect: [:each | self visitNode: each])]]! !!RBParseTreeRewriter methodsFor: 'accessing' stamp: 'jws 10/29/2016 09:16'!executeTree: aParseTree 	| oldContext |	oldContext := context.	context := Dictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer! !!RBParseTreeRewriter methodsFor: 'accessing'!tree	^tree! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:30'!visitArrayNode: anArrayNode	anArrayNode statements: (anArrayNode statements collect: [:each | self visitNode: each])! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitBlockNode: aBlockNode 	aBlockNode arguments: (self visitArgumentNodes: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:28'!visitCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								show: 'Cannot replace message node inside of cascaded node with non-message node.';								cr.							newMessages add: each]]].	notFound size = aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitLiteralArrayNode: aRBArrayLiteralNode	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents collect: [ :each | self visitNode: each ])! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitMessageNode: aMessageNode	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode arguments: (aMessageNode arguments collect: [ :each | self visitNode: each ])! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitMethodNode: aMethodNode	aMethodNode arguments: (self visitArgumentNodes: aMethodNode arguments).	aMethodNode pragmas: (aMethodNode pragmas collect: [ :each | self visitNode: each ]).	aMethodNode body: (self visitNode: aMethodNode body)! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:32'!visitPragmaNode: aPragmaNode	aPragmaNode arguments: (aPragmaNode arguments collect: [ :each | self visitNode: each ])! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:29'!visitReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)! !!RBParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'StephaneDucasse 3/29/2013 16:31'!visitSequenceNode: aSequenceNode	aSequenceNode temporaries: (self visitTemporaryNodes: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [ :each | self visitNode: each ])! !!RBParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!RBParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)! !!RBParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)! !!RBParseTreeSearcher class methodsFor: 'accessing'!treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil! !!RBParseTreeSearcher class methodsFor: 'accessing'!treeMatchingStatements: aString in: aParseTree 	| notifier tree |	notifier := self new.	tree := RBParser parseExpression: aString.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].	notifier matchesTree: tree		do: [:aNode :answer | ^RBParser parseExpression: aString].	notifier executeTree: aParseTree.	^nil! !!RBParseTreeSearcher class methodsFor: 'private'!buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!RBParseTreeSearcher class methodsFor: 'private'!buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]! !!RBParseTreeSearcher class methodsFor: 'private'!buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]! !!RBParseTreeSearcher class methodsFor: 'instance creation'!getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself! !!RBParseTreeSearcher class methodsFor: 'instance creation' stamp: 'lr 11/4/2009 11:44'!justSendsSuper	^ self new		matchesAnyMethodOf: #(			'`@method: `@args ^ super `@method: `@args' 			'`@method: `@args super `@method: `@args')		do: [ :node :answer | true ];		yourself! !!RBParseTreeSearcher class methodsFor: 'instance creation'!returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself! !!RBParseTreeSearcher class methodsFor: 'instance creation'!setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself! !!RBParseTreeRewriter class methodsFor: 'instance creation'!removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'instance creation'!replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'instance creation'!replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule replaceTree: (RBLiteralNode value: literal)		withTree: (RBLiteralNode value: newLiteral).	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'instance creation' stamp: 'lr 11/23/2009 14:27'!variable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self'! !!RBParseTreeRewriter class methodsFor: 'instance creation' stamp: 'lr 11/23/2009 14:27'!variable: aVarName getter: getMethod setter: setMethod receiver: aString 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: aString , ' ' , setMethod , ' ``@object';		replace: aVarName with: aString , ' ' , getMethod.	^rewriteRule! !!RBParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree! !!RBParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree! !!RBParseTreeRewriter class methodsFor: 'accessing'!replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree replaceStmt |	tree := self buildTree: code method: false.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]		ifFalse: 			[tree addNode: (RBPatternVariableNode named: '`@.S2').			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].	^self 		replace: tree formattedCode		with: replaceStmt		in: aParseTree		onInterval: anInterval! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'TestRunner 11/3/2009 09:10'!copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [ :key :value | newDictionary at: key put: value ].	^ newDictionary! !!RBReadBeforeWrittenTester methodsFor: 'private'!createScope	scopeStack add: (self copyDictionary: scopeStack last)! !!RBReadBeforeWrittenTester methodsFor: 'private'!currentScope	^scopeStack last! !!RBReadBeforeWrittenTester methodsFor: 'private'!processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!removeScope	^scopeStack removeLast! !!RBReadBeforeWrittenTester methodsFor: 'private'!variableRead: aNode 	(self currentScope includesKey: aNode name) 		ifTrue: 			[(self currentScope at: aNode name) isNil 				ifTrue: [self currentScope at: aNode name put: true]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!variableWritten: aNode 	(self currentScope includesKey: aNode variable name) 		ifTrue: 			[(self currentScope at: aNode variable name) isNil 				ifTrue: [self currentScope at: aNode variable name put: false]]! !!RBReadBeforeWrittenTester methodsFor: 'accessing'!executeTree: aParseTree 	^self visitNode: aParseTree! !!RBReadBeforeWrittenTester methodsFor: 'accessing'!read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!checkNewTemps: aBoolean 	checkNewTemps := aBoolean! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]! !!RBReadBeforeWrittenTester methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:04'!visitAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode! !!RBReadBeforeWrittenTester methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:04'!visitBlockNode: aBlockNode 	self processBlock: aBlockNode! !!RBReadBeforeWrittenTester methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:04'!visitMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBReadBeforeWrittenTester methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:04'!visitSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode! !!RBReadBeforeWrittenTester methodsFor: 'visiting' stamp: 'StephaneDucasse 3/29/2013 16:05'!visitVariableNode: aVariableNode 	self variableRead: aVariableNode! !!RBReadBeforeWrittenTester methodsFor: 'initialization'!initialize	super initialize.	scopeStack := OrderedCollection with: Dictionary new.	read := Set new.	checkNewTemps := true! !!RBReadBeforeWrittenTester class methodsFor: 'accessing'!isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not! !!RBReadBeforeWrittenTester class methodsFor: 'accessing'!isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty! !!RBReadBeforeWrittenTester class methodsFor: 'accessing'!readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing'!variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!checkForValidTemporaryVariable	| parseTree |	parseTree := class parseTreeFor: selector.	(parseTree allTemporaryVariables includes: temporaryVariableName) 		ifFalse: 			[self refactoringError: temporaryVariableName 						, ' isn''t a valid temporary variable name'].	(parseTree allArgumentVariables includes: temporaryVariableName) 		ifTrue: 			[self refactoringError: temporaryVariableName , ' is a block parameter'].	(RBReadBeforeWrittenTester isVariable: temporaryVariableName		readBeforeWrittenIn: parseTree) 			ifTrue: 				[self 					refactoringWarning: ('<1s> is read before it is written.<n>Proceed anyway?' 							expandMacrosWith: temporaryVariableName)]! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition hierarchyOf: class				definesVariable: temporaryVariableName asString) not 			& (RBCondition withBlock: 						[self checkForValidTemporaryVariable.						true])! !!TemporaryToInstanceVariableRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector variable: aVariableName 	class := self classObjectFor: aClass.	selector := aSelector.	temporaryVariableName := aVariableName! !!TemporaryToInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' variable: ''';		nextPutAll: temporaryVariableName;		nextPut: $'.	aStream nextPut: $)! !!TemporaryToInstanceVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!transform	| parseTree matcher protocols |	parseTree := class parseTreeFor: selector.	parseTree isNil		ifTrue: [ self refactoringError: 'Could not parse method' ].	protocols := class protocolsFor: selector.	class removeMethod: selector.	class addInstanceVariable: temporaryVariableName.	(matcher := ParseTreeRewriter removeTemporaryNamed: temporaryVariableName) executeTree: parseTree.	class compileTree: matcher tree classified: protocols! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!class: aClass selector: aSelector variable: aVariableName 	^self new 		class: aClass		selector: aSelector		variable: aVariableName! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: aClass selector: aSelector variable: aVariableName 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			variable: aVariableName;		yourself! !!TemporaryToInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass:					variable: 'asdf');		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass1:					variable: 'aSmalllintContext')! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testRedefinedTemporary	| class |	class := model classNamed: #Foo.	class 		compile: 'someMethod | instVarName1 | instVarName1 := 4. ^instVarName1'		classified: #(#accessing).	self shouldFail: (TemporaryToInstanceVariableRefactoring 				class: class				selector: #someMethod				variable: 'instVarName1')! !!TemporaryToInstanceVariableTest methodsFor: 'tests'!testTemporaryToInstanceVariable	| refactoring class |	refactoring := TemporaryToInstanceVariableRefactoring 				class: LintRuleTest				selector: #displayName				variable: 'nameStream'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName								nameStream := WriteStream on: (String new: 64).								nameStream									nextPutAll: self name;									nextPutAll: '' (''.								self problemCount printOn: nameStream.								nameStream nextPut: $).								^nameStream contents').	self assert: (class directlyDefinesInstanceVariable: 'nameStream')! !!Trait methodsFor: '*RefactoringEngine' stamp: 'md 3/14/2006 16:44'!includesBehavior: aClass	^false! !!TransformationRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:10'!changes	^builder changes! !!TransformationRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(rewriteRule canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(self class recursiveSelfRule executeTree: rewriteRule tree				initialAnswer: false) 					ifFalse: 						[builder 							compile: rewriteRule tree printString							in: class							classified: aSmalllintContext protocol]]! !!TransformationRule methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRule methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange named: 'Some transformations'! !!TransformationRule methodsFor: 'testing'!hasConflicts	^true! !!TransformationRule methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRule methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRule methodsFor: 'rules' stamp: 'jws 10/23/2016 05:38'!superSends	| rule |	rule := ParseTreeRewriter new.	rule		replace: 'super `@message: ``@args'		with: 'self `@message: ``@args'		when: [ :aNode | (class withAllSubclasses detect: [ :each | each includesSelector: aNode selector ] ifNone: [ nil ]) isNil ].	self rewriteUsing: rule! !!TransformationRule methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!TransformationRule class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRule class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRule class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRule class methodsFor: 'transformations'!cascadedNextPutAlls	^self		rewrite: #(			#('``@rcvr nextPutAll: ``@object1 , ``@object2'					"->"				'``@rcvr nextPutAll: ``@object1; nextPutAll: ``@object2')			#('``@rcvr show: ``@object1 , ``@object2'					"->"				'``@rcvr show: ``@object1; show: ``@object2'))		methods: false		name: 'Use cascaded nextPutAll:''s instead of #, in #nextPutAll:'! !!TransformationRule class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRule class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRule class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRule class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRule class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRule class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRule class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRule class methodsFor: 'transformations' stamp: 'nk 3/5/2005 16:06'!translateLiteralsInMenus	^self 		rewrite: {				{					'`@menu add: `#label action: `#sym'.					'`@menu add: `#label translated action: `#sym'				}.				{					'`@menu add: `#label selector: `#sym arguments: `@stuff'.					'`@menu add: `#label translated selector: `#sym arguments: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff'.					'`@menu add: `#label translated subMenu: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.					'`@menu add: `#label translated subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu add: `#label target: `@targ action: `#sel'.					'`@menu add: `#label translated target: `@targ action: `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel'.					'`@menu add: `#label translated target: `@targ selector `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel argument: `@arg'				}.				{					'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel arguments: `@arg'				}.				{					'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.					'`@menu addTranslatedList: `{ :n :c | n }'				}.				{					'`@menu addTitle: `#label'.					'`@menu addTitle: `#label translated'				}.				{					'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.					'`@menu addTitle: `#label translated updatingSelector: `#sel updateTarget: `@targ'				}.				{					'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.					'`@menu addWithLabel: `#label translated enablement: `#esel action: `#sel'				}.				{					'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.					'`@menu addWithLabel: `#label translated enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu balloonTextForLastItem: `#label'.					'`@menu balloonTextForLastItem: `#label translated'				}.				{					'`@menu labels: `#lit lines: `@lines selections: `@sels'.					'`@menu labels: (`#lit collect: [ :l | l translated ]) lines: `@lines selections: `@sels'				}.				{					'`@menu title: `#title'.					'`@menu title: `#title translated'				}			}		methods: false		name: 'add translations to strings in menus'! !!TransformationRule class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRule class methodsFor: 'accessing' stamp: 'jws 10/23/2016 05:39'!initializeRecursiveSelfRule	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule		matchesAnyMethodOf:			#('`@methodName: `@args | `@temps | self `@methodName: `@args1' '`@methodName: `@args | `@temps | ^self `@methodName: `@args1')		do: [ :aNode :answer | true ].	^ RecursiveSelfRule! !!TransformationRule class methodsFor: 'accessing'!recursiveSelfRule	^RecursiveSelfRule isNil 		ifTrue: [self initializeRecursiveSelfRule]		ifFalse: [RecursiveSelfRule]! !!TransformationRule class methodsFor: 'instance creation' stamp: 'jws 10/23/2016 05:38'!rewrite: stringArrays methods: aBoolean name: aName	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays		do: [ :each | 			aBoolean				ifTrue: [ rewriteRule replaceMethod: each first with: each last ]				ifFalse: [ rewriteRule replace: each first with: each last ] ].	^ self new		name: aName;		rewriteUsing: rewriteRule;		yourself! !!TransformationRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]]! !!TransformationRuleTest methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRuleTest methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange new! !!TransformationRuleTest methodsFor: 'testing'!hasConflicts	^true! !!TransformationRuleTest methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRuleTest methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRuleTest methodsFor: 'rules' stamp: 'jws 10/23/2016 05:38'!superSends	| rule |	rule := ParseTreeRewriter new.	rule		addSearch:			'super `@message: ``@args'				->					([ :aNode | (class withAllSubclasses detect: [ :each | each includesSelector: aNode selector ] ifNone: [ nil ]) isNil ]						-> 'self `@message: ``@args').	self rewriteUsing: rule! !!TransformationRuleTest methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!TransformationRuleTest class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRuleTest class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRuleTest class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRuleTest class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRuleTest class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRuleTest class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRuleTest class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRuleTest class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRuleTest class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRuleTest class methodsFor: 'class initialization' stamp: 'jws 10/23/2016 05:39'!initializeAfterLoad1	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule		addMethodSearches:			#('`@methodName: `@args | `@temps | self `@methodName: `@args' '`@methodName: `@args | `@temps | ^self `@methodName: `@args')				-> [ :aNode :answer | true ]! !!TransformationRuleTest class methodsFor: 'class initialization'!nuke	RecursiveSelfRule := nil! !!TransformationRuleTest class methodsFor: 'instance creation' stamp: 'jws 10/23/2016 05:38'!rewrite: stringArrays methods: aBoolean name: aName	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays		do: [ :each | 			aBoolean				ifTrue: [ rewriteRule addMethodSearch: each first -> each last ]				ifFalse: [ rewriteRule addSearch: each first -> each last ] ].	^ self new		name: aName;		rewriteUsing: rewriteRule;		yourself! !!VariableEnvironment methodsFor: 'private'!accessorMethods	^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables)! !!VariableEnvironment methodsFor: 'private'!allClassesDo: aBlock 	| classes instVarBlock |	classes := Set new.	instVarBlock := 			[:each | 			| class |			class := self classForName: each.			classes addAll: class withAllSubclasses].	instanceVariables keysDo: instVarBlock.	instanceVariableReaders keysDo: instVarBlock.	instanceVariableWriters keysDo: instVarBlock.	classVariables keysDo: 			[:each | 			| class |			class := self classForName: each.			class notNil 				ifTrue: 					[classes						addAll: class withAllSubclasses;						addAll: class class withAllSubclasses]].	classes do: aBlock! !!VariableEnvironment methodsFor: 'private'!classForName: aString 	| name isMeta class |	isMeta := aString includes: $ .	name := (isMeta 				ifTrue: [aString copyFrom: 1 to: (aString size - 6 max: 1)]				ifFalse: [aString]) asSymbol.	class := Smalltalk at: name ifAbsent: [nil].	^class notNil & isMeta ifTrue: [class class] ifFalse: [class]! !!VariableEnvironment methodsFor: 'private' stamp: 'md 1/17/2006 14:17'!classVariableSelectorsFor: aClass 	| selectors classVars nonMetaClass |	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	selectors := Set new.	classVars := Set new.	classVariables keysDo: 			[:each | 			| cls |			cls := self classForName: each.			(cls notNil and: [nonMetaClass includesBehavior: cls]) 				ifTrue: [classVars addAll: (classVariables at: each)]].	classVars do: 			[:each | 			| binding |			binding := aClass bindingOf: each.			binding notNil 				ifTrue: [selectors addAll: (aClass whichSelectorsReferTo: binding)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!classVariables	^classVariables! !!VariableEnvironment methodsFor: 'private'!classVariables: anObject	classVariables := anObject! !!VariableEnvironment methodsFor: 'private'!computeSelectorCacheFor: aClass 	^(self instanceVariableSelectorsFor: aClass)		addAll: (self classVariableSelectorsFor: aClass);		yourself! !!VariableEnvironment methodsFor: 'private'!flushCachesFor: aClass 	| nonMetaClass |	selectorCache isNil ifTrue: [^self].	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	nonMetaClass withAllSubclasses do: 			[:each | 			selectorCache				removeKey: each ifAbsent: [];				removeKey: each class ifAbsent: []]! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders	^instanceVariableReaders! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders: anObject	instanceVariableReaders := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariableSelectorsFor: aClass 	| selectors |	selectors := Set new.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters) 		with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsAssign:)		do: 			[:var :sel | 			| instVars |			instVars := Set new.			(self perform: var) keysDo: 					[:each | 					| cls |					cls := self classForName: each.					(cls notNil and: [aClass includesBehavior: cls]) 						ifTrue: [instVars addAll: ((self perform: var) at: each)]].			instVars do: [:each | selectors addAll: (aClass perform: sel with: each)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters	^instanceVariableWriters! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters: anObject	instanceVariableWriters := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariables	^instanceVariables! !!VariableEnvironment methodsFor: 'private'!instanceVariables: anObject	instanceVariables := anObject! !!VariableEnvironment methodsFor: 'private'!selectorCache	^selectorCache isNil 		ifTrue: [selectorCache := Dictionary new]		ifFalse: [selectorCache]! !!VariableEnvironment methodsFor: 'private'!selectorCacheFor: aClass 	^self selectorCache at: aClass		ifAbsentPut: [self computeSelectorCacheFor: aClass]! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass classVariable: aSymbol 	(classVariables at: aClass name ifAbsentPut: [Set new]) add: aSymbol.	self flushCachesFor: aClass.	self addSearchString: aSymbol! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariable: aString 	(instanceVariables at: aClass name ifAbsentPut: [Set new]) add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableReader: aString 	(instanceVariableReaders at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableWriter: aString 	(instanceVariableWriters at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!classNamesWithVariables	| classNames |	classNames := Set new.	classNames		addAll: instanceVariables keys;		addAll: instanceVariableReaders keys;		addAll: instanceVariableWriters keys;		addAll: classVariables keys.	^classNames! !!VariableEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^classVariables at: aClass name ifAbsent: [#()]! !!VariableEnvironment methodsFor: 'accessing' stamp: 'md 1/17/2006 14:17'!environmentForClassVariable: aSymbol in: aClass 	| selectorEnvironment assoc block |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aSymbol.	((classVariables at: aClass name ifAbsent: [#()]) includes: aSymbol) 		ifFalse: [^selectorEnvironment].	assoc := aClass bindingOf: aSymbol.	block := 			[:each | 			(each whichSelectorsReferTo: assoc) 				do: [:sel | selectorEnvironment addClass: each selector: sel]].	aClass withAllSubAndSuperclassesDo: 			[:each | 			block				value: each;				value: each class].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'accessing' stamp: 'nk 2/26/2005 07:24'!environmentForInstanceVariable: aString in: aClass 	| selectorEnvironment isReader isWriter |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aString.	isReader := isWriter := false.	((instanceVariables at: aClass name ifAbsent: [#()]) includes: aString) 		ifTrue: 			[isReader := true.			isWriter := true].	((instanceVariableWriters at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isWriter := true].	((instanceVariableReaders at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isReader := true].	aClass withAllSubAndSuperclassesDo:			[:each | 			isWriter 				ifTrue: 					[(each whichSelectorsAssign: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]].			isReader 				ifTrue: 					[(each whichSelectorsRead: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]]].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	| vars name |	vars := Set new.	name := aClass name.	vars		addAll: (instanceVariables at: name ifAbsent: [#()]);		addAll: (instanceVariableReaders at: name ifAbsent: [#()]);		addAll: (instanceVariableWriters at: name ifAbsent: [#()]).	^vars! !!VariableEnvironment methodsFor: 'accessing'!numberVariables	^self accessorMethods inject: 0		into: [:sum :each | sum + ((self perform: each) inject: 0 into: [:s :e | s + e size])]! !!VariableEnvironment methodsFor: 'accessing'!problemCount	^self numberVariables! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass classVariable: aSymbol 	| vars |	vars := classVariables at: aClass name ifAbsent: [Set new].	vars remove: aSymbol ifAbsent: [].	vars isEmpty ifTrue: [classVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariable: aString 	| vars |	vars := instanceVariables at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableReader: aString 	| vars |	vars := instanceVariableReaders at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableReaders removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableWriter: aString 	| vars |	vars := instanceVariableWriters at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableWriters removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'copying'!copyDictionary: aDictionary 	| copy |	copy := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value | copy at: key put: value].	^copy! !!VariableEnvironment methodsFor: 'copying'!postCopy	super postCopy.	instanceVariables := self copyDictionary: instanceVariables.	instanceVariableReaders := self copyDictionary: instanceVariableReaders.	instanceVariableWriters := self copyDictionary: instanceVariableWriters.	classVariables := self copyDictionary: classVariables.	selectorCache := nil! !!VariableEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	(instanceVariables includesKey: aClass) ifTrue: [^true].	(classVariables includesKey: aClass) ifTrue: [^true].	^((self selectorCacheFor: aClass) 		detect: [:each | self includesSelector: each in: aClass]		ifNone: [nil]) notNil! !!VariableEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesSelector: aSymbol in: aClass 	^(environment includesSelector: aSymbol in: aClass) 		and: [(self selectorCacheFor: aClass) includes: aSymbol]! !!VariableEnvironment methodsFor: 'testing'!isEmpty	self accessorMethods 		do: [:each | (self perform: each) isEmpty ifFalse: [^false]].	^true! !!VariableEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	instanceVariables := Dictionary new.	classVariables := Dictionary new.	instanceVariableReaders := Dictionary new.	instanceVariableWriters := Dictionary new! !!VariableEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 18:10'!logOrInspect	Transcript cr; cr; show:self name.	instanceVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , '->' , variable asString]].	classVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , ' (cvar) ' , variable asString]].! !!VariableEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' new '.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables) 		do: 			[:each | 			aStream				nextPutAll: each;				nextPutAll: ': '.			(self perform: each) storeOn: aStream.			aStream nextPutAll: '; '].	aStream nextPutAll: ' yourself)'! !!VariableEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(VariableEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:20'!on: anEnvironment readersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Readers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsRead: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableReader: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'md 1/17/2006 14:17'!on: anEnvironment referencesToClassVariable: aSymbol in: aClass 	| newEnv definingClass assoc |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aSymbol , ''' in ' , aClass name;				yourself.	definingClass := aClass whichClassDefinesClassVar: aSymbol.	assoc := definingClass bindingOf: aSymbol.	definingClass withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsReferTo: assoc) isEmpty 				ifFalse: [newEnv addClass: cls classVariable: aSymbol]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:23'!on: anEnvironment referencesToInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			((cls whichSelectorsRead: aString) isEmpty not 				or: [(cls whichSelectorsAssign: aString) isEmpty not]) 					ifTrue: [newEnv addClass: cls instanceVariable: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:17'!on: anEnvironment writersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Writers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsAssign: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableWriter: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation'!readersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		readersOfInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToClassVariable: aSymbol in: aClass 	^self 		on: BrowserEnvironment new		referencesToClassVariable: aSymbol		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		referencesToInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!writersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		writersOfInstanceVariable: aString		in: aClass! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 3/4/2005 11:04'!addMorphicSwitchesTo: window 	^window! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 2/25/2005 16:39'!indicateClassMessages! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNamesWithVariables asSortedCollection! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 2/26/2005 12:04'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4)! !!VariableEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	| cls variables ranges firstRange firstQuote |	(cls := self selectedClassOrMetaClass) ifNil: [^1 to: 0].	variables := OrderedCollection 				withAll: (self browserEnvironment instanceVariablesFor: cls).	variables addAll: (self browserEnvironment classVariablesFor: cls).	firstQuote := self contents indexOf: $'.	firstQuote isZero ifTrue: [firstQuote := 1].	ranges := SortedCollection sortBlock: [:a :b | a first < b first].	ranges 		addAll: (variables collect: 					[:var | 					{ 						self contents 							indexOfSubCollection: var							startingAt: firstQuote							ifAbsent: self contents size.						var size}]).	firstRange := ranges at: 1 ifAbsent: [^1 to: 0].	^firstRange first to: firstRange first + firstRange second - 1! !!VariableEnvironmentBrowser methodsFor: 'nil' stamp: 'nk 3/2/2005 14:36'!instanceMessagesIndicated	^true! !!VariableEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:38'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: 			[self browserEnvironment instanceVariableSelectorsFor: self selectedClassOrMetaClass]		ifFalse: 			[self browserEnvironment classVariableSelectorsFor: self selectedClassOrMetaClass]) 			asSortedCollection! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!VariableEnvironmentTest methodsFor: 'tests'!testAddRemove	| refs |	refs := VariableEnvironment new.	refs addClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0! !!VariableEnvironmentTest methodsFor: 'tests'!testInstVars	| refs writers readers |	refs := VariableEnvironment referencesToInstanceVariable: 'refactorings'				in: RefactoringManager.	writers := VariableEnvironment writersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	readers := VariableEnvironment readersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	self universalTestFor: refs.	self universalTestFor: writers.	self universalTestFor: readers.	self assert: refs numberSelectors = (writers | readers) numberSelectors! !!VariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPut: $)! !!VariableRefactoring methodsFor: 'initialize-release'!variable: aVarName class: aClass 	class := self classObjectFor: aClass.	variableName := aVarName! !!AbstractClassVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!abstractClassReferences	| replacer |	replacer := ParseTreeRewriter		variable: variableName		getter: self accessorsRefactoring getterMethod		setter: self accessorsRefactoring setterMethod.	self		convertClasses: class metaclass withAllSubclasses		select: [ :aClass | 			(aClass whichSelectorsReferToClassVariable: variableName)				reject: [ :each | 					aClass == class metaclass						and: [ each == self accessorsRefactoring getterMethod or: [ each == self accessorsRefactoring setterMethod ] ] ] ]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!abstractInstanceReferences	| replacer |	replacer := ParseTreeRewriter		classVariable: variableName		getter: self accessorsRefactoring getterMethod		setter: self accessorsRefactoring setterMethod.	self		convertClasses: class withAllSubclasses		select: [ :aClass | aClass whichSelectorsReferToClassVariable: variableName ]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractInstanceReferences.	self abstractClassReferences! !!AbstractClassVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName asString						class: class						classVariable: true]		ifFalse: [accessorsRefactoring]! !!AbstractClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) 			& ((RBCondition withBlock: 						[(#(#Object #Behavior #ClassDescription #Class) includes: class name) not]) 					errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class')! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!abstractReferences	| replacer |	replacer := ParseTreeRewriter		variable: variableName		getter: self accessorsRefactoring getterMethod		setter: self accessorsRefactoring setterMethod.	self		convertClasses: class withAllSubclasses		select: [ :aClass | 			(aClass whichSelectorsReferToInstanceVariable: variableName)				reject: [ :each | 					aClass == class						and: [ each == self accessorsRefactoring getterMethod or: [ each == self accessorsRefactoring setterMethod ] ] ] ]		using: replacer! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractReferences! !!AbstractInstanceVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName						class: class						classVariable: false]		ifFalse: [accessorsRefactoring]! !!AbstractInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition directlyDefinesInstanceVariable: variableName in: class! !!AddClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: variableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: variableName asString) 					not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddClassVariableRefactoring methodsFor: 'transforming'!transform	class addClassVariable: variableName! !!AddInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: variableName for: class) 		& (RBCondition hierarchyOf: class definesVariable: variableName) not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddInstanceVariableRefactoring methodsFor: 'transforming'!transform	class addInstanceVariable: variableName! !!CreateAccessorsForVariableRefactoring methodsFor: 'initialize-release'!classVariable: aBoolean 	classVariable := aBoolean! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createGetterAccessor	getterMethod := self findGetterMethod.	getterMethod isNil ifTrue: [getterMethod := self defineGetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createSetterAccessor	setterMethod := self findSetterMethod.	setterMethod isNil ifTrue: [setterMethod := self defineSetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming' stamp: 'dc 4/4/2007 16:41'!defineGetterMethod	| selector definingClass |	definingClass := self definingClass.	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString.	definingClass 		compile: ('<1s><n><t>^ <2s>' expandMacrosWith: selector with: variableName)		classified: #(#accessing).	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming' stamp: 'dc 4/4/2007 16:41'!defineSetterMethod	| selector definingClass string |	definingClass := self definingClass.	string := self needsReturnForSetter 				ifTrue: ['<1s> anObject<n><t>^ <2s> := anObject']				ifFalse: ['<1s> anObject<n><t><2s> := anObject'].	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString , ':'.	definingClass 		compile: (string expandMacrosWith: selector with: variableName)		classified: #accessing.	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!transform	self		createGetterAccessor;		createSetterAccessor! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!definingClass	^classVariable ifTrue: [class metaclass] ifFalse: [class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing' stamp: 'jws 10/23/2016 05:39'!findGetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := ParseTreeSearcher getterMethod: variableName.	^ self possibleGetterSelectors		detect: [ :each | 			(self checkClass: definingClass selector: each using: matcher) notNil				and: [ (definingClass subclassRedefines: each) not ] ]		ifNone: [ nil ]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing' stamp: 'jws 10/23/2016 05:39'!findSetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := self needsReturnForSetter		ifTrue: [ ParseTreeSearcher returnSetterMethod: variableName ]		ifFalse: [ ParseTreeSearcher setterMethod: variableName ].	^ self possibleSetterSelectors		detect: [ :each | 			(self checkClass: definingClass selector: each using: matcher) notNil				and: [ (definingClass subclassRedefines: each) not ] ]		ifNone: [ nil ]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!getterMethod	^getterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!methodsReferencingVariable	^classVariable 		ifTrue: [self definingClass whichSelectorsReferToClassVariable: variableName]		ifFalse: 			[self definingClass whichSelectorsReferToInstanceVariable: variableName]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleGetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 0]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleSetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 1]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!setterMethod	^setterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing'!needsReturnForSetter	needsReturn isNil 		ifTrue: 			[needsReturn := self 						usesAssignmentOf: variableName						in: class						classVariable: classVariable].	^needsReturn! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing' stamp: 'jws 10/23/2016 05:39'!usesAssignmentOf: aString in: aClass classVariable: isClassVar	| matcher definingClass |	matcher := ParseTreeSearcher new.	matcher		answer: false;		matches: aString , ' := ``@object' do: [ :aNode :answer | answer or: [ aNode isUsed ] ].	definingClass := isClassVar		ifTrue: [ aClass nonMetaclass ]		ifFalse: [ aClass ].	^ (definingClass withAllSubclasses		,			(isClassVar				ifTrue: [ definingClass metaclass withAllSubclasses ]				ifFalse: [ #() ])		detect: [ :each | 			((isClassVar				ifTrue: [ each whichSelectorsReferToClassVariable: aString ]				ifFalse: [ each whichSelectorsReferToInstanceVariable: aString ])				detect: [ :sel | self checkClass: each selector: sel using: matcher ]				ifNone: [ nil ]) notNil ]		ifNone: [ nil ]) notNil! !!CreateAccessorsForVariableRefactoring methodsFor: 'preconditions'!preconditions	^classVariable 		ifTrue: [RBCondition definesClassVariable: variableName asSymbol in: class]		ifFalse: [RBCondition definesInstanceVariable: variableName in: class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' classVariable: '.	classVariable storeOn: aStream.	aStream nextPut: $)! !!ProtectInstanceVariableRefactoring methodsFor: 'private-accessing' stamp: 'jws 10/23/2016 05:39'!getterSetterMethods	| matcher |	matcher := ParseTreeSearcher new.	matcher		answer: Set new;		matchesAnyMethodOf:				(Array						with: '`method ^' , variableName						with: ('`method: `arg <1s> := `arg' expandMacrosWith: variableName)						with: ('`method: `arg ^<1s> := `arg' expandMacrosWith: variableName))			do: [ :aNode :answer | 				(class subclassRedefines: aNode selector)					ifFalse: [ answer add: aNode selector ].				answer ].	(class whichSelectorsReferToInstanceVariable: variableName)		do: [ :each | self checkClass: class selector: each using: matcher ].	^ matcher answer! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!inline: aSelector 	self onError: 			[self performComponentRefactoring: (InlineAllSendersRefactoring 						model: self model						sendersOf: aSelector						in: class)]		do: []! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!transform	self setOption: #inlineExpression toUse: [:ref :string | true].	self getterSetterMethods do: [:each | self inline: each]! !!ProtectInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition definesInstanceVariable: variableName in: class! !!PullUpClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not! !!PullUpClassVariableRefactoring methodsFor: 'private-accessing'!subclassDefiningVariable	| subclasses |	subclasses := class allSubclasses 				select: [:each | each directlyDefinesClassVariable: variableName].	subclasses isEmpty 		ifTrue: 			[self refactoringError: 'Could not find a class defining ' , variableName].	subclasses size > 1 		ifTrue: [self refactoringError: 'Multiple subclasses define ' , variableName].	^subclasses asArray first! !!PullUpClassVariableRefactoring methodsFor: 'transforming'!transform	| subclass |	subclass := self subclassDefiningVariable.	subclass removeClassVariable: variableName.	class addClassVariable: variableName! !!PullUpInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition withBlock: 			[(class hierarchyDefinesInstanceVariable: variableName) 				ifFalse: [self refactoringError: 'No subclass defines ' , variableName].			(class subclasses 				detect: [:each | (each directlyDefinesInstanceVariable: variableName) not]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringWarning: 'Not all subclasses have an instance variable named ' 								, variableName , '.'].			true]! !!PullUpInstanceVariableRefactoring methodsFor: 'transforming'!transform	class allSubclasses do: 			[:each | 			(each directlyDefinesInstanceVariable: variableName) 				ifTrue: [each removeInstanceVariable: variableName]].	class addInstanceVariable: variableName! !!PushDownClassVariableRefactoring methodsFor: 'preconditions' stamp: 'rr 3/11/2004 22:03'!findDestinationClass	| classVarName classes classVar cond |	classVarName := variableName asSymbol.	classVar := class realClass classPool associationAt: classVarName.	cond := [:eachClass | ((eachClass allCallsOn: classVar) 							select: [:eachRef | eachRef actualClass = eachClass])  isEmpty].	classes := class withAllSubclasses reject: [:each | (cond value: each realClass) 												and: [cond value: each realClass class]].	destinationClass := classes isEmpty ifTrue: [nil] ifFalse: [classes asOrderedCollection  first].	classes do: 			[:each | 			(destinationClass includesClass: each) 				ifTrue: [destinationClass := each]				ifFalse: 					[(each includesClass: destinationClass) 						ifFalse: [self signalMultipleReferenceError]]].	destinationClass = class ifTrue: [self signalStillReferencedError].	^destinationClass! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!preconditions	"Preconditions are that only one subclass refers to the class variable."	^(RBCondition definesClassVariable: variableName in: class) 		& (RBCondition withBlock: 					[self findDestinationClass.					true])! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalMultipleReferenceError	self signalReferenceError: ('Multiple subclasses reference <1s>' 				expandMacrosWith: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalReferenceError: errorString 	class realClass isNil 		ifTrue: [self refactoringError: errorString]		ifFalse: 			[| classVarName error |			error := '<1s><n>Browse references?' expandMacrosWith: errorString.			classVarName := variableName asSymbol.			self refactoringError: error				with: 					[self 						openBrowserOn: (VariableEnvironment referencesToClassVariable: classVarName								in: class realClass)]]! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalStillReferencedError	self signalReferenceError: ('<1p> has references to <2s>' 				expandMacrosWith: class				with: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName.	destinationClass isNil ifTrue: [^self].	destinationClass addClassVariable: variableName! !!PushDownInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition referencesInstanceVariable: variableName				in: class.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName in: class) 		& references not! !!PushDownInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName.	class subclasses do: 			[:each | 			(each withAllSubclasses detect: 					[:aClass | 					(aClass whichSelectorsReferToInstanceVariable: variableName) isEmpty not]				ifNone: [nil]) notNil 				ifTrue: [each addInstanceVariable: variableName]]! !!RemoveClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition definesClassVariable: variableName in: class) 			& (RBCondition withBlock: 						[| block |						block := 								[:each | 								(each whichSelectorsReferToClassVariable: variableName) isEmpty 									ifFalse: 										[class realClass isNil 											ifTrue: 												[self 													refactoringError: ('<1s> is referenced.' expandMacrosWith: variableName)]											ifFalse: 												[self refactoringError: ('<1s> is referenced.<n>Browse references?' 															expandMacrosWith: variableName)													with: 														[self 															openBrowserOn: (VariableEnvironment referencesToClassVariable: variableName																	in: class realClass)]]]].						class withAllSubclasses do: block.						class metaclass withAllSubclasses do: block.						true])! !!RemoveClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName! !!RemoveInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition hierarchyOf: class				referencesInstanceVariable: variableName.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName asString in: class) 		& references not! !!RemoveInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName! !!RenameClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: newName asString for: class) 			& (RBCondition definesClassVariable: variableName asString in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName asString) not 			& (RBCondition isGlobal: newName asString in: self model) not! !!RenameClassVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameClassVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!renameReferences	| replacer subclasses |	replacer := ParseTreeRewriter		rename: variableName		to: newName		handler: [ 			self				refactoringError:					('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses'						expandMacrosWith: newName) ].	subclasses := class withAllSubclasses asSet.	subclasses addAll: class metaclass withAllSubclasses.	self		convertClasses: subclasses		select: [ :aClass | aClass whichSelectorsReferToClassVariable: variableName ]		using: replacer! !!RenameClassVariableRefactoring methodsFor: 'transforming'!transform	class 		renameClassVariable: variableName		to: newName		around: [self renameReferences]! !!RenameClassVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!RenameInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: newName for: class) 		& (RBCondition definesInstanceVariable: variableName in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName) not 			& (RBCondition isGlobal: newName in: self model) not! !!RenameInstanceVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameInstanceVariableRefactoring methodsFor: 'transforming' stamp: 'jws 10/23/2016 05:38'!renameReferences	| replacer |	replacer := ParseTreeRewriter		rename: variableName		to: newName		handler: [ 			self				refactoringError:					('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses'						expandMacrosWith: newName) ].	self		convertClasses: class withAllSubclasses		select: [ :aClass | aClass whichSelectorsReferToInstanceVariable: variableName ]		using: replacer! !!RenameInstanceVariableRefactoring methodsFor: 'transforming'!transform	class 		renameInstanceVariable: variableName		to: newName		around: [self renameReferences]! !!RenameInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!VariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass 	^(self new)		model: aRBSmalltalk;		variable: aVarName class: aClass;		yourself! !!VariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass	^self new variable: aVarName class: aClass! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass classVariable: aBoolean 	^(self 		model: aRBSmalltalk		variable: aVarName		class: aClass)		classVariable: aBoolean;		yourself! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass classVariable: aBoolean 	^(self variable: aVarName class: aClass)		classVariable: aBoolean; yourself! !!RemoveInstanceVariableRefactoring class methodsFor: 'as yet unclassified' stamp: 'rr 3/11/2004 11:06'!remove: variable from: class	^ self variable: variable class:  class! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!VariableTypeTest methodsFor: 'tests'!testBasicLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'classBlock' in: BasicLintRuleTest.	"self assert: types size = 1."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	types := typer typesFor: 'methodBlock' in: (typer model classFor: BasicLintRuleTest).	"self should: [types size = 2]."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	"self should: [types includes: MessageChannel]."	typer printString! !!VariableTypeTest methodsFor: 'tests' stamp: 'bh 4/4/2000 09:32'!testCompositeLintRuleTypes	| typer types |	typer := RefactoryTyper new runOn: CompositeLintRuleTest.	types := typer guessTypesFor: 'rules'.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: Collection)).	types := typer typesFor: '-rules-'.	self assert: types size = 2.	self assert: (types includes: (typer model classFor: LintRule)).	self assert: (types includes: (typer model classFor: LintRuleTest)).	self assert: (typer guessTypesFor: 'asdf') isEmpty.	typer printString! !!VariableTypeTest methodsFor: 'tests'!testLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'name' in: LintRuleTest.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: String))! !!VariableTypeTest methodsFor: 'tests'!testParseTreeTypes	| types model |	model := RBNamespace new.	types := RefactoryTyper 				typesFor: 'foo'				in: (RBParser 						parseExpression: 'foo printString; testBasicLintRuleTypes; testParseTreeTypes')				model: model.	self assert: types size = 1.	self assert: (types includes: (model classFor: self class))! !RBConfigurableFormatter initialize!!RBProgramNodeVisitor reorganize!('visiting' visitArgumentNode: visitArgumentNodes: visitArrayNode: visitAssignmentNode: visitBlockNode: visitCascadeNode: visitLiteralArrayNode: visitLiteralNode: visitMessageNode: visitMethodNode: visitNode: visitParseErrorNode: visitPatternBlockNode: visitPatternWrapperBlockNode: visitPragmaNode: visitReturnNode: visitSelfNode: visitSequenceNode: visitSuperNode: visitTemporaryNode: visitTemporaryNodes: visitThisContextNode: visitVariableNode:)!RefactoringBrowser initialize!SmaCCShiftAction initialize!SmaCCScanner initialize!SmaCCRejectAction initialize!SmaCCParserGenerator initialize!SmaCCNode initialize!SmaCCGrammar initialize!RewriteTool initialize!RefactoryChangeManager initialize!RefactoringServiceProvider initialize!RBScanner initialize!RBAbstractClass initialize!LintDialog initialize!FinderTool initialize!ASTCache initialize!